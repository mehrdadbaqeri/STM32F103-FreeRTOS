
STM32F103-FreeRTOS.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000646c  08000110  08000110  00010110  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000039c  08006580  08006580  00016580  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800691c  0800691c  000201e0  2**0
                  CONTENTS
  4 .ARM          00000000  0800691c  0800691c  000201e0  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800691c  0800691c  000201e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800691c  0800691c  0001691c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08006920  08006920  00016920  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000001e0  20000000  08006924  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001b5c  200001e0  08006b04  000201e0  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  20001d3c  08006b04  00021d3c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  000201e0  2**0
                  CONTENTS, READONLY
 12 .debug_info   000261c4  00000000  00000000  00020209  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00004b35  00000000  00000000  000463cd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00015c5f  00000000  00000000  0004af02  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 000013d8  00000000  00000000  00060b68  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 000025f0  00000000  00000000  00061f40  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  0001a28e  00000000  00000000  00064530  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0001519e  00000000  00000000  0007e7be  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    000999d6  00000000  00000000  0009395c  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  0012d332  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00004fc8  00000000  00000000  0012d3b0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000110 <__do_global_dtors_aux>:
 8000110:	b510      	push	{r4, lr}
 8000112:	4c05      	ldr	r4, [pc, #20]	; (8000128 <__do_global_dtors_aux+0x18>)
 8000114:	7823      	ldrb	r3, [r4, #0]
 8000116:	b933      	cbnz	r3, 8000126 <__do_global_dtors_aux+0x16>
 8000118:	4b04      	ldr	r3, [pc, #16]	; (800012c <__do_global_dtors_aux+0x1c>)
 800011a:	b113      	cbz	r3, 8000122 <__do_global_dtors_aux+0x12>
 800011c:	4804      	ldr	r0, [pc, #16]	; (8000130 <__do_global_dtors_aux+0x20>)
 800011e:	f3af 8000 	nop.w
 8000122:	2301      	movs	r3, #1
 8000124:	7023      	strb	r3, [r4, #0]
 8000126:	bd10      	pop	{r4, pc}
 8000128:	200001e0 	.word	0x200001e0
 800012c:	00000000 	.word	0x00000000
 8000130:	08006564 	.word	0x08006564

08000134 <frame_dummy>:
 8000134:	b508      	push	{r3, lr}
 8000136:	4b03      	ldr	r3, [pc, #12]	; (8000144 <frame_dummy+0x10>)
 8000138:	b11b      	cbz	r3, 8000142 <frame_dummy+0xe>
 800013a:	4903      	ldr	r1, [pc, #12]	; (8000148 <frame_dummy+0x14>)
 800013c:	4803      	ldr	r0, [pc, #12]	; (800014c <frame_dummy+0x18>)
 800013e:	f3af 8000 	nop.w
 8000142:	bd08      	pop	{r3, pc}
 8000144:	00000000 	.word	0x00000000
 8000148:	200001e4 	.word	0x200001e4
 800014c:	08006564 	.word	0x08006564

08000150 <strlen>:
 8000150:	4603      	mov	r3, r0
 8000152:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000156:	2a00      	cmp	r2, #0
 8000158:	d1fb      	bne.n	8000152 <strlen+0x2>
 800015a:	1a18      	subs	r0, r3, r0
 800015c:	3801      	subs	r0, #1
 800015e:	4770      	bx	lr

08000160 <__aeabi_drsub>:
 8000160:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000164:	e002      	b.n	800016c <__adddf3>
 8000166:	bf00      	nop

08000168 <__aeabi_dsub>:
 8000168:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0800016c <__adddf3>:
 800016c:	b530      	push	{r4, r5, lr}
 800016e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000172:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000176:	ea94 0f05 	teq	r4, r5
 800017a:	bf08      	it	eq
 800017c:	ea90 0f02 	teqeq	r0, r2
 8000180:	bf1f      	itttt	ne
 8000182:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000186:	ea55 0c02 	orrsne.w	ip, r5, r2
 800018a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800018e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000192:	f000 80e2 	beq.w	800035a <__adddf3+0x1ee>
 8000196:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800019a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800019e:	bfb8      	it	lt
 80001a0:	426d      	neglt	r5, r5
 80001a2:	dd0c      	ble.n	80001be <__adddf3+0x52>
 80001a4:	442c      	add	r4, r5
 80001a6:	ea80 0202 	eor.w	r2, r0, r2
 80001aa:	ea81 0303 	eor.w	r3, r1, r3
 80001ae:	ea82 0000 	eor.w	r0, r2, r0
 80001b2:	ea83 0101 	eor.w	r1, r3, r1
 80001b6:	ea80 0202 	eor.w	r2, r0, r2
 80001ba:	ea81 0303 	eor.w	r3, r1, r3
 80001be:	2d36      	cmp	r5, #54	; 0x36
 80001c0:	bf88      	it	hi
 80001c2:	bd30      	pophi	{r4, r5, pc}
 80001c4:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80001c8:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80001cc:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80001d0:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80001d4:	d002      	beq.n	80001dc <__adddf3+0x70>
 80001d6:	4240      	negs	r0, r0
 80001d8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80001dc:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80001e0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80001e4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80001e8:	d002      	beq.n	80001f0 <__adddf3+0x84>
 80001ea:	4252      	negs	r2, r2
 80001ec:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80001f0:	ea94 0f05 	teq	r4, r5
 80001f4:	f000 80a7 	beq.w	8000346 <__adddf3+0x1da>
 80001f8:	f1a4 0401 	sub.w	r4, r4, #1
 80001fc:	f1d5 0e20 	rsbs	lr, r5, #32
 8000200:	db0d      	blt.n	800021e <__adddf3+0xb2>
 8000202:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000206:	fa22 f205 	lsr.w	r2, r2, r5
 800020a:	1880      	adds	r0, r0, r2
 800020c:	f141 0100 	adc.w	r1, r1, #0
 8000210:	fa03 f20e 	lsl.w	r2, r3, lr
 8000214:	1880      	adds	r0, r0, r2
 8000216:	fa43 f305 	asr.w	r3, r3, r5
 800021a:	4159      	adcs	r1, r3
 800021c:	e00e      	b.n	800023c <__adddf3+0xd0>
 800021e:	f1a5 0520 	sub.w	r5, r5, #32
 8000222:	f10e 0e20 	add.w	lr, lr, #32
 8000226:	2a01      	cmp	r2, #1
 8000228:	fa03 fc0e 	lsl.w	ip, r3, lr
 800022c:	bf28      	it	cs
 800022e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000232:	fa43 f305 	asr.w	r3, r3, r5
 8000236:	18c0      	adds	r0, r0, r3
 8000238:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800023c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000240:	d507      	bpl.n	8000252 <__adddf3+0xe6>
 8000242:	f04f 0e00 	mov.w	lr, #0
 8000246:	f1dc 0c00 	rsbs	ip, ip, #0
 800024a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800024e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000252:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8000256:	d31b      	bcc.n	8000290 <__adddf3+0x124>
 8000258:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 800025c:	d30c      	bcc.n	8000278 <__adddf3+0x10c>
 800025e:	0849      	lsrs	r1, r1, #1
 8000260:	ea5f 0030 	movs.w	r0, r0, rrx
 8000264:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000268:	f104 0401 	add.w	r4, r4, #1
 800026c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000270:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000274:	f080 809a 	bcs.w	80003ac <__adddf3+0x240>
 8000278:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 800027c:	bf08      	it	eq
 800027e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000282:	f150 0000 	adcs.w	r0, r0, #0
 8000286:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800028a:	ea41 0105 	orr.w	r1, r1, r5
 800028e:	bd30      	pop	{r4, r5, pc}
 8000290:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000294:	4140      	adcs	r0, r0
 8000296:	eb41 0101 	adc.w	r1, r1, r1
 800029a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800029e:	f1a4 0401 	sub.w	r4, r4, #1
 80002a2:	d1e9      	bne.n	8000278 <__adddf3+0x10c>
 80002a4:	f091 0f00 	teq	r1, #0
 80002a8:	bf04      	itt	eq
 80002aa:	4601      	moveq	r1, r0
 80002ac:	2000      	moveq	r0, #0
 80002ae:	fab1 f381 	clz	r3, r1
 80002b2:	bf08      	it	eq
 80002b4:	3320      	addeq	r3, #32
 80002b6:	f1a3 030b 	sub.w	r3, r3, #11
 80002ba:	f1b3 0220 	subs.w	r2, r3, #32
 80002be:	da0c      	bge.n	80002da <__adddf3+0x16e>
 80002c0:	320c      	adds	r2, #12
 80002c2:	dd08      	ble.n	80002d6 <__adddf3+0x16a>
 80002c4:	f102 0c14 	add.w	ip, r2, #20
 80002c8:	f1c2 020c 	rsb	r2, r2, #12
 80002cc:	fa01 f00c 	lsl.w	r0, r1, ip
 80002d0:	fa21 f102 	lsr.w	r1, r1, r2
 80002d4:	e00c      	b.n	80002f0 <__adddf3+0x184>
 80002d6:	f102 0214 	add.w	r2, r2, #20
 80002da:	bfd8      	it	le
 80002dc:	f1c2 0c20 	rsble	ip, r2, #32
 80002e0:	fa01 f102 	lsl.w	r1, r1, r2
 80002e4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80002e8:	bfdc      	itt	le
 80002ea:	ea41 010c 	orrle.w	r1, r1, ip
 80002ee:	4090      	lslle	r0, r2
 80002f0:	1ae4      	subs	r4, r4, r3
 80002f2:	bfa2      	ittt	ge
 80002f4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80002f8:	4329      	orrge	r1, r5
 80002fa:	bd30      	popge	{r4, r5, pc}
 80002fc:	ea6f 0404 	mvn.w	r4, r4
 8000300:	3c1f      	subs	r4, #31
 8000302:	da1c      	bge.n	800033e <__adddf3+0x1d2>
 8000304:	340c      	adds	r4, #12
 8000306:	dc0e      	bgt.n	8000326 <__adddf3+0x1ba>
 8000308:	f104 0414 	add.w	r4, r4, #20
 800030c:	f1c4 0220 	rsb	r2, r4, #32
 8000310:	fa20 f004 	lsr.w	r0, r0, r4
 8000314:	fa01 f302 	lsl.w	r3, r1, r2
 8000318:	ea40 0003 	orr.w	r0, r0, r3
 800031c:	fa21 f304 	lsr.w	r3, r1, r4
 8000320:	ea45 0103 	orr.w	r1, r5, r3
 8000324:	bd30      	pop	{r4, r5, pc}
 8000326:	f1c4 040c 	rsb	r4, r4, #12
 800032a:	f1c4 0220 	rsb	r2, r4, #32
 800032e:	fa20 f002 	lsr.w	r0, r0, r2
 8000332:	fa01 f304 	lsl.w	r3, r1, r4
 8000336:	ea40 0003 	orr.w	r0, r0, r3
 800033a:	4629      	mov	r1, r5
 800033c:	bd30      	pop	{r4, r5, pc}
 800033e:	fa21 f004 	lsr.w	r0, r1, r4
 8000342:	4629      	mov	r1, r5
 8000344:	bd30      	pop	{r4, r5, pc}
 8000346:	f094 0f00 	teq	r4, #0
 800034a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800034e:	bf06      	itte	eq
 8000350:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 8000354:	3401      	addeq	r4, #1
 8000356:	3d01      	subne	r5, #1
 8000358:	e74e      	b.n	80001f8 <__adddf3+0x8c>
 800035a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800035e:	bf18      	it	ne
 8000360:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000364:	d029      	beq.n	80003ba <__adddf3+0x24e>
 8000366:	ea94 0f05 	teq	r4, r5
 800036a:	bf08      	it	eq
 800036c:	ea90 0f02 	teqeq	r0, r2
 8000370:	d005      	beq.n	800037e <__adddf3+0x212>
 8000372:	ea54 0c00 	orrs.w	ip, r4, r0
 8000376:	bf04      	itt	eq
 8000378:	4619      	moveq	r1, r3
 800037a:	4610      	moveq	r0, r2
 800037c:	bd30      	pop	{r4, r5, pc}
 800037e:	ea91 0f03 	teq	r1, r3
 8000382:	bf1e      	ittt	ne
 8000384:	2100      	movne	r1, #0
 8000386:	2000      	movne	r0, #0
 8000388:	bd30      	popne	{r4, r5, pc}
 800038a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800038e:	d105      	bne.n	800039c <__adddf3+0x230>
 8000390:	0040      	lsls	r0, r0, #1
 8000392:	4149      	adcs	r1, r1
 8000394:	bf28      	it	cs
 8000396:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800039a:	bd30      	pop	{r4, r5, pc}
 800039c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80003a0:	bf3c      	itt	cc
 80003a2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80003a6:	bd30      	popcc	{r4, r5, pc}
 80003a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003ac:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80003b0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80003b4:	f04f 0000 	mov.w	r0, #0
 80003b8:	bd30      	pop	{r4, r5, pc}
 80003ba:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80003be:	bf1a      	itte	ne
 80003c0:	4619      	movne	r1, r3
 80003c2:	4610      	movne	r0, r2
 80003c4:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80003c8:	bf1c      	itt	ne
 80003ca:	460b      	movne	r3, r1
 80003cc:	4602      	movne	r2, r0
 80003ce:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80003d2:	bf06      	itte	eq
 80003d4:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80003d8:	ea91 0f03 	teqeq	r1, r3
 80003dc:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80003e0:	bd30      	pop	{r4, r5, pc}
 80003e2:	bf00      	nop

080003e4 <__aeabi_ui2d>:
 80003e4:	f090 0f00 	teq	r0, #0
 80003e8:	bf04      	itt	eq
 80003ea:	2100      	moveq	r1, #0
 80003ec:	4770      	bxeq	lr
 80003ee:	b530      	push	{r4, r5, lr}
 80003f0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80003f4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80003f8:	f04f 0500 	mov.w	r5, #0
 80003fc:	f04f 0100 	mov.w	r1, #0
 8000400:	e750      	b.n	80002a4 <__adddf3+0x138>
 8000402:	bf00      	nop

08000404 <__aeabi_i2d>:
 8000404:	f090 0f00 	teq	r0, #0
 8000408:	bf04      	itt	eq
 800040a:	2100      	moveq	r1, #0
 800040c:	4770      	bxeq	lr
 800040e:	b530      	push	{r4, r5, lr}
 8000410:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000414:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000418:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800041c:	bf48      	it	mi
 800041e:	4240      	negmi	r0, r0
 8000420:	f04f 0100 	mov.w	r1, #0
 8000424:	e73e      	b.n	80002a4 <__adddf3+0x138>
 8000426:	bf00      	nop

08000428 <__aeabi_f2d>:
 8000428:	0042      	lsls	r2, r0, #1
 800042a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800042e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000432:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000436:	bf1f      	itttt	ne
 8000438:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800043c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000440:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000444:	4770      	bxne	lr
 8000446:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 800044a:	bf08      	it	eq
 800044c:	4770      	bxeq	lr
 800044e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 8000452:	bf04      	itt	eq
 8000454:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000458:	4770      	bxeq	lr
 800045a:	b530      	push	{r4, r5, lr}
 800045c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000460:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000464:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000468:	e71c      	b.n	80002a4 <__adddf3+0x138>
 800046a:	bf00      	nop

0800046c <__aeabi_ul2d>:
 800046c:	ea50 0201 	orrs.w	r2, r0, r1
 8000470:	bf08      	it	eq
 8000472:	4770      	bxeq	lr
 8000474:	b530      	push	{r4, r5, lr}
 8000476:	f04f 0500 	mov.w	r5, #0
 800047a:	e00a      	b.n	8000492 <__aeabi_l2d+0x16>

0800047c <__aeabi_l2d>:
 800047c:	ea50 0201 	orrs.w	r2, r0, r1
 8000480:	bf08      	it	eq
 8000482:	4770      	bxeq	lr
 8000484:	b530      	push	{r4, r5, lr}
 8000486:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800048a:	d502      	bpl.n	8000492 <__aeabi_l2d+0x16>
 800048c:	4240      	negs	r0, r0
 800048e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000492:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000496:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800049a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800049e:	f43f aed8 	beq.w	8000252 <__adddf3+0xe6>
 80004a2:	f04f 0203 	mov.w	r2, #3
 80004a6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004aa:	bf18      	it	ne
 80004ac:	3203      	addne	r2, #3
 80004ae:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80004b2:	bf18      	it	ne
 80004b4:	3203      	addne	r2, #3
 80004b6:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80004ba:	f1c2 0320 	rsb	r3, r2, #32
 80004be:	fa00 fc03 	lsl.w	ip, r0, r3
 80004c2:	fa20 f002 	lsr.w	r0, r0, r2
 80004c6:	fa01 fe03 	lsl.w	lr, r1, r3
 80004ca:	ea40 000e 	orr.w	r0, r0, lr
 80004ce:	fa21 f102 	lsr.w	r1, r1, r2
 80004d2:	4414      	add	r4, r2
 80004d4:	e6bd      	b.n	8000252 <__adddf3+0xe6>
 80004d6:	bf00      	nop

080004d8 <__aeabi_dmul>:
 80004d8:	b570      	push	{r4, r5, r6, lr}
 80004da:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80004de:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80004e2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80004e6:	bf1d      	ittte	ne
 80004e8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80004ec:	ea94 0f0c 	teqne	r4, ip
 80004f0:	ea95 0f0c 	teqne	r5, ip
 80004f4:	f000 f8de 	bleq	80006b4 <__aeabi_dmul+0x1dc>
 80004f8:	442c      	add	r4, r5
 80004fa:	ea81 0603 	eor.w	r6, r1, r3
 80004fe:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000502:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8000506:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800050a:	bf18      	it	ne
 800050c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000510:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000514:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000518:	d038      	beq.n	800058c <__aeabi_dmul+0xb4>
 800051a:	fba0 ce02 	umull	ip, lr, r0, r2
 800051e:	f04f 0500 	mov.w	r5, #0
 8000522:	fbe1 e502 	umlal	lr, r5, r1, r2
 8000526:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 800052a:	fbe0 e503 	umlal	lr, r5, r0, r3
 800052e:	f04f 0600 	mov.w	r6, #0
 8000532:	fbe1 5603 	umlal	r5, r6, r1, r3
 8000536:	f09c 0f00 	teq	ip, #0
 800053a:	bf18      	it	ne
 800053c:	f04e 0e01 	orrne.w	lr, lr, #1
 8000540:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8000544:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000548:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 800054c:	d204      	bcs.n	8000558 <__aeabi_dmul+0x80>
 800054e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8000552:	416d      	adcs	r5, r5
 8000554:	eb46 0606 	adc.w	r6, r6, r6
 8000558:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 800055c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000560:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8000564:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000568:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 800056c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000570:	bf88      	it	hi
 8000572:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000576:	d81e      	bhi.n	80005b6 <__aeabi_dmul+0xde>
 8000578:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 800057c:	bf08      	it	eq
 800057e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000582:	f150 0000 	adcs.w	r0, r0, #0
 8000586:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800058a:	bd70      	pop	{r4, r5, r6, pc}
 800058c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000590:	ea46 0101 	orr.w	r1, r6, r1
 8000594:	ea40 0002 	orr.w	r0, r0, r2
 8000598:	ea81 0103 	eor.w	r1, r1, r3
 800059c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80005a0:	bfc2      	ittt	gt
 80005a2:	ebd4 050c 	rsbsgt	r5, r4, ip
 80005a6:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80005aa:	bd70      	popgt	{r4, r5, r6, pc}
 80005ac:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80005b0:	f04f 0e00 	mov.w	lr, #0
 80005b4:	3c01      	subs	r4, #1
 80005b6:	f300 80ab 	bgt.w	8000710 <__aeabi_dmul+0x238>
 80005ba:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80005be:	bfde      	ittt	le
 80005c0:	2000      	movle	r0, #0
 80005c2:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80005c6:	bd70      	pople	{r4, r5, r6, pc}
 80005c8:	f1c4 0400 	rsb	r4, r4, #0
 80005cc:	3c20      	subs	r4, #32
 80005ce:	da35      	bge.n	800063c <__aeabi_dmul+0x164>
 80005d0:	340c      	adds	r4, #12
 80005d2:	dc1b      	bgt.n	800060c <__aeabi_dmul+0x134>
 80005d4:	f104 0414 	add.w	r4, r4, #20
 80005d8:	f1c4 0520 	rsb	r5, r4, #32
 80005dc:	fa00 f305 	lsl.w	r3, r0, r5
 80005e0:	fa20 f004 	lsr.w	r0, r0, r4
 80005e4:	fa01 f205 	lsl.w	r2, r1, r5
 80005e8:	ea40 0002 	orr.w	r0, r0, r2
 80005ec:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80005f0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005f4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80005f8:	fa21 f604 	lsr.w	r6, r1, r4
 80005fc:	eb42 0106 	adc.w	r1, r2, r6
 8000600:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000604:	bf08      	it	eq
 8000606:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800060a:	bd70      	pop	{r4, r5, r6, pc}
 800060c:	f1c4 040c 	rsb	r4, r4, #12
 8000610:	f1c4 0520 	rsb	r5, r4, #32
 8000614:	fa00 f304 	lsl.w	r3, r0, r4
 8000618:	fa20 f005 	lsr.w	r0, r0, r5
 800061c:	fa01 f204 	lsl.w	r2, r1, r4
 8000620:	ea40 0002 	orr.w	r0, r0, r2
 8000624:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000628:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800062c:	f141 0100 	adc.w	r1, r1, #0
 8000630:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000634:	bf08      	it	eq
 8000636:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800063a:	bd70      	pop	{r4, r5, r6, pc}
 800063c:	f1c4 0520 	rsb	r5, r4, #32
 8000640:	fa00 f205 	lsl.w	r2, r0, r5
 8000644:	ea4e 0e02 	orr.w	lr, lr, r2
 8000648:	fa20 f304 	lsr.w	r3, r0, r4
 800064c:	fa01 f205 	lsl.w	r2, r1, r5
 8000650:	ea43 0302 	orr.w	r3, r3, r2
 8000654:	fa21 f004 	lsr.w	r0, r1, r4
 8000658:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800065c:	fa21 f204 	lsr.w	r2, r1, r4
 8000660:	ea20 0002 	bic.w	r0, r0, r2
 8000664:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000668:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800066c:	bf08      	it	eq
 800066e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000672:	bd70      	pop	{r4, r5, r6, pc}
 8000674:	f094 0f00 	teq	r4, #0
 8000678:	d10f      	bne.n	800069a <__aeabi_dmul+0x1c2>
 800067a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800067e:	0040      	lsls	r0, r0, #1
 8000680:	eb41 0101 	adc.w	r1, r1, r1
 8000684:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000688:	bf08      	it	eq
 800068a:	3c01      	subeq	r4, #1
 800068c:	d0f7      	beq.n	800067e <__aeabi_dmul+0x1a6>
 800068e:	ea41 0106 	orr.w	r1, r1, r6
 8000692:	f095 0f00 	teq	r5, #0
 8000696:	bf18      	it	ne
 8000698:	4770      	bxne	lr
 800069a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800069e:	0052      	lsls	r2, r2, #1
 80006a0:	eb43 0303 	adc.w	r3, r3, r3
 80006a4:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80006a8:	bf08      	it	eq
 80006aa:	3d01      	subeq	r5, #1
 80006ac:	d0f7      	beq.n	800069e <__aeabi_dmul+0x1c6>
 80006ae:	ea43 0306 	orr.w	r3, r3, r6
 80006b2:	4770      	bx	lr
 80006b4:	ea94 0f0c 	teq	r4, ip
 80006b8:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80006bc:	bf18      	it	ne
 80006be:	ea95 0f0c 	teqne	r5, ip
 80006c2:	d00c      	beq.n	80006de <__aeabi_dmul+0x206>
 80006c4:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80006c8:	bf18      	it	ne
 80006ca:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80006ce:	d1d1      	bne.n	8000674 <__aeabi_dmul+0x19c>
 80006d0:	ea81 0103 	eor.w	r1, r1, r3
 80006d4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80006d8:	f04f 0000 	mov.w	r0, #0
 80006dc:	bd70      	pop	{r4, r5, r6, pc}
 80006de:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80006e2:	bf06      	itte	eq
 80006e4:	4610      	moveq	r0, r2
 80006e6:	4619      	moveq	r1, r3
 80006e8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80006ec:	d019      	beq.n	8000722 <__aeabi_dmul+0x24a>
 80006ee:	ea94 0f0c 	teq	r4, ip
 80006f2:	d102      	bne.n	80006fa <__aeabi_dmul+0x222>
 80006f4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80006f8:	d113      	bne.n	8000722 <__aeabi_dmul+0x24a>
 80006fa:	ea95 0f0c 	teq	r5, ip
 80006fe:	d105      	bne.n	800070c <__aeabi_dmul+0x234>
 8000700:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000704:	bf1c      	itt	ne
 8000706:	4610      	movne	r0, r2
 8000708:	4619      	movne	r1, r3
 800070a:	d10a      	bne.n	8000722 <__aeabi_dmul+0x24a>
 800070c:	ea81 0103 	eor.w	r1, r1, r3
 8000710:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000714:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000718:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800071c:	f04f 0000 	mov.w	r0, #0
 8000720:	bd70      	pop	{r4, r5, r6, pc}
 8000722:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000726:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800072a:	bd70      	pop	{r4, r5, r6, pc}

0800072c <__aeabi_ddiv>:
 800072c:	b570      	push	{r4, r5, r6, lr}
 800072e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000732:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000736:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800073a:	bf1d      	ittte	ne
 800073c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000740:	ea94 0f0c 	teqne	r4, ip
 8000744:	ea95 0f0c 	teqne	r5, ip
 8000748:	f000 f8a7 	bleq	800089a <__aeabi_ddiv+0x16e>
 800074c:	eba4 0405 	sub.w	r4, r4, r5
 8000750:	ea81 0e03 	eor.w	lr, r1, r3
 8000754:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000758:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800075c:	f000 8088 	beq.w	8000870 <__aeabi_ddiv+0x144>
 8000760:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000764:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000768:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800076c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000770:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000774:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000778:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800077c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000780:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000784:	429d      	cmp	r5, r3
 8000786:	bf08      	it	eq
 8000788:	4296      	cmpeq	r6, r2
 800078a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800078e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000792:	d202      	bcs.n	800079a <__aeabi_ddiv+0x6e>
 8000794:	085b      	lsrs	r3, r3, #1
 8000796:	ea4f 0232 	mov.w	r2, r2, rrx
 800079a:	1ab6      	subs	r6, r6, r2
 800079c:	eb65 0503 	sbc.w	r5, r5, r3
 80007a0:	085b      	lsrs	r3, r3, #1
 80007a2:	ea4f 0232 	mov.w	r2, r2, rrx
 80007a6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80007aa:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80007ae:	ebb6 0e02 	subs.w	lr, r6, r2
 80007b2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80007b6:	bf22      	ittt	cs
 80007b8:	1ab6      	subcs	r6, r6, r2
 80007ba:	4675      	movcs	r5, lr
 80007bc:	ea40 000c 	orrcs.w	r0, r0, ip
 80007c0:	085b      	lsrs	r3, r3, #1
 80007c2:	ea4f 0232 	mov.w	r2, r2, rrx
 80007c6:	ebb6 0e02 	subs.w	lr, r6, r2
 80007ca:	eb75 0e03 	sbcs.w	lr, r5, r3
 80007ce:	bf22      	ittt	cs
 80007d0:	1ab6      	subcs	r6, r6, r2
 80007d2:	4675      	movcs	r5, lr
 80007d4:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80007d8:	085b      	lsrs	r3, r3, #1
 80007da:	ea4f 0232 	mov.w	r2, r2, rrx
 80007de:	ebb6 0e02 	subs.w	lr, r6, r2
 80007e2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80007e6:	bf22      	ittt	cs
 80007e8:	1ab6      	subcs	r6, r6, r2
 80007ea:	4675      	movcs	r5, lr
 80007ec:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80007f0:	085b      	lsrs	r3, r3, #1
 80007f2:	ea4f 0232 	mov.w	r2, r2, rrx
 80007f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80007fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80007fe:	bf22      	ittt	cs
 8000800:	1ab6      	subcs	r6, r6, r2
 8000802:	4675      	movcs	r5, lr
 8000804:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000808:	ea55 0e06 	orrs.w	lr, r5, r6
 800080c:	d018      	beq.n	8000840 <__aeabi_ddiv+0x114>
 800080e:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000812:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000816:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800081a:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800081e:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000822:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000826:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800082a:	d1c0      	bne.n	80007ae <__aeabi_ddiv+0x82>
 800082c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000830:	d10b      	bne.n	800084a <__aeabi_ddiv+0x11e>
 8000832:	ea41 0100 	orr.w	r1, r1, r0
 8000836:	f04f 0000 	mov.w	r0, #0
 800083a:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800083e:	e7b6      	b.n	80007ae <__aeabi_ddiv+0x82>
 8000840:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000844:	bf04      	itt	eq
 8000846:	4301      	orreq	r1, r0
 8000848:	2000      	moveq	r0, #0
 800084a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800084e:	bf88      	it	hi
 8000850:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000854:	f63f aeaf 	bhi.w	80005b6 <__aeabi_dmul+0xde>
 8000858:	ebb5 0c03 	subs.w	ip, r5, r3
 800085c:	bf04      	itt	eq
 800085e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000862:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000866:	f150 0000 	adcs.w	r0, r0, #0
 800086a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800086e:	bd70      	pop	{r4, r5, r6, pc}
 8000870:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000874:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000878:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800087c:	bfc2      	ittt	gt
 800087e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000882:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000886:	bd70      	popgt	{r4, r5, r6, pc}
 8000888:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800088c:	f04f 0e00 	mov.w	lr, #0
 8000890:	3c01      	subs	r4, #1
 8000892:	e690      	b.n	80005b6 <__aeabi_dmul+0xde>
 8000894:	ea45 0e06 	orr.w	lr, r5, r6
 8000898:	e68d      	b.n	80005b6 <__aeabi_dmul+0xde>
 800089a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800089e:	ea94 0f0c 	teq	r4, ip
 80008a2:	bf08      	it	eq
 80008a4:	ea95 0f0c 	teqeq	r5, ip
 80008a8:	f43f af3b 	beq.w	8000722 <__aeabi_dmul+0x24a>
 80008ac:	ea94 0f0c 	teq	r4, ip
 80008b0:	d10a      	bne.n	80008c8 <__aeabi_ddiv+0x19c>
 80008b2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80008b6:	f47f af34 	bne.w	8000722 <__aeabi_dmul+0x24a>
 80008ba:	ea95 0f0c 	teq	r5, ip
 80008be:	f47f af25 	bne.w	800070c <__aeabi_dmul+0x234>
 80008c2:	4610      	mov	r0, r2
 80008c4:	4619      	mov	r1, r3
 80008c6:	e72c      	b.n	8000722 <__aeabi_dmul+0x24a>
 80008c8:	ea95 0f0c 	teq	r5, ip
 80008cc:	d106      	bne.n	80008dc <__aeabi_ddiv+0x1b0>
 80008ce:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008d2:	f43f aefd 	beq.w	80006d0 <__aeabi_dmul+0x1f8>
 80008d6:	4610      	mov	r0, r2
 80008d8:	4619      	mov	r1, r3
 80008da:	e722      	b.n	8000722 <__aeabi_dmul+0x24a>
 80008dc:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80008e0:	bf18      	it	ne
 80008e2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80008e6:	f47f aec5 	bne.w	8000674 <__aeabi_dmul+0x19c>
 80008ea:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80008ee:	f47f af0d 	bne.w	800070c <__aeabi_dmul+0x234>
 80008f2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80008f6:	f47f aeeb 	bne.w	80006d0 <__aeabi_dmul+0x1f8>
 80008fa:	e712      	b.n	8000722 <__aeabi_dmul+0x24a>

080008fc <__gedf2>:
 80008fc:	f04f 3cff 	mov.w	ip, #4294967295
 8000900:	e006      	b.n	8000910 <__cmpdf2+0x4>
 8000902:	bf00      	nop

08000904 <__ledf2>:
 8000904:	f04f 0c01 	mov.w	ip, #1
 8000908:	e002      	b.n	8000910 <__cmpdf2+0x4>
 800090a:	bf00      	nop

0800090c <__cmpdf2>:
 800090c:	f04f 0c01 	mov.w	ip, #1
 8000910:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000914:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000918:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800091c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000920:	bf18      	it	ne
 8000922:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000926:	d01b      	beq.n	8000960 <__cmpdf2+0x54>
 8000928:	b001      	add	sp, #4
 800092a:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800092e:	bf0c      	ite	eq
 8000930:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000934:	ea91 0f03 	teqne	r1, r3
 8000938:	bf02      	ittt	eq
 800093a:	ea90 0f02 	teqeq	r0, r2
 800093e:	2000      	moveq	r0, #0
 8000940:	4770      	bxeq	lr
 8000942:	f110 0f00 	cmn.w	r0, #0
 8000946:	ea91 0f03 	teq	r1, r3
 800094a:	bf58      	it	pl
 800094c:	4299      	cmppl	r1, r3
 800094e:	bf08      	it	eq
 8000950:	4290      	cmpeq	r0, r2
 8000952:	bf2c      	ite	cs
 8000954:	17d8      	asrcs	r0, r3, #31
 8000956:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800095a:	f040 0001 	orr.w	r0, r0, #1
 800095e:	4770      	bx	lr
 8000960:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000964:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000968:	d102      	bne.n	8000970 <__cmpdf2+0x64>
 800096a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800096e:	d107      	bne.n	8000980 <__cmpdf2+0x74>
 8000970:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000974:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000978:	d1d6      	bne.n	8000928 <__cmpdf2+0x1c>
 800097a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800097e:	d0d3      	beq.n	8000928 <__cmpdf2+0x1c>
 8000980:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000984:	4770      	bx	lr
 8000986:	bf00      	nop

08000988 <__aeabi_cdrcmple>:
 8000988:	4684      	mov	ip, r0
 800098a:	4610      	mov	r0, r2
 800098c:	4662      	mov	r2, ip
 800098e:	468c      	mov	ip, r1
 8000990:	4619      	mov	r1, r3
 8000992:	4663      	mov	r3, ip
 8000994:	e000      	b.n	8000998 <__aeabi_cdcmpeq>
 8000996:	bf00      	nop

08000998 <__aeabi_cdcmpeq>:
 8000998:	b501      	push	{r0, lr}
 800099a:	f7ff ffb7 	bl	800090c <__cmpdf2>
 800099e:	2800      	cmp	r0, #0
 80009a0:	bf48      	it	mi
 80009a2:	f110 0f00 	cmnmi.w	r0, #0
 80009a6:	bd01      	pop	{r0, pc}

080009a8 <__aeabi_dcmpeq>:
 80009a8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80009ac:	f7ff fff4 	bl	8000998 <__aeabi_cdcmpeq>
 80009b0:	bf0c      	ite	eq
 80009b2:	2001      	moveq	r0, #1
 80009b4:	2000      	movne	r0, #0
 80009b6:	f85d fb08 	ldr.w	pc, [sp], #8
 80009ba:	bf00      	nop

080009bc <__aeabi_dcmplt>:
 80009bc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80009c0:	f7ff ffea 	bl	8000998 <__aeabi_cdcmpeq>
 80009c4:	bf34      	ite	cc
 80009c6:	2001      	movcc	r0, #1
 80009c8:	2000      	movcs	r0, #0
 80009ca:	f85d fb08 	ldr.w	pc, [sp], #8
 80009ce:	bf00      	nop

080009d0 <__aeabi_dcmple>:
 80009d0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80009d4:	f7ff ffe0 	bl	8000998 <__aeabi_cdcmpeq>
 80009d8:	bf94      	ite	ls
 80009da:	2001      	movls	r0, #1
 80009dc:	2000      	movhi	r0, #0
 80009de:	f85d fb08 	ldr.w	pc, [sp], #8
 80009e2:	bf00      	nop

080009e4 <__aeabi_dcmpge>:
 80009e4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80009e8:	f7ff ffce 	bl	8000988 <__aeabi_cdrcmple>
 80009ec:	bf94      	ite	ls
 80009ee:	2001      	movls	r0, #1
 80009f0:	2000      	movhi	r0, #0
 80009f2:	f85d fb08 	ldr.w	pc, [sp], #8
 80009f6:	bf00      	nop

080009f8 <__aeabi_dcmpgt>:
 80009f8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80009fc:	f7ff ffc4 	bl	8000988 <__aeabi_cdrcmple>
 8000a00:	bf34      	ite	cc
 8000a02:	2001      	movcc	r0, #1
 8000a04:	2000      	movcs	r0, #0
 8000a06:	f85d fb08 	ldr.w	pc, [sp], #8
 8000a0a:	bf00      	nop

08000a0c <__aeabi_d2iz>:
 8000a0c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a10:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a14:	d215      	bcs.n	8000a42 <__aeabi_d2iz+0x36>
 8000a16:	d511      	bpl.n	8000a3c <__aeabi_d2iz+0x30>
 8000a18:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a1c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a20:	d912      	bls.n	8000a48 <__aeabi_d2iz+0x3c>
 8000a22:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a26:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a2a:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a2e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000a32:	fa23 f002 	lsr.w	r0, r3, r2
 8000a36:	bf18      	it	ne
 8000a38:	4240      	negne	r0, r0
 8000a3a:	4770      	bx	lr
 8000a3c:	f04f 0000 	mov.w	r0, #0
 8000a40:	4770      	bx	lr
 8000a42:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a46:	d105      	bne.n	8000a54 <__aeabi_d2iz+0x48>
 8000a48:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000a4c:	bf08      	it	eq
 8000a4e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000a52:	4770      	bx	lr
 8000a54:	f04f 0000 	mov.w	r0, #0
 8000a58:	4770      	bx	lr
 8000a5a:	bf00      	nop

08000a5c <__aeabi_d2f>:
 8000a5c:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a60:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a64:	bf24      	itt	cs
 8000a66:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a6a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a6e:	d90d      	bls.n	8000a8c <__aeabi_d2f+0x30>
 8000a70:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a74:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000a78:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000a7c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000a80:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000a84:	bf08      	it	eq
 8000a86:	f020 0001 	biceq.w	r0, r0, #1
 8000a8a:	4770      	bx	lr
 8000a8c:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000a90:	d121      	bne.n	8000ad6 <__aeabi_d2f+0x7a>
 8000a92:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000a96:	bfbc      	itt	lt
 8000a98:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000a9c:	4770      	bxlt	lr
 8000a9e:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aa2:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000aa6:	f1c2 0218 	rsb	r2, r2, #24
 8000aaa:	f1c2 0c20 	rsb	ip, r2, #32
 8000aae:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ab2:	fa20 f002 	lsr.w	r0, r0, r2
 8000ab6:	bf18      	it	ne
 8000ab8:	f040 0001 	orrne.w	r0, r0, #1
 8000abc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ac0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000ac4:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000ac8:	ea40 000c 	orr.w	r0, r0, ip
 8000acc:	fa23 f302 	lsr.w	r3, r3, r2
 8000ad0:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000ad4:	e7cc      	b.n	8000a70 <__aeabi_d2f+0x14>
 8000ad6:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000ada:	d107      	bne.n	8000aec <__aeabi_d2f+0x90>
 8000adc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000ae0:	bf1e      	ittt	ne
 8000ae2:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000ae6:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000aea:	4770      	bxne	lr
 8000aec:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000af0:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000af4:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000af8:	4770      	bx	lr
 8000afa:	bf00      	nop

08000afc <StringCompare>:
 * @param char* str2 The second string.
 *
 * @return uint8_t
 */
static uint8_t StringCompare (char str1[], char str2[], uint16_t length)
{
 8000afc:	b470      	push	{r4, r5, r6}
 * @param char* str The given string.
 */
inline static void StringToLowerCase (char *str)
{
  int i = 0;
  while (str[i] != '\0')
 8000afe:	7803      	ldrb	r3, [r0, #0]
 8000b00:	b153      	cbz	r3, 8000b18 <StringCompare+0x1c>
 8000b02:	4605      	mov	r5, r0
    {
      if (str[i] >= 'A' && str[i] <= 'Z')
 8000b04:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 8000b08:	2c19      	cmp	r4, #25
	{
	  str[i] = str[i] + 32;
 8000b0a:	bf9c      	itt	ls
 8000b0c:	3320      	addls	r3, #32
 8000b0e:	702b      	strbls	r3, [r5, #0]
  while (str[i] != '\0')
 8000b10:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8000b14:	2b00      	cmp	r3, #0
 8000b16:	d1f5      	bne.n	8000b04 <StringCompare+0x8>
 8000b18:	780b      	ldrb	r3, [r1, #0]
 8000b1a:	b153      	cbz	r3, 8000b32 <StringCompare+0x36>
 8000b1c:	460d      	mov	r5, r1
      if (str[i] >= 'A' && str[i] <= 'Z')
 8000b1e:	f1a3 0441 	sub.w	r4, r3, #65	; 0x41
 8000b22:	2c19      	cmp	r4, #25
	  str[i] = str[i] + 32;
 8000b24:	bf9c      	itt	ls
 8000b26:	3320      	addls	r3, #32
 8000b28:	702b      	strbls	r3, [r5, #0]
  while (str[i] != '\0')
 8000b2a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	d1f5      	bne.n	8000b1e <StringCompare+0x22>
  for (i = 0; i < length; i++)
 8000b32:	2300      	movs	r3, #0
  uint8_t comVAR = 0, i;
 8000b34:	461c      	mov	r4, r3
      if (str1[i] == str2[i])
 8000b36:	5cc6      	ldrb	r6, [r0, r3]
 8000b38:	5ccd      	ldrb	r5, [r1, r3]
  for (i = 0; i < length; i++)
 8000b3a:	3301      	adds	r3, #1
      if (str1[i] == str2[i])
 8000b3c:	42ae      	cmp	r6, r5
	comVAR++;
 8000b3e:	bf08      	it	eq
 8000b40:	3401      	addeq	r4, #1
  for (i = 0; i < length; i++)
 8000b42:	b2db      	uxtb	r3, r3
	comVAR++;
 8000b44:	bf0c      	ite	eq
 8000b46:	b2e4      	uxtbeq	r4, r4
	comVAR = 0;
 8000b48:	2400      	movne	r4, #0
  for (i = 0; i < length; i++)
 8000b4a:	4293      	cmp	r3, r2
 8000b4c:	d3f3      	bcc.n	8000b36 <StringCompare+0x3a>
 8000b4e:	1aa0      	subs	r0, r4, r2
 8000b50:	fab0 f080 	clz	r0, r0
}
 8000b54:	bc70      	pop	{r4, r5, r6}
 8000b56:	0940      	lsrs	r0, r0, #5
 8000b58:	4770      	bx	lr
 8000b5a:	bf00      	nop

08000b5c <UARTWriteString>:
/*
 * Write the given string to the bluetooth UART channel.
 *
 * @param char* str The string to write into the bluetooth UART channel.
 */
void UARTWriteString(char* str){
 8000b5c:	b510      	push	{r4, lr}
 8000b5e:	4604      	mov	r4, r0
  HAL_UART_Transmit (&huart2,(uint8_t*)str, strlen(str), 500);
 8000b60:	f7ff faf6 	bl	8000150 <strlen>
 8000b64:	4621      	mov	r1, r4
}
 8000b66:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_UART_Transmit (&huart2,(uint8_t*)str, strlen(str), 500);
 8000b6a:	b282      	uxth	r2, r0
 8000b6c:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8000b70:	4801      	ldr	r0, [pc, #4]	; (8000b78 <UARTWriteString+0x1c>)
 8000b72:	f002 b91b 	b.w	8002dac <HAL_UART_Transmit>
 8000b76:	bf00      	nop
 8000b78:	20001c68 	.word	0x20001c68

08000b7c <SendInvalidCommandMsg>:
static void SendInvalidCommandMsg(){
 8000b7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  strcat (bluetoothReceiveCommand, " is not a valid command!!!\n");
 8000b7e:	4e0a      	ldr	r6, [pc, #40]	; (8000ba8 <SendInvalidCommandMsg+0x2c>)
 8000b80:	4c0a      	ldr	r4, [pc, #40]	; (8000bac <SendInvalidCommandMsg+0x30>)
 8000b82:	4630      	mov	r0, r6
 8000b84:	f7ff fae4 	bl	8000150 <strlen>
 8000b88:	4607      	mov	r7, r0
 8000b8a:	1985      	adds	r5, r0, r6
 8000b8c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8000b8e:	51b8      	str	r0, [r7, r6]
 8000b90:	6069      	str	r1, [r5, #4]
 8000b92:	60aa      	str	r2, [r5, #8]
 8000b94:	60eb      	str	r3, [r5, #12]
 8000b96:	cc07      	ldmia	r4!, {r0, r1, r2}
 8000b98:	6128      	str	r0, [r5, #16]
 8000b9a:	6169      	str	r1, [r5, #20]
 8000b9c:	61aa      	str	r2, [r5, #24]
  UARTWriteString(bluetoothReceiveCommand);
 8000b9e:	4630      	mov	r0, r6
}
 8000ba0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  UARTWriteString(bluetoothReceiveCommand);
 8000ba4:	f7ff bfda 	b.w	8000b5c <UARTWriteString>
 8000ba8:	20001b1c 	.word	0x20001b1c
 8000bac:	080065b4 	.word	0x080065b4

08000bb0 <WriteLedPin>:
static void WriteLedPin(LED_IDX ledIdx, FlagStatus flagStat){
 8000bb0:	b410      	push	{r4}
  ledBlinkRatePerSecond[ledIdx] = 0;
 8000bb2:	2400      	movs	r4, #0
 8000bb4:	4b0f      	ldr	r3, [pc, #60]	; (8000bf4 <WriteLedPin+0x44>)
 8000bb6:	541c      	strb	r4, [r3, r0]
  if( ledIdx == LED_ONBOARD){
 8000bb8:	b130      	cbz	r0, 8000bc8 <WriteLedPin+0x18>
  else if(ledIdx == LED_GREEN){
 8000bba:	2801      	cmp	r0, #1
 8000bbc:	d014      	beq.n	8000be8 <WriteLedPin+0x38>
  else if(ledIdx == LED_RED){
 8000bbe:	2802      	cmp	r0, #2
 8000bc0:	d00c      	beq.n	8000bdc <WriteLedPin+0x2c>
}
 8000bc2:	bc10      	pop	{r4}
    SendInvalidCommandMsg();
 8000bc4:	f7ff bfda 	b.w	8000b7c <SendInvalidCommandMsg>
    HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, flagStat);
 8000bc8:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8000bcc:	460a      	mov	r2, r1
 8000bce:	f500 3088 	add.w	r0, r0, #69632	; 0x11000
 8000bd2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
}
 8000bd6:	bc10      	pop	{r4}
    HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, flagStat);
 8000bd8:	f001 ba30 	b.w	800203c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(LED_Red_GPIO_Port, LED_Red_Pin, flagStat);
 8000bdc:	460a      	mov	r2, r1
 8000bde:	4806      	ldr	r0, [pc, #24]	; (8000bf8 <WriteLedPin+0x48>)
 8000be0:	2108      	movs	r1, #8
}
 8000be2:	bc10      	pop	{r4}
    HAL_GPIO_WritePin(LED_Red_GPIO_Port, LED_Red_Pin, flagStat);
 8000be4:	f001 ba2a 	b.w	800203c <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(LED_Green_GPIO_Port, LED_Green_Pin, flagStat);
 8000be8:	460a      	mov	r2, r1
 8000bea:	4803      	ldr	r0, [pc, #12]	; (8000bf8 <WriteLedPin+0x48>)
 8000bec:	2110      	movs	r1, #16
}
 8000bee:	bc10      	pop	{r4}
    HAL_GPIO_WritePin(LED_Green_GPIO_Port, LED_Green_Pin, flagStat);
 8000bf0:	f001 ba24 	b.w	800203c <HAL_GPIO_WritePin>
 8000bf4:	20000200 	.word	0x20000200
 8000bf8:	40010c00 	.word	0x40010c00

08000bfc <URATCommandParser>:
{
 8000bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
  char *cmd[5] = { "", "", "", "", "" };
 8000bfe:	4d32      	ldr	r5, [pc, #200]	; (8000cc8 <URATCommandParser+0xcc>)
{
 8000c00:	b087      	sub	sp, #28
  char *cmd[5] = { "", "", "", "", "" };
 8000c02:	ac01      	add	r4, sp, #4
 8000c04:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8000c06:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8000c08:	682b      	ldr	r3, [r5, #0]
  char *cmdLine = strtok (bluetoothReceiveCommand, " ");
 8000c0a:	4930      	ldr	r1, [pc, #192]	; (8000ccc <URATCommandParser+0xd0>)
 8000c0c:	4830      	ldr	r0, [pc, #192]	; (8000cd0 <URATCommandParser+0xd4>)
  char *cmd[5] = { "", "", "", "", "" };
 8000c0e:	6023      	str	r3, [r4, #0]
  char *cmdLine = strtok (bluetoothReceiveCommand, " ");
 8000c10:	f004 f896 	bl	8004d40 <strtok>
  while (cmdLine != NULL)
 8000c14:	b1d8      	cbz	r0, 8000c4e <URATCommandParser+0x52>
 8000c16:	4604      	mov	r4, r0
 8000c18:	2500      	movs	r5, #0
      HAL_UART_Transmit(&huart2, (uint8_t*)cmdLine, strlen(cmdLine), 500);
 8000c1a:	4f2e      	ldr	r7, [pc, #184]	; (8000cd4 <URATCommandParser+0xd8>)
      cmdLine = strtok (NULL, " ");
 8000c1c:	4e2b      	ldr	r6, [pc, #172]	; (8000ccc <URATCommandParser+0xd0>)
      cmdParams[i++] = cmdLine;
 8000c1e:	aa06      	add	r2, sp, #24
 8000c20:	b2eb      	uxtb	r3, r5
 8000c22:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8000c26:	f843 4c14 	str.w	r4, [r3, #-20]
      HAL_UART_Transmit(&huart2, (uint8_t*)cmdLine, strlen(cmdLine), 500);
 8000c2a:	4620      	mov	r0, r4
 8000c2c:	f7ff fa90 	bl	8000150 <strlen>
 8000c30:	4621      	mov	r1, r4
 8000c32:	b282      	uxth	r2, r0
 8000c34:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 8000c38:	4638      	mov	r0, r7
 8000c3a:	f002 f8b7 	bl	8002dac <HAL_UART_Transmit>
      cmdLine = strtok (NULL, " ");
 8000c3e:	4631      	mov	r1, r6
 8000c40:	2000      	movs	r0, #0
 8000c42:	f004 f87d 	bl	8004d40 <strtok>
 8000c46:	3501      	adds	r5, #1
  while (cmdLine != NULL)
 8000c48:	4604      	mov	r4, r0
 8000c4a:	2800      	cmp	r0, #0
 8000c4c:	d1e7      	bne.n	8000c1e <URATCommandParser+0x22>
  if(StringCompare((char*) cmd[0], (char*)"led", strlen("led"))){
 8000c4e:	2203      	movs	r2, #3
 8000c50:	4921      	ldr	r1, [pc, #132]	; (8000cd8 <URATCommandParser+0xdc>)
 8000c52:	9801      	ldr	r0, [sp, #4]
 8000c54:	f7ff ff52 	bl	8000afc <StringCompare>
 8000c58:	b948      	cbnz	r0, 8000c6e <URATCommandParser+0x72>
  memset (bluetoothReceiveCommand, 0, sizeof(bluetoothReceiveCommand));
 8000c5a:	2232      	movs	r2, #50	; 0x32
 8000c5c:	2100      	movs	r1, #0
 8000c5e:	481c      	ldr	r0, [pc, #112]	; (8000cd0 <URATCommandParser+0xd4>)
 8000c60:	f004 f865 	bl	8004d2e <memset>
  bufferIndex = 0;
 8000c64:	2200      	movs	r2, #0
 8000c66:	4b1d      	ldr	r3, [pc, #116]	; (8000cdc <URATCommandParser+0xe0>)
 8000c68:	701a      	strb	r2, [r3, #0]
}
 8000c6a:	b007      	add	sp, #28
 8000c6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t ledIdx = atoi(cmd[2]);
 8000c6e:	9803      	ldr	r0, [sp, #12]
 8000c70:	f004 f800 	bl	8004c74 <atoi>
 8000c74:	b2c4      	uxtb	r4, r0
    if(ledIdx > MAX_NOF_LEDS || ledIdx < 0){
 8000c76:	2c03      	cmp	r4, #3
 8000c78:	d812      	bhi.n	8000ca0 <URATCommandParser+0xa4>
      if(StringCompare((char*) cmd[1], (char*)"on", strlen("on")))
 8000c7a:	9d02      	ldr	r5, [sp, #8]
 8000c7c:	2202      	movs	r2, #2
 8000c7e:	4628      	mov	r0, r5
 8000c80:	4917      	ldr	r1, [pc, #92]	; (8000ce0 <URATCommandParser+0xe4>)
 8000c82:	f7ff ff3b 	bl	8000afc <StringCompare>
 8000c86:	b970      	cbnz	r0, 8000ca6 <URATCommandParser+0xaa>
      else if(StringCompare((char*)cmd[1], (char*)"off", strlen("off")))
 8000c88:	2203      	movs	r2, #3
 8000c8a:	4916      	ldr	r1, [pc, #88]	; (8000ce4 <URATCommandParser+0xe8>)
 8000c8c:	4628      	mov	r0, r5
 8000c8e:	f7ff ff35 	bl	8000afc <StringCompare>
 8000c92:	b998      	cbnz	r0, 8000cbc <URATCommandParser+0xc0>
      else if(StringCompare((char*)cmd[1], (char*)"blink", strlen("blink")))
 8000c94:	4628      	mov	r0, r5
 8000c96:	2205      	movs	r2, #5
 8000c98:	4913      	ldr	r1, [pc, #76]	; (8000ce8 <URATCommandParser+0xec>)
 8000c9a:	f7ff ff2f 	bl	8000afc <StringCompare>
 8000c9e:	b938      	cbnz	r0, 8000cb0 <URATCommandParser+0xb4>
      SendInvalidCommandMsg();
 8000ca0:	f7ff ff6c 	bl	8000b7c <SendInvalidCommandMsg>
 8000ca4:	e7d9      	b.n	8000c5a <URATCommandParser+0x5e>
	WriteLedPin(ledIdx, RESET);
 8000ca6:	4620      	mov	r0, r4
 8000ca8:	2100      	movs	r1, #0
 8000caa:	f7ff ff81 	bl	8000bb0 <WriteLedPin>
 8000cae:	e7d4      	b.n	8000c5a <URATCommandParser+0x5e>
	ledBlinkRatePerSecond[ledIdx] = atoi(cmd[3]);
 8000cb0:	9804      	ldr	r0, [sp, #16]
 8000cb2:	f003 ffdf 	bl	8004c74 <atoi>
 8000cb6:	4b0d      	ldr	r3, [pc, #52]	; (8000cec <URATCommandParser+0xf0>)
 8000cb8:	5518      	strb	r0, [r3, r4]
 8000cba:	e7ce      	b.n	8000c5a <URATCommandParser+0x5e>
	WriteLedPin(ledIdx, SET);
 8000cbc:	4620      	mov	r0, r4
 8000cbe:	2101      	movs	r1, #1
 8000cc0:	f7ff ff76 	bl	8000bb0 <WriteLedPin>
 8000cc4:	e7c9      	b.n	8000c5a <URATCommandParser+0x5e>
 8000cc6:	bf00      	nop
 8000cc8:	08006580 	.word	0x08006580
 8000ccc:	080065d0 	.word	0x080065d0
 8000cd0:	20001b1c 	.word	0x20001b1c
 8000cd4:	20001c68 	.word	0x20001c68
 8000cd8:	080065d4 	.word	0x080065d4
 8000cdc:	200001fc 	.word	0x200001fc
 8000ce0:	080065d8 	.word	0x080065d8
 8000ce4:	080065dc 	.word	0x080065dc
 8000ce8:	080065e0 	.word	0x080065e0
 8000cec:	20000200 	.word	0x20000200

08000cf0 <onboardLedCtrlTask>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_onboardLedCtrlTask */
void onboardLedCtrlTask(void *argument)
{
 8000cf0:	b508      	push	{r3, lr}
 8000cf2:	4c0c      	ldr	r4, [pc, #48]	; (8000d24 <onboardLedCtrlTask+0x34>)
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    if(ledBlinkRatePerSecond[LED_ONBOARD] > 0){
      HAL_GPIO_TogglePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin);
 8000cf4:	4d0c      	ldr	r5, [pc, #48]	; (8000d28 <onboardLedCtrlTask+0x38>)
    if(ledBlinkRatePerSecond[LED_ONBOARD] > 0){
 8000cf6:	7823      	ldrb	r3, [r4, #0]
 8000cf8:	b173      	cbz	r3, 8000d18 <onboardLedCtrlTask+0x28>
      HAL_GPIO_TogglePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin);
 8000cfa:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000cfe:	4628      	mov	r0, r5
 8000d00:	f001 f9a0 	bl	8002044 <HAL_GPIO_TogglePin>
      osDelay(1000 / 2 / ledBlinkRatePerSecond[LED_ONBOARD]);
 8000d04:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000d08:	7823      	ldrb	r3, [r4, #0]
 8000d0a:	fb90 f0f3 	sdiv	r0, r0, r3
 8000d0e:	f002 fab7 	bl	8003280 <osDelay>
    if(ledBlinkRatePerSecond[LED_ONBOARD] > 0){
 8000d12:	7823      	ldrb	r3, [r4, #0]
 8000d14:	2b00      	cmp	r3, #0
 8000d16:	d1f0      	bne.n	8000cfa <onboardLedCtrlTask+0xa>
    }
    else{
      osDelay( 1000 );
 8000d18:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d1c:	f002 fab0 	bl	8003280 <osDelay>
 8000d20:	e7e9      	b.n	8000cf6 <onboardLedCtrlTask+0x6>
 8000d22:	bf00      	nop
 8000d24:	20000200 	.word	0x20000200
 8000d28:	40011000 	.word	0x40011000

08000d2c <redLedCtrlTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_redLedCtrlTask */
void redLedCtrlTask(void *argument)
{
 8000d2c:	b508      	push	{r3, lr}
 8000d2e:	4c0b      	ldr	r4, [pc, #44]	; (8000d5c <redLedCtrlTask+0x30>)
  /* USER CODE BEGIN redLedCtrlTask */
  /* Infinite loop */
  for(;;)
  {
    if(ledBlinkRatePerSecond[LED_RED] > 0){
      HAL_GPIO_TogglePin(LED_Red_GPIO_Port, LED_Red_Pin);
 8000d30:	4d0b      	ldr	r5, [pc, #44]	; (8000d60 <redLedCtrlTask+0x34>)
    if(ledBlinkRatePerSecond[LED_RED] > 0){
 8000d32:	78a3      	ldrb	r3, [r4, #2]
 8000d34:	b16b      	cbz	r3, 8000d52 <redLedCtrlTask+0x26>
      HAL_GPIO_TogglePin(LED_Red_GPIO_Port, LED_Red_Pin);
 8000d36:	2108      	movs	r1, #8
 8000d38:	4628      	mov	r0, r5
 8000d3a:	f001 f983 	bl	8002044 <HAL_GPIO_TogglePin>
      osDelay(1000 / 2 / ledBlinkRatePerSecond[LED_RED]);
 8000d3e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000d42:	78a3      	ldrb	r3, [r4, #2]
 8000d44:	fb90 f0f3 	sdiv	r0, r0, r3
 8000d48:	f002 fa9a 	bl	8003280 <osDelay>
    if(ledBlinkRatePerSecond[LED_RED] > 0){
 8000d4c:	78a3      	ldrb	r3, [r4, #2]
 8000d4e:	2b00      	cmp	r3, #0
 8000d50:	d1f1      	bne.n	8000d36 <redLedCtrlTask+0xa>
    }
    else{
      osDelay( 1000 );
 8000d52:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000d56:	f002 fa93 	bl	8003280 <osDelay>
 8000d5a:	e7ea      	b.n	8000d32 <redLedCtrlTask+0x6>
 8000d5c:	20000200 	.word	0x20000200
 8000d60:	40010c00 	.word	0x40010c00

08000d64 <getTemperatureTask>:
  char temperature[20] = "";
 8000d64:	2300      	movs	r3, #0
{
 8000d66:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
    tempCelcius = ( rawADCData - 328) / 48.0;
 8000d6a:	f04f 0800 	mov.w	r8, #0
{
 8000d6e:	b086      	sub	sp, #24
  char temperature[20] = "";
 8000d70:	e9cd 3301 	strd	r3, r3, [sp, #4]
 8000d74:	e9cd 3303 	strd	r3, r3, [sp, #12]
    tempCelcius = ( rawADCData - 328) / 48.0;
 8000d78:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8000e04 <getTemperatureTask+0xa0>
 8000d7c:	4e1c      	ldr	r6, [pc, #112]	; (8000df0 <getTemperatureTask+0x8c>)
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
 8000d7e:	4d1d      	ldr	r5, [pc, #116]	; (8000df4 <getTemperatureTask+0x90>)
    HAL_ADC_Start(&hadc1);
 8000d80:	4c1d      	ldr	r4, [pc, #116]	; (8000df8 <getTemperatureTask+0x94>)
  char temperature[20] = "";
 8000d82:	9305      	str	r3, [sp, #20]
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0, GPIO_PIN_SET);
 8000d84:	2201      	movs	r2, #1
 8000d86:	4628      	mov	r0, r5
 8000d88:	4611      	mov	r1, r2
 8000d8a:	f001 f957 	bl	800203c <HAL_GPIO_WritePin>
    HAL_ADC_Start(&hadc1);
 8000d8e:	4620      	mov	r0, r4
 8000d90:	f000 fdc6 	bl	8001920 <HAL_ADC_Start>
    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
 8000d94:	f04f 31ff 	mov.w	r1, #4294967295
 8000d98:	4620      	mov	r0, r4
 8000d9a:	f000 fbc9 	bl	8001530 <HAL_ADC_PollForConversion>
    rawADCData = HAL_ADC_GetValue(&hadc1);
 8000d9e:	4620      	mov	r0, r4
 8000da0:	f000 fc6e 	bl	8001680 <HAL_ADC_GetValue>
    tempCelcius = ( rawADCData - 328) / 48.0;
 8000da4:	f5a0 70a4 	sub.w	r0, r0, #328	; 0x148
 8000da8:	f7ff fb1c 	bl	80003e4 <__aeabi_ui2d>
 8000dac:	464b      	mov	r3, r9
 8000dae:	4642      	mov	r2, r8
 8000db0:	f7ff fcbc 	bl	800072c <__aeabi_ddiv>
 8000db4:	f7ff fe52 	bl	8000a5c <__aeabi_d2f>
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
 8000db8:	2200      	movs	r2, #0
    tempCelcius = ( rawADCData - 328) / 48.0;
 8000dba:	6030      	str	r0, [r6, #0]
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
 8000dbc:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000dc0:	4628      	mov	r0, r5
 8000dc2:	f001 f93b 	bl	800203c <HAL_GPIO_WritePin>
    UARTWriteString("T: ");
 8000dc6:	480d      	ldr	r0, [pc, #52]	; (8000dfc <getTemperatureTask+0x98>)
 8000dc8:	f7ff fec8 	bl	8000b5c <UARTWriteString>
    gcvt((double)tempCelcius, 6, (char*)temperature);
 8000dcc:	6830      	ldr	r0, [r6, #0]
 8000dce:	f7ff fb2b 	bl	8000428 <__aeabi_f2d>
 8000dd2:	ab01      	add	r3, sp, #4
 8000dd4:	2206      	movs	r2, #6
 8000dd6:	f003 ff51 	bl	8004c7c <gcvt>
    UARTWriteString((char*)temperature);
 8000dda:	a801      	add	r0, sp, #4
 8000ddc:	f7ff febe 	bl	8000b5c <UARTWriteString>
    UARTWriteString(" C\n");
 8000de0:	4807      	ldr	r0, [pc, #28]	; (8000e00 <getTemperatureTask+0x9c>)
 8000de2:	f7ff febb 	bl	8000b5c <UARTWriteString>
    osDelay(1000);
 8000de6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000dea:	f002 fa49 	bl	8003280 <osDelay>
 8000dee:	e7c9      	b.n	8000d84 <getTemperatureTask+0x20>
 8000df0:	2000020c 	.word	0x2000020c
 8000df4:	40010800 	.word	0x40010800
 8000df8:	20001bf0 	.word	0x20001bf0
 8000dfc:	080065e8 	.word	0x080065e8
 8000e00:	080065ec 	.word	0x080065ec
 8000e04:	40480000 	.word	0x40480000

08000e08 <myButtonCtrlTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_myButtonCtrlTask */
void myButtonCtrlTask(void *argument)
{
 8000e08:	b508      	push	{r3, lr}
  /* USER CODE BEGIN myButtonCtrlTask */
  /* Infinite loop */
  for(;;)
  {
    osDelay(100);
    if(HAL_GPIO_ReadPin(Button_GPIO_Port, Button_Pin) == GPIO_PIN_RESET){
 8000e0a:	4c0d      	ldr	r4, [pc, #52]	; (8000e40 <myButtonCtrlTask+0x38>)
      osDelay(20);
      if(HAL_GPIO_ReadPin(Button_GPIO_Port, Button_Pin) == GPIO_PIN_RESET){
	UARTWriteString("Button was pressed\n");
 8000e0c:	4d0d      	ldr	r5, [pc, #52]	; (8000e44 <myButtonCtrlTask+0x3c>)
    osDelay(100);
 8000e0e:	2064      	movs	r0, #100	; 0x64
 8000e10:	f002 fa36 	bl	8003280 <osDelay>
    if(HAL_GPIO_ReadPin(Button_GPIO_Port, Button_Pin) == GPIO_PIN_RESET){
 8000e14:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000e18:	4809      	ldr	r0, [pc, #36]	; (8000e40 <myButtonCtrlTask+0x38>)
 8000e1a:	f001 f909 	bl	8002030 <HAL_GPIO_ReadPin>
 8000e1e:	2800      	cmp	r0, #0
 8000e20:	d1f5      	bne.n	8000e0e <myButtonCtrlTask+0x6>
      osDelay(20);
 8000e22:	2014      	movs	r0, #20
 8000e24:	f002 fa2c 	bl	8003280 <osDelay>
      if(HAL_GPIO_ReadPin(Button_GPIO_Port, Button_Pin) == GPIO_PIN_RESET){
 8000e28:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000e2c:	4620      	mov	r0, r4
 8000e2e:	f001 f8ff 	bl	8002030 <HAL_GPIO_ReadPin>
 8000e32:	2800      	cmp	r0, #0
 8000e34:	d1eb      	bne.n	8000e0e <myButtonCtrlTask+0x6>
	UARTWriteString("Button was pressed\n");
 8000e36:	4628      	mov	r0, r5
 8000e38:	f7ff fe90 	bl	8000b5c <UARTWriteString>
 8000e3c:	e7e7      	b.n	8000e0e <myButtonCtrlTask+0x6>
 8000e3e:	bf00      	nop
 8000e40:	40010800 	.word	0x40010800
 8000e44:	08006614 	.word	0x08006614

08000e48 <SystemClock_Config>:
{
 8000e48:	b530      	push	{r4, r5, lr}
 8000e4a:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000e4c:	2100      	movs	r1, #0
 8000e4e:	2224      	movs	r2, #36	; 0x24
 8000e50:	a80b      	add	r0, sp, #44	; 0x2c
 8000e52:	f003 ff6c 	bl	8004d2e <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000e56:	2400      	movs	r4, #0
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000e58:	2201      	movs	r2, #1
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000e5a:	2502      	movs	r5, #2
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000e5c:	2310      	movs	r3, #16
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000e5e:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000e60:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000e64:	9405      	str	r4, [sp, #20]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000e66:	9401      	str	r4, [sp, #4]
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000e68:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8000e6c:	e9cd 4408 	strd	r4, r4, [sp, #32]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000e70:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8000e74:	9404      	str	r4, [sp, #16]
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000e76:	950a      	str	r5, [sp, #40]	; 0x28
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000e78:	f001 f9ae 	bl	80021d8 <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000e7c:	230f      	movs	r3, #15
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000e7e:	4621      	mov	r1, r4
 8000e80:	a805      	add	r0, sp, #20
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000e82:	9305      	str	r3, [sp, #20]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000e84:	e9cd 4406 	strd	r4, r4, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000e88:	e9cd 4408 	strd	r4, r4, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000e8c:	f001 fbd2 	bl	8002634 <HAL_RCC_ClockConfig>
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000e90:	a801      	add	r0, sp, #4
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 8000e92:	9501      	str	r5, [sp, #4]
  PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
 8000e94:	9403      	str	r4, [sp, #12]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000e96:	f001 fcad 	bl	80027f4 <HAL_RCCEx_PeriphCLKConfig>
}
 8000e9a:	b015      	add	sp, #84	; 0x54
 8000e9c:	bd30      	pop	{r4, r5, pc}
 8000e9e:	bf00      	nop

08000ea0 <main>:
{
 8000ea0:	b580      	push	{r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000ea2:	2400      	movs	r4, #0
{
 8000ea4:	b08a      	sub	sp, #40	; 0x28
  HAL_Init();
 8000ea6:	f000 fb0d 	bl	80014c4 <HAL_Init>
  SystemClock_Config();
 8000eaa:	f7ff ffcd 	bl	8000e48 <SystemClock_Config>
  HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, GPIO_PIN_SET);
 8000eae:	2201      	movs	r2, #1
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000eb0:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8000eb4:	e9cd 4408 	strd	r4, r4, [sp, #32]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000eb8:	4d68      	ldr	r5, [pc, #416]	; (800105c <main+0x1bc>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000eba:	4617      	mov	r7, r2
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000ebc:	69ab      	ldr	r3, [r5, #24]
  HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, GPIO_PIN_SET);
 8000ebe:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000ec2:	f043 0310 	orr.w	r3, r3, #16
 8000ec6:	61ab      	str	r3, [r5, #24]
 8000ec8:	69ab      	ldr	r3, [r5, #24]
  HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, GPIO_PIN_SET);
 8000eca:	4865      	ldr	r0, [pc, #404]	; (8001060 <main+0x1c0>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8000ecc:	f003 0310 	and.w	r3, r3, #16
 8000ed0:	9302      	str	r3, [sp, #8]
 8000ed2:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000ed4:	69ab      	ldr	r3, [r5, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000ed6:	2602      	movs	r6, #2
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8000ed8:	f043 0320 	orr.w	r3, r3, #32
 8000edc:	61ab      	str	r3, [r5, #24]
 8000ede:	69ab      	ldr	r3, [r5, #24]
 8000ee0:	f003 0320 	and.w	r3, r3, #32
 8000ee4:	9303      	str	r3, [sp, #12]
 8000ee6:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000ee8:	69ab      	ldr	r3, [r5, #24]
 8000eea:	f043 0304 	orr.w	r3, r3, #4
 8000eee:	61ab      	str	r3, [r5, #24]
 8000ef0:	69ab      	ldr	r3, [r5, #24]
 8000ef2:	f003 0304 	and.w	r3, r3, #4
 8000ef6:	9304      	str	r3, [sp, #16]
 8000ef8:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000efa:	69ab      	ldr	r3, [r5, #24]
 8000efc:	f043 0308 	orr.w	r3, r3, #8
 8000f00:	61ab      	str	r3, [r5, #24]
 8000f02:	69ab      	ldr	r3, [r5, #24]
 8000f04:	f003 0308 	and.w	r3, r3, #8
 8000f08:	9305      	str	r3, [sp, #20]
 8000f0a:	9b05      	ldr	r3, [sp, #20]
  HAL_GPIO_WritePin(LED_OnBoard_GPIO_Port, LED_OnBoard_Pin, GPIO_PIN_SET);
 8000f0c:	f001 f896 	bl	800203c <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, LED_Red_Pin|LED_Green_Pin, GPIO_PIN_SET);
 8000f10:	463a      	mov	r2, r7
 8000f12:	2118      	movs	r1, #24
 8000f14:	4853      	ldr	r0, [pc, #332]	; (8001064 <main+0x1c4>)
 8000f16:	f001 f891 	bl	800203c <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = LED_OnBoard_Pin;
 8000f1a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(LED_OnBoard_GPIO_Port, &GPIO_InitStruct);
 8000f1e:	a906      	add	r1, sp, #24
 8000f20:	484f      	ldr	r0, [pc, #316]	; (8001060 <main+0x1c0>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000f22:	e9cd 3706 	strd	r3, r7, [sp, #24]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000f26:	9609      	str	r6, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f28:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(LED_OnBoard_GPIO_Port, &GPIO_InitStruct);
 8000f2a:	f000 ff95 	bl	8001e58 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = Button_Pin;
 8000f2e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000f32:	4b4d      	ldr	r3, [pc, #308]	; (8001068 <main+0x1c8>)
  HAL_GPIO_Init(Button_GPIO_Port, &GPIO_InitStruct);
 8000f34:	a906      	add	r1, sp, #24
 8000f36:	484d      	ldr	r0, [pc, #308]	; (800106c <main+0x1cc>)
  GPIO_InitStruct.Pin = Button_Pin;
 8000f38:	9206      	str	r2, [sp, #24]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8000f3a:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f3c:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(Button_GPIO_Port, &GPIO_InitStruct);
 8000f3e:	f000 ff8b 	bl	8001e58 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = LED_Red_Pin|LED_Green_Pin;
 8000f42:	2318      	movs	r3, #24
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000f44:	4847      	ldr	r0, [pc, #284]	; (8001064 <main+0x1c4>)
 8000f46:	eb0d 0103 	add.w	r1, sp, r3
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000f4a:	9609      	str	r6, [sp, #36]	; 0x24
  GPIO_InitStruct.Pin = LED_Red_Pin|LED_Green_Pin;
 8000f4c:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000f4e:	e9cd 7407 	strd	r7, r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000f52:	f000 ff81 	bl	8001e58 <HAL_GPIO_Init>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000f56:	696b      	ldr	r3, [r5, #20]
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
 8000f58:	4622      	mov	r2, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000f5a:	433b      	orrs	r3, r7
 8000f5c:	616b      	str	r3, [r5, #20]
 8000f5e:	696b      	ldr	r3, [r5, #20]
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
 8000f60:	4621      	mov	r1, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000f62:	403b      	ands	r3, r7
 8000f64:	9301      	str	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
 8000f66:	2010      	movs	r0, #16
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000f68:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Channel6_IRQn, 0, 0);
 8000f6a:	f000 fe1b 	bl	8001ba4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel6_IRQn);
 8000f6e:	2010      	movs	r0, #16
 8000f70:	f000 fe4e 	bl	8001c10 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(DMA1_Channel7_IRQn, 0, 0);
 8000f74:	4622      	mov	r2, r4
 8000f76:	4621      	mov	r1, r4
 8000f78:	2011      	movs	r0, #17
 8000f7a:	f000 fe13 	bl	8001ba4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel7_IRQn);
 8000f7e:	2011      	movs	r0, #17
 8000f80:	f000 fe46 	bl	8001c10 <HAL_NVIC_EnableIRQ>
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000f84:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  hi2c1.Instance = I2C1;
 8000f88:	4b39      	ldr	r3, [pc, #228]	; (8001070 <main+0x1d0>)
  hi2c1.Init.ClockSpeed = 400000;
 8000f8a:	493a      	ldr	r1, [pc, #232]	; (8001074 <main+0x1d4>)
  hi2c1.Instance = I2C1;
 8000f8c:	f5a5 35de 	sub.w	r5, r5, #113664	; 0x1bc00
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8000f90:	4618      	mov	r0, r3
  hi2c1.Init.ClockSpeed = 400000;
 8000f92:	e9c3 5100 	strd	r5, r1, [r3]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000f96:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress1 = 0;
 8000f98:	e9c3 4402 	strd	r4, r4, [r3, #8]
  hi2c1.Init.OwnAddress2 = 0;
 8000f9c:	e9c3 4405 	strd	r4, r4, [r3, #20]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8000fa0:	e9c3 4407 	strd	r4, r4, [r3, #28]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8000fa4:	f001 f858 	bl	8002058 <HAL_I2C_Init>
  huart2.Init.BaudRate = 9600;
 8000fa8:	f44f 5216 	mov.w	r2, #9600	; 0x2580
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000fac:	230c      	movs	r3, #12
  huart2.Instance = USART2;
 8000fae:	4d32      	ldr	r5, [pc, #200]	; (8001078 <main+0x1d8>)
 8000fb0:	4932      	ldr	r1, [pc, #200]	; (800107c <main+0x1dc>)
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000fb2:	4628      	mov	r0, r5
  huart2.Init.BaudRate = 9600;
 8000fb4:	e9c5 1200 	strd	r1, r2, [r5]
  huart2.Init.Mode = UART_MODE_TX_RX;
 8000fb8:	616b      	str	r3, [r5, #20]
  huart2.Init.StopBits = UART_STOPBITS_1;
 8000fba:	e9c5 4402 	strd	r4, r4, [r5, #8]
  huart2.Init.Parity = UART_PARITY_NONE;
 8000fbe:	612c      	str	r4, [r5, #16]
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
 8000fc0:	e9c5 4406 	strd	r4, r4, [r5, #24]
  if (HAL_UART_Init(&huart2) != HAL_OK)
 8000fc4:	f001 fec2 	bl	8002d4c <HAL_UART_Init>
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000fc8:	f44f 2360 	mov.w	r3, #917504	; 0xe0000
  hadc1.Instance = ADC1;
 8000fcc:	4e2c      	ldr	r6, [pc, #176]	; (8001080 <main+0x1e0>)
 8000fce:	4a2d      	ldr	r2, [pc, #180]	; (8001084 <main+0x1e4>)
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000fd0:	4630      	mov	r0, r6
  hadc1.Instance = ADC1;
 8000fd2:	6032      	str	r2, [r6, #0]
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000fd4:	61f3      	str	r3, [r6, #28]
  ADC_ChannelConfTypeDef sConfig = {0};
 8000fd6:	e9cd 4406 	strd	r4, r4, [sp, #24]
 8000fda:	9408      	str	r4, [sp, #32]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8000fdc:	60b4      	str	r4, [r6, #8]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000fde:	7334      	strb	r4, [r6, #12]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000fe0:	7534      	strb	r4, [r6, #20]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000fe2:	6074      	str	r4, [r6, #4]
  hadc1.Init.NbrOfConversion = 1;
 8000fe4:	6137      	str	r7, [r6, #16]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000fe6:	f000 fd23 	bl	8001a30 <HAL_ADC_Init>
  sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
 8000fea:	2307      	movs	r3, #7
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8000fec:	2210      	movs	r2, #16
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000fee:	a906      	add	r1, sp, #24
 8000ff0:	4630      	mov	r0, r6
  sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
 8000ff2:	9308      	str	r3, [sp, #32]
  sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
 8000ff4:	e9cd 2706 	strd	r2, r7, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000ff8:	f000 fbc4 	bl	8001784 <HAL_ADC_ConfigChannel>
  HAL_Delay(1000);
 8000ffc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001000:	f000 fa84 	bl	800150c <HAL_Delay>
  memset(bluetoothReceiveCommand, 0, sizeof(bluetoothReceiveCommand));
 8001004:	4621      	mov	r1, r4
 8001006:	2232      	movs	r2, #50	; 0x32
 8001008:	481f      	ldr	r0, [pc, #124]	; (8001088 <main+0x1e8>)
 800100a:	f003 fe90 	bl	8004d2e <memset>
  __HAL_UART_ENABLE_IT(&huart2, UART_IT_RXNE);
 800100e:	682a      	ldr	r2, [r5, #0]
 8001010:	68d3      	ldr	r3, [r2, #12]
 8001012:	f043 0320 	orr.w	r3, r3, #32
 8001016:	60d3      	str	r3, [r2, #12]
  osKernelInitialize();
 8001018:	f002 f89c 	bl	8003154 <osKernelInitialize>
  onboardLedCtrlHandle = osThreadNew(onboardLedCtrlTask, NULL, &onboardLedCtrl_attributes);
 800101c:	4621      	mov	r1, r4
 800101e:	4a1b      	ldr	r2, [pc, #108]	; (800108c <main+0x1ec>)
 8001020:	481b      	ldr	r0, [pc, #108]	; (8001090 <main+0x1f0>)
 8001022:	f002 f8d3 	bl	80031cc <osThreadNew>
 8001026:	4b1b      	ldr	r3, [pc, #108]	; (8001094 <main+0x1f4>)
  getTemperatureHandle = osThreadNew(getTemperatureTask, NULL, &getTemperature_attributes);
 8001028:	4621      	mov	r1, r4
  onboardLedCtrlHandle = osThreadNew(onboardLedCtrlTask, NULL, &onboardLedCtrl_attributes);
 800102a:	6018      	str	r0, [r3, #0]
  getTemperatureHandle = osThreadNew(getTemperatureTask, NULL, &getTemperature_attributes);
 800102c:	4a1a      	ldr	r2, [pc, #104]	; (8001098 <main+0x1f8>)
 800102e:	481b      	ldr	r0, [pc, #108]	; (800109c <main+0x1fc>)
 8001030:	f002 f8cc 	bl	80031cc <osThreadNew>
 8001034:	4b1a      	ldr	r3, [pc, #104]	; (80010a0 <main+0x200>)
  redLedCtrlHandle = osThreadNew(redLedCtrlTask, NULL, &redLedCtrl_attributes);
 8001036:	4621      	mov	r1, r4
  getTemperatureHandle = osThreadNew(getTemperatureTask, NULL, &getTemperature_attributes);
 8001038:	6018      	str	r0, [r3, #0]
  redLedCtrlHandle = osThreadNew(redLedCtrlTask, NULL, &redLedCtrl_attributes);
 800103a:	4a1a      	ldr	r2, [pc, #104]	; (80010a4 <main+0x204>)
 800103c:	481a      	ldr	r0, [pc, #104]	; (80010a8 <main+0x208>)
 800103e:	f002 f8c5 	bl	80031cc <osThreadNew>
 8001042:	4b1a      	ldr	r3, [pc, #104]	; (80010ac <main+0x20c>)
  myButtonCtrlHandle = osThreadNew(myButtonCtrlTask, NULL, &myButtonCtrl_attributes);
 8001044:	4621      	mov	r1, r4
  redLedCtrlHandle = osThreadNew(redLedCtrlTask, NULL, &redLedCtrl_attributes);
 8001046:	6018      	str	r0, [r3, #0]
  myButtonCtrlHandle = osThreadNew(myButtonCtrlTask, NULL, &myButtonCtrl_attributes);
 8001048:	4a19      	ldr	r2, [pc, #100]	; (80010b0 <main+0x210>)
 800104a:	481a      	ldr	r0, [pc, #104]	; (80010b4 <main+0x214>)
 800104c:	f002 f8be 	bl	80031cc <osThreadNew>
 8001050:	4b19      	ldr	r3, [pc, #100]	; (80010b8 <main+0x218>)
 8001052:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8001054:	f002 f898 	bl	8003188 <osKernelStart>
 8001058:	e7fe      	b.n	8001058 <main+0x1b8>
 800105a:	bf00      	nop
 800105c:	40021000 	.word	0x40021000
 8001060:	40011000 	.word	0x40011000
 8001064:	40010c00 	.word	0x40010c00
 8001068:	10110000 	.word	0x10110000
 800106c:	40010800 	.word	0x40010800
 8001070:	20001b98 	.word	0x20001b98
 8001074:	00061a80 	.word	0x00061a80
 8001078:	20001c68 	.word	0x20001c68
 800107c:	40004400 	.word	0x40004400
 8001080:	20001bf0 	.word	0x20001bf0
 8001084:	40012400 	.word	0x40012400
 8001088:	20001b1c 	.word	0x20001b1c
 800108c:	0800664c 	.word	0x0800664c
 8001090:	08000cf1 	.word	0x08000cf1
 8001094:	20001ca8 	.word	0x20001ca8
 8001098:	080065f0 	.word	0x080065f0
 800109c:	08000d65 	.word	0x08000d65
 80010a0:	20001c20 	.word	0x20001c20
 80010a4:	08006670 	.word	0x08006670
 80010a8:	08000d2d 	.word	0x08000d2d
 80010ac:	20001bec 	.word	0x20001bec
 80010b0:	08006628 	.word	0x08006628
 80010b4:	08000e09 	.word	0x08000e09
 80010b8:	20001b50 	.word	0x20001b50

080010bc <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM3) {
 80010bc:	6802      	ldr	r2, [r0, #0]
 80010be:	4b03      	ldr	r3, [pc, #12]	; (80010cc <HAL_TIM_PeriodElapsedCallback+0x10>)
 80010c0:	429a      	cmp	r2, r3
 80010c2:	d000      	beq.n	80010c6 <HAL_TIM_PeriodElapsedCallback+0xa>
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 80010c4:	4770      	bx	lr
    HAL_IncTick();
 80010c6:	f000 ba0f 	b.w	80014e8 <HAL_IncTick>
 80010ca:	bf00      	nop
 80010cc:	40000400 	.word	0x40000400

080010d0 <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 80010d0:	4770      	bx	lr
 80010d2:	bf00      	nop

080010d4 <HAL_MspInit>:

  /* System interrupt init*/

  /* Peripheral interrupt init */
  /* RCC_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 80010d4:	2200      	movs	r2, #0
  __HAL_RCC_AFIO_CLK_ENABLE();
 80010d6:	4b12      	ldr	r3, [pc, #72]	; (8001120 <HAL_MspInit+0x4c>)
{
 80010d8:	b510      	push	{r4, lr}
  __HAL_RCC_AFIO_CLK_ENABLE();
 80010da:	699c      	ldr	r4, [r3, #24]
{
 80010dc:	b082      	sub	sp, #8
  __HAL_RCC_AFIO_CLK_ENABLE();
 80010de:	f044 0401 	orr.w	r4, r4, #1
 80010e2:	619c      	str	r4, [r3, #24]
 80010e4:	699c      	ldr	r4, [r3, #24]
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 80010e6:	4611      	mov	r1, r2
  __HAL_RCC_AFIO_CLK_ENABLE();
 80010e8:	f004 0401 	and.w	r4, r4, #1
 80010ec:	9400      	str	r4, [sp, #0]
 80010ee:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80010f0:	69dc      	ldr	r4, [r3, #28]
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 80010f2:	2005      	movs	r0, #5
  __HAL_RCC_PWR_CLK_ENABLE();
 80010f4:	f044 5480 	orr.w	r4, r4, #268435456	; 0x10000000
 80010f8:	61dc      	str	r4, [r3, #28]
 80010fa:	69db      	ldr	r3, [r3, #28]
 80010fc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001100:	9301      	str	r3, [sp, #4]
 8001102:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(RCC_IRQn, 0, 0);
 8001104:	f000 fd4e 	bl	8001ba4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(RCC_IRQn);
 8001108:	2005      	movs	r0, #5
 800110a:	f000 fd81 	bl	8001c10 <HAL_NVIC_EnableIRQ>

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 800110e:	4a05      	ldr	r2, [pc, #20]	; (8001124 <HAL_MspInit+0x50>)
 8001110:	6853      	ldr	r3, [r2, #4]
 8001112:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8001116:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800111a:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800111c:	b002      	add	sp, #8
 800111e:	bd10      	pop	{r4, pc}
 8001120:	40021000 	.word	0x40021000
 8001124:	40010000 	.word	0x40010000

08001128 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8001128:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800112a:	2400      	movs	r4, #0
  if(hadc->Instance==ADC1)
 800112c:	6802      	ldr	r2, [r0, #0]
 800112e:	4b18      	ldr	r3, [pc, #96]	; (8001190 <HAL_ADC_MspInit+0x68>)
{
 8001130:	b087      	sub	sp, #28
  if(hadc->Instance==ADC1)
 8001132:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001134:	e9cd 4402 	strd	r4, r4, [sp, #8]
 8001138:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(hadc->Instance==ADC1)
 800113c:	d001      	beq.n	8001142 <HAL_ADC_MspInit+0x1a>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 800113e:	b007      	add	sp, #28
 8001140:	bd30      	pop	{r4, r5, pc}
    GPIO_InitStruct.Pin = LM35_Pin;
 8001142:	2020      	movs	r0, #32
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001144:	2503      	movs	r5, #3
    __HAL_RCC_ADC1_CLK_ENABLE();
 8001146:	f503 436c 	add.w	r3, r3, #60416	; 0xec00
 800114a:	699a      	ldr	r2, [r3, #24]
    HAL_GPIO_Init(LM35_GPIO_Port, &GPIO_InitStruct);
 800114c:	a902      	add	r1, sp, #8
    __HAL_RCC_ADC1_CLK_ENABLE();
 800114e:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001152:	619a      	str	r2, [r3, #24]
 8001154:	699a      	ldr	r2, [r3, #24]
 8001156:	f402 7200 	and.w	r2, r2, #512	; 0x200
 800115a:	9200      	str	r2, [sp, #0]
 800115c:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800115e:	699a      	ldr	r2, [r3, #24]
 8001160:	f042 0204 	orr.w	r2, r2, #4
 8001164:	619a      	str	r2, [r3, #24]
 8001166:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pin = LM35_Pin;
 8001168:	9002      	str	r0, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800116a:	f003 0304 	and.w	r3, r3, #4
 800116e:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(LM35_GPIO_Port, &GPIO_InitStruct);
 8001170:	4808      	ldr	r0, [pc, #32]	; (8001194 <HAL_ADC_MspInit+0x6c>)
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001172:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001174:	9503      	str	r5, [sp, #12]
    HAL_GPIO_Init(LM35_GPIO_Port, &GPIO_InitStruct);
 8001176:	f000 fe6f 	bl	8001e58 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(ADC1_2_IRQn, 0, 0);
 800117a:	4622      	mov	r2, r4
 800117c:	4621      	mov	r1, r4
 800117e:	2012      	movs	r0, #18
 8001180:	f000 fd10 	bl	8001ba4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC1_2_IRQn);
 8001184:	2012      	movs	r0, #18
 8001186:	f000 fd43 	bl	8001c10 <HAL_NVIC_EnableIRQ>
}
 800118a:	b007      	add	sp, #28
 800118c:	bd30      	pop	{r4, r5, pc}
 800118e:	bf00      	nop
 8001190:	40012400 	.word	0x40012400
 8001194:	40010800 	.word	0x40010800

08001198 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8001198:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800119a:	2400      	movs	r4, #0
  if(hi2c->Instance==I2C1)
 800119c:	6802      	ldr	r2, [r0, #0]
 800119e:	4b2c      	ldr	r3, [pc, #176]	; (8001250 <HAL_I2C_MspInit+0xb8>)
{
 80011a0:	b087      	sub	sp, #28
  if(hi2c->Instance==I2C1)
 80011a2:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80011a4:	e9cd 4402 	strd	r4, r4, [sp, #8]
 80011a8:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(hi2c->Instance==I2C1)
 80011ac:	d001      	beq.n	80011b2 <HAL_I2C_MspInit+0x1a>
  /* USER CODE BEGIN I2C1_MspInit 1 */

  /* USER CODE END I2C1_MspInit 1 */
  }

}
 80011ae:	b007      	add	sp, #28
 80011b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80011b2:	2512      	movs	r5, #18
 80011b4:	4606      	mov	r6, r0
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80011b6:	2001      	movs	r0, #1
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80011b8:	2203      	movs	r2, #3
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80011ba:	f04f 0cc0 	mov.w	ip, #192	; 0xc0
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80011be:	4f25      	ldr	r7, [pc, #148]	; (8001254 <HAL_I2C_MspInit+0xbc>)
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011c0:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80011c2:	69bb      	ldr	r3, [r7, #24]
 80011c4:	f043 0308 	orr.w	r3, r3, #8
 80011c8:	61bb      	str	r3, [r7, #24]
 80011ca:	69bb      	ldr	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80011cc:	e9cd 5003 	strd	r5, r0, [sp, #12]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80011d0:	f003 0308 	and.w	r3, r3, #8
 80011d4:	9300      	str	r3, [sp, #0]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011d6:	4820      	ldr	r0, [pc, #128]	; (8001258 <HAL_I2C_MspInit+0xc0>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80011d8:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80011da:	9205      	str	r2, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
 80011dc:	f8cd c008 	str.w	ip, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011e0:	f000 fe3a 	bl	8001e58 <HAL_GPIO_Init>
    hdma_i2c1_rx.Init.MemInc = DMA_MINC_ENABLE;
 80011e4:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011e6:	69fb      	ldr	r3, [r7, #28]
    hdma_i2c1_rx.Instance = DMA1_Channel7;
 80011e8:	4d1c      	ldr	r5, [pc, #112]	; (800125c <HAL_I2C_MspInit+0xc4>)
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011ea:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80011ee:	61fb      	str	r3, [r7, #28]
 80011f0:	69fb      	ldr	r3, [r7, #28]
    hdma_i2c1_rx.Instance = DMA1_Channel7;
 80011f2:	4a1b      	ldr	r2, [pc, #108]	; (8001260 <HAL_I2C_MspInit+0xc8>)
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011f4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80011f8:	9301      	str	r3, [sp, #4]
    if (HAL_DMA_Init(&hdma_i2c1_rx) != HAL_OK)
 80011fa:	4628      	mov	r0, r5
    __HAL_RCC_I2C1_CLK_ENABLE();
 80011fc:	9b01      	ldr	r3, [sp, #4]
    hdma_i2c1_rx.Init.MemInc = DMA_MINC_ENABLE;
 80011fe:	60e9      	str	r1, [r5, #12]
    hdma_i2c1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001200:	e9c5 4401 	strd	r4, r4, [r5, #4]
    hdma_i2c1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001204:	e9c5 4404 	strd	r4, r4, [r5, #16]
    hdma_i2c1_rx.Init.Priority = DMA_PRIORITY_LOW;
 8001208:	e9c5 4406 	strd	r4, r4, [r5, #24]
    hdma_i2c1_rx.Instance = DMA1_Channel7;
 800120c:	602a      	str	r2, [r5, #0]
    if (HAL_DMA_Init(&hdma_i2c1_rx) != HAL_OK)
 800120e:	f000 fd0d 	bl	8001c2c <HAL_DMA_Init>
 8001212:	b9b0      	cbnz	r0, 8001242 <HAL_I2C_MspInit+0xaa>
    hdma_i2c1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001214:	2010      	movs	r0, #16
    hdma_i2c1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001216:	2300      	movs	r3, #0
    hdma_i2c1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001218:	2280      	movs	r2, #128	; 0x80
    hdma_i2c1_tx.Instance = DMA1_Channel6;
 800121a:	4c12      	ldr	r4, [pc, #72]	; (8001264 <HAL_I2C_MspInit+0xcc>)
 800121c:	4912      	ldr	r1, [pc, #72]	; (8001268 <HAL_I2C_MspInit+0xd0>)
    hdma_i2c1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 800121e:	6060      	str	r0, [r4, #4]
    __HAL_LINKDMA(hi2c,hdmarx,hdma_i2c1_rx);
 8001220:	63b5      	str	r5, [r6, #56]	; 0x38
    if (HAL_DMA_Init(&hdma_i2c1_tx) != HAL_OK)
 8001222:	4620      	mov	r0, r4
    __HAL_LINKDMA(hi2c,hdmarx,hdma_i2c1_rx);
 8001224:	626e      	str	r6, [r5, #36]	; 0x24
    hdma_i2c1_tx.Instance = DMA1_Channel6;
 8001226:	6021      	str	r1, [r4, #0]
    hdma_i2c1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001228:	e9c4 3202 	strd	r3, r2, [r4, #8]
    hdma_i2c1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 800122c:	e9c4 3304 	strd	r3, r3, [r4, #16]
    hdma_i2c1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8001230:	e9c4 3306 	strd	r3, r3, [r4, #24]
    if (HAL_DMA_Init(&hdma_i2c1_tx) != HAL_OK)
 8001234:	f000 fcfa 	bl	8001c2c <HAL_DMA_Init>
 8001238:	b930      	cbnz	r0, 8001248 <HAL_I2C_MspInit+0xb0>
    __HAL_LINKDMA(hi2c,hdmatx,hdma_i2c1_tx);
 800123a:	6374      	str	r4, [r6, #52]	; 0x34
 800123c:	6266      	str	r6, [r4, #36]	; 0x24
}
 800123e:	b007      	add	sp, #28
 8001240:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
 8001242:	f7ff ff45 	bl	80010d0 <Error_Handler>
 8001246:	e7e5      	b.n	8001214 <HAL_I2C_MspInit+0x7c>
      Error_Handler();
 8001248:	f7ff ff42 	bl	80010d0 <Error_Handler>
 800124c:	e7f5      	b.n	800123a <HAL_I2C_MspInit+0xa2>
 800124e:	bf00      	nop
 8001250:	40005400 	.word	0x40005400
 8001254:	40021000 	.word	0x40021000
 8001258:	40010c00 	.word	0x40010c00
 800125c:	20001c24 	.word	0x20001c24
 8001260:	40020080 	.word	0x40020080
 8001264:	20001b54 	.word	0x20001b54
 8001268:	4002006c 	.word	0x4002006c

0800126c <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 800126c:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800126e:	2400      	movs	r4, #0
  if(huart->Instance==USART2)
 8001270:	6802      	ldr	r2, [r0, #0]
 8001272:	4b1c      	ldr	r3, [pc, #112]	; (80012e4 <HAL_UART_MspInit+0x78>)
{
 8001274:	b086      	sub	sp, #24
  if(huart->Instance==USART2)
 8001276:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001278:	e9cd 4402 	strd	r4, r4, [sp, #8]
 800127c:	e9cd 4404 	strd	r4, r4, [sp, #16]
  if(huart->Instance==USART2)
 8001280:	d001      	beq.n	8001286 <HAL_UART_MspInit+0x1a>
  /* USER CODE BEGIN USART2_MspInit 1 */

  /* USER CODE END USART2_MspInit 1 */
  }

}
 8001282:	b006      	add	sp, #24
 8001284:	bd70      	pop	{r4, r5, r6, pc}
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8001286:	2104      	movs	r1, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001288:	2602      	movs	r6, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 800128a:	2503      	movs	r5, #3
    __HAL_RCC_USART2_CLK_ENABLE();
 800128c:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 8001290:	69da      	ldr	r2, [r3, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001292:	4815      	ldr	r0, [pc, #84]	; (80012e8 <HAL_UART_MspInit+0x7c>)
    __HAL_RCC_USART2_CLK_ENABLE();
 8001294:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8001298:	61da      	str	r2, [r3, #28]
 800129a:	69da      	ldr	r2, [r3, #28]
 800129c:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80012a0:	9200      	str	r2, [sp, #0]
 80012a2:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012a4:	699a      	ldr	r2, [r3, #24]
 80012a6:	430a      	orrs	r2, r1
 80012a8:	619a      	str	r2, [r3, #24]
 80012aa:	699b      	ldr	r3, [r3, #24]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80012ac:	9102      	str	r1, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012ae:	400b      	ands	r3, r1
 80012b0:	9301      	str	r3, [sp, #4]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012b2:	a902      	add	r1, sp, #8
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80012b4:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80012b6:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 80012b8:	9505      	str	r5, [sp, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012ba:	f000 fdcd 	bl	8001e58 <HAL_GPIO_Init>
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 80012be:	2308      	movs	r3, #8
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012c0:	4809      	ldr	r0, [pc, #36]	; (80012e8 <HAL_UART_MspInit+0x7c>)
 80012c2:	eb0d 0103 	add.w	r1, sp, r3
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 80012c6:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80012c8:	e9cd 4403 	strd	r4, r4, [sp, #12]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80012cc:	f000 fdc4 	bl	8001e58 <HAL_GPIO_Init>
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
 80012d0:	4622      	mov	r2, r4
 80012d2:	4621      	mov	r1, r4
 80012d4:	2026      	movs	r0, #38	; 0x26
 80012d6:	f000 fc65 	bl	8001ba4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USART2_IRQn);
 80012da:	2026      	movs	r0, #38	; 0x26
 80012dc:	f000 fc98 	bl	8001c10 <HAL_NVIC_EnableIRQ>
}
 80012e0:	b006      	add	sp, #24
 80012e2:	bd70      	pop	{r4, r5, r6, pc}
 80012e4:	40004400 	.word	0x40004400
 80012e8:	40010800 	.word	0x40010800

080012ec <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80012ec:	b510      	push	{r4, lr}
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  /*Configure the TIM3 IRQ priority */
  HAL_NVIC_SetPriority(TIM3_IRQn, TickPriority ,0);
 80012ee:	4601      	mov	r1, r0
{
 80012f0:	b088      	sub	sp, #32
  HAL_NVIC_SetPriority(TIM3_IRQn, TickPriority ,0);
 80012f2:	2200      	movs	r2, #0
 80012f4:	201d      	movs	r0, #29
 80012f6:	f000 fc55 	bl	8001ba4 <HAL_NVIC_SetPriority>

  /* Enable the TIM3 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM3_IRQn);
 80012fa:	201d      	movs	r0, #29
 80012fc:	f000 fc88 	bl	8001c10 <HAL_NVIC_EnableIRQ>
  /* Enable TIM3 clock */
  __HAL_RCC_TIM3_CLK_ENABLE();
 8001300:	4b15      	ldr	r3, [pc, #84]	; (8001358 <HAL_InitTick+0x6c>)

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001302:	a901      	add	r1, sp, #4
  __HAL_RCC_TIM3_CLK_ENABLE();
 8001304:	69da      	ldr	r2, [r3, #28]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001306:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM3_CLK_ENABLE();
 8001308:	f042 0202 	orr.w	r2, r2, #2
 800130c:	61da      	str	r2, [r3, #28]
 800130e:	69db      	ldr	r3, [r3, #28]

  /* Compute the prescaler value to have TIM3 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);

  /* Initialize TIM3 */
  htim3.Instance = TIM3;
 8001310:	4c12      	ldr	r4, [pc, #72]	; (800135c <HAL_InitTick+0x70>)
  __HAL_RCC_TIM3_CLK_ENABLE();
 8001312:	f003 0302 	and.w	r3, r3, #2
 8001316:	9302      	str	r3, [sp, #8]
 8001318:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800131a:	f001 fa4b 	bl	80027b4 <HAL_RCC_GetClockConfig>
  uwTimclock = HAL_RCC_GetPCLK1Freq();
 800131e:	f001 fa29 	bl	8002774 <HAL_RCC_GetPCLK1Freq>
  + Period = [(TIM3CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim3.Init.Period = (1000000 / 1000) - 1;
 8001322:	f240 31e7 	movw	r1, #999	; 0x3e7
  htim3.Init.Prescaler = uwPrescalerValue;
  htim3.Init.ClockDivision = 0;
 8001326:	2200      	movs	r2, #0
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8001328:	4b0d      	ldr	r3, [pc, #52]	; (8001360 <HAL_InitTick+0x74>)
  htim3.Init.Period = (1000000 / 1000) - 1;
 800132a:	60e1      	str	r1, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800132c:	fba3 1300 	umull	r1, r3, r3, r0
  htim3.Instance = TIM3;
 8001330:	490c      	ldr	r1, [pc, #48]	; (8001364 <HAL_InitTick+0x78>)
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 8001332:	0c9b      	lsrs	r3, r3, #18
 8001334:	3b01      	subs	r3, #1
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim3) == HAL_OK)
 8001336:	4620      	mov	r0, r4
  htim3.Instance = TIM3;
 8001338:	e9c4 1300 	strd	r1, r3, [r4]
  htim3.Init.ClockDivision = 0;
 800133c:	6122      	str	r2, [r4, #16]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 800133e:	60a2      	str	r2, [r4, #8]
  if(HAL_TIM_Base_Init(&htim3) == HAL_OK)
 8001340:	f001 fc66 	bl	8002c10 <HAL_TIM_Base_Init>
 8001344:	b110      	cbz	r0, 800134c <HAL_InitTick+0x60>
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim3);
  }

  /* Return function status */
  return HAL_ERROR;
 8001346:	2001      	movs	r0, #1
}
 8001348:	b008      	add	sp, #32
 800134a:	bd10      	pop	{r4, pc}
    return HAL_TIM_Base_Start_IT(&htim3);
 800134c:	4620      	mov	r0, r4
 800134e:	f001 fb4d 	bl	80029ec <HAL_TIM_Base_Start_IT>
}
 8001352:	b008      	add	sp, #32
 8001354:	bd10      	pop	{r4, pc}
 8001356:	bf00      	nop
 8001358:	40021000 	.word	0x40021000
 800135c:	20001cac 	.word	0x20001cac
 8001360:	431bde83 	.word	0x431bde83
 8001364:	40000400 	.word	0x40000400

08001368 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8001368:	4770      	bx	lr
 800136a:	bf00      	nop

0800136c <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800136c:	e7fe      	b.n	800136c <HardFault_Handler>
 800136e:	bf00      	nop

08001370 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8001370:	e7fe      	b.n	8001370 <MemManage_Handler>
 8001372:	bf00      	nop

08001374 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001374:	e7fe      	b.n	8001374 <BusFault_Handler>
 8001376:	bf00      	nop

08001378 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001378:	e7fe      	b.n	8001378 <UsageFault_Handler>
 800137a:	bf00      	nop

0800137c <DebugMon_Handler>:
 800137c:	4770      	bx	lr
 800137e:	bf00      	nop

08001380 <RCC_IRQHandler>:
 8001380:	4770      	bx	lr
 8001382:	bf00      	nop

08001384 <DMA1_Channel6_IRQHandler>:
void DMA1_Channel6_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel6_IRQn 0 */

  /* USER CODE END DMA1_Channel6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c1_tx);
 8001384:	4801      	ldr	r0, [pc, #4]	; (800138c <DMA1_Channel6_IRQHandler+0x8>)
 8001386:	f000 bcd1 	b.w	8001d2c <HAL_DMA_IRQHandler>
 800138a:	bf00      	nop
 800138c:	20001b54 	.word	0x20001b54

08001390 <DMA1_Channel7_IRQHandler>:
void DMA1_Channel7_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel7_IRQn 0 */

  /* USER CODE END DMA1_Channel7_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c1_rx);
 8001390:	4801      	ldr	r0, [pc, #4]	; (8001398 <DMA1_Channel7_IRQHandler+0x8>)
 8001392:	f000 bccb 	b.w	8001d2c <HAL_DMA_IRQHandler>
 8001396:	bf00      	nop
 8001398:	20001c24 	.word	0x20001c24

0800139c <ADC1_2_IRQHandler>:
void ADC1_2_IRQHandler(void)
{
  /* USER CODE BEGIN ADC1_2_IRQn 0 */

  /* USER CODE END ADC1_2_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 800139c:	4801      	ldr	r0, [pc, #4]	; (80013a4 <ADC1_2_IRQHandler+0x8>)
 800139e:	f000 b975 	b.w	800168c <HAL_ADC_IRQHandler>
 80013a2:	bf00      	nop
 80013a4:	20001bf0 	.word	0x20001bf0

080013a8 <TIM3_IRQHandler>:
void TIM3_IRQHandler(void)
{
  /* USER CODE BEGIN TIM3_IRQn 0 */

  /* USER CODE END TIM3_IRQn 0 */
  HAL_TIM_IRQHandler(&htim3);
 80013a8:	4801      	ldr	r0, [pc, #4]	; (80013b0 <TIM3_IRQHandler+0x8>)
 80013aa:	f001 bb4f 	b.w	8002a4c <HAL_TIM_IRQHandler>
 80013ae:	bf00      	nop
 80013b0:	20001cac 	.word	0x20001cac

080013b4 <USART2_IRQHandler>:

/**
  * @brief This function handles USART2 global interrupt.
  */
void USART2_IRQHandler(void)
{
 80013b4:	b570      	push	{r4, r5, r6, lr}
  /* USER CODE BEGIN USART2_IRQn 0 */
  HAL_UART_Receive(&huart2, (uint8_t*)&bluetoothReceiveCommand[bufferIndex++], 1, 10);
 80013b6:	4d0e      	ldr	r5, [pc, #56]	; (80013f0 <USART2_IRQHandler+0x3c>)
 80013b8:	4c0e      	ldr	r4, [pc, #56]	; (80013f4 <USART2_IRQHandler+0x40>)
 80013ba:	7829      	ldrb	r1, [r5, #0]
 80013bc:	230a      	movs	r3, #10
 80013be:	1c4e      	adds	r6, r1, #1
 80013c0:	2201      	movs	r2, #1
 80013c2:	4421      	add	r1, r4
 80013c4:	480c      	ldr	r0, [pc, #48]	; (80013f8 <USART2_IRQHandler+0x44>)
 80013c6:	702e      	strb	r6, [r5, #0]
 80013c8:	f001 fd54 	bl	8002e74 <HAL_UART_Receive>

  if(bluetoothReceiveCommand[bufferIndex-1] == '\n')
 80013cc:	782b      	ldrb	r3, [r5, #0]
 80013ce:	441c      	add	r4, r3
 80013d0:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 80013d4:	2b0a      	cmp	r3, #10
 80013d6:	d004      	beq.n	80013e2 <USART2_IRQHandler+0x2e>
  /* USER CODE END USART2_IRQn 0 */
  HAL_UART_IRQHandler(&huart2);
  /* USER CODE BEGIN USART2_IRQn 1 */

  /* USER CODE END USART2_IRQn 1 */
}
 80013d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  HAL_UART_IRQHandler(&huart2);
 80013dc:	4806      	ldr	r0, [pc, #24]	; (80013f8 <USART2_IRQHandler+0x44>)
 80013de:	f001 bdf3 	b.w	8002fc8 <HAL_UART_IRQHandler>
	URATCommandParser();
 80013e2:	f7ff fc0b 	bl	8000bfc <URATCommandParser>
}
 80013e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  HAL_UART_IRQHandler(&huart2);
 80013ea:	4803      	ldr	r0, [pc, #12]	; (80013f8 <USART2_IRQHandler+0x44>)
 80013ec:	f001 bdec 	b.w	8002fc8 <HAL_UART_IRQHandler>
 80013f0:	200001fc 	.word	0x200001fc
 80013f4:	20001b1c 	.word	0x20001b1c
 80013f8:	20001c68 	.word	0x20001c68

080013fc <_sbrk>:
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
  const uint8_t *max_heap = (uint8_t *)stack_limit;
  uint8_t *prev_heap_end;

  /* Initalize heap end at first call */
  if (NULL == __sbrk_heap_end)
 80013fc:	490d      	ldr	r1, [pc, #52]	; (8001434 <_sbrk+0x38>)
{
 80013fe:	b510      	push	{r4, lr}
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001400:	4a0d      	ldr	r2, [pc, #52]	; (8001438 <_sbrk+0x3c>)
 8001402:	4c0e      	ldr	r4, [pc, #56]	; (800143c <_sbrk+0x40>)
  if (NULL == __sbrk_heap_end)
 8001404:	680b      	ldr	r3, [r1, #0]
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001406:	1b12      	subs	r2, r2, r4
  if (NULL == __sbrk_heap_end)
 8001408:	b12b      	cbz	r3, 8001416 <_sbrk+0x1a>
  {
    __sbrk_heap_end = &_end;
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 800140a:	4418      	add	r0, r3
 800140c:	4290      	cmp	r0, r2
 800140e:	d808      	bhi.n	8001422 <_sbrk+0x26>
    errno = ENOMEM;
    return (void *)-1;
  }

  prev_heap_end = __sbrk_heap_end;
  __sbrk_heap_end += incr;
 8001410:	6008      	str	r0, [r1, #0]

  return (void *)prev_heap_end;
}
 8001412:	4618      	mov	r0, r3
 8001414:	bd10      	pop	{r4, pc}
    __sbrk_heap_end = &_end;
 8001416:	4c0a      	ldr	r4, [pc, #40]	; (8001440 <_sbrk+0x44>)
 8001418:	4623      	mov	r3, r4
  if (__sbrk_heap_end + incr > max_heap)
 800141a:	4418      	add	r0, r3
 800141c:	4290      	cmp	r0, r2
    __sbrk_heap_end = &_end;
 800141e:	600c      	str	r4, [r1, #0]
  if (__sbrk_heap_end + incr > max_heap)
 8001420:	d9f6      	bls.n	8001410 <_sbrk+0x14>
    errno = ENOMEM;
 8001422:	f003 fc4f 	bl	8004cc4 <__errno>
 8001426:	220c      	movs	r2, #12
    return (void *)-1;
 8001428:	f04f 33ff 	mov.w	r3, #4294967295
    errno = ENOMEM;
 800142c:	6002      	str	r2, [r0, #0]
}
 800142e:	4618      	mov	r0, r3
 8001430:	bd10      	pop	{r4, pc}
 8001432:	bf00      	nop
 8001434:	20000204 	.word	0x20000204
 8001438:	20002800 	.word	0x20002800
 800143c:	00000400 	.word	0x00000400
 8001440:	20001d40 	.word	0x20001d40

08001444 <SystemInit>:

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8001444:	4770      	bx	lr
 8001446:	bf00      	nop

08001448 <HAL_ADC_ConvCpltCallback>:
uint32_t adcBuf = 0;
float tempCelcius = 0;

void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
  tempCelcius = adcBuf*.322;   // convert value from adc buffer to temperature in Centigrade
 8001448:	4b09      	ldr	r3, [pc, #36]	; (8001470 <HAL_ADC_ConvCpltCallback+0x28>)
{
 800144a:	b510      	push	{r4, lr}
  tempCelcius = adcBuf*.322;   // convert value from adc buffer to temperature in Centigrade
 800144c:	6818      	ldr	r0, [r3, #0]
 800144e:	f7fe ffc9 	bl	80003e4 <__aeabi_ui2d>
 8001452:	a305      	add	r3, pc, #20	; (adr r3, 8001468 <HAL_ADC_ConvCpltCallback+0x20>)
 8001454:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001458:	f7ff f83e 	bl	80004d8 <__aeabi_dmul>
 800145c:	f7ff fafe 	bl	8000a5c <__aeabi_d2f>
 8001460:	4c04      	ldr	r4, [pc, #16]	; (8001474 <HAL_ADC_ConvCpltCallback+0x2c>)
 8001462:	6020      	str	r0, [r4, #0]
}
 8001464:	bd10      	pop	{r4, pc}
 8001466:	bf00      	nop
 8001468:	e353f7cf 	.word	0xe353f7cf
 800146c:	3fd49ba5 	.word	0x3fd49ba5
 8001470:	20000208 	.word	0x20000208
 8001474:	2000020c 	.word	0x2000020c

08001478 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 8001478:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800147a:	e003      	b.n	8001484 <LoopCopyDataInit>

0800147c <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 800147c:	4b0b      	ldr	r3, [pc, #44]	; (80014ac <LoopFillZerobss+0x14>)
  ldr r3, [r3, r1]
 800147e:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8001480:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8001482:	3104      	adds	r1, #4

08001484 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8001484:	480a      	ldr	r0, [pc, #40]	; (80014b0 <LoopFillZerobss+0x18>)
  ldr r3, =_edata
 8001486:	4b0b      	ldr	r3, [pc, #44]	; (80014b4 <LoopFillZerobss+0x1c>)
  adds r2, r0, r1
 8001488:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800148a:	429a      	cmp	r2, r3
  bcc CopyDataInit
 800148c:	d3f6      	bcc.n	800147c <CopyDataInit>
  ldr r2, =_sbss
 800148e:	4a0a      	ldr	r2, [pc, #40]	; (80014b8 <LoopFillZerobss+0x20>)
  b LoopFillZerobss
 8001490:	e002      	b.n	8001498 <LoopFillZerobss>

08001492 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8001492:	2300      	movs	r3, #0
  str r3, [r2], #4
 8001494:	f842 3b04 	str.w	r3, [r2], #4

08001498 <LoopFillZerobss>:

LoopFillZerobss:
  ldr r3, = _ebss
 8001498:	4b08      	ldr	r3, [pc, #32]	; (80014bc <LoopFillZerobss+0x24>)
  cmp r2, r3
 800149a:	429a      	cmp	r2, r3
  bcc FillZerobss
 800149c:	d3f9      	bcc.n	8001492 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800149e:	f7ff ffd1 	bl	8001444 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80014a2:	f003 fc15 	bl	8004cd0 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80014a6:	f7ff fcfb 	bl	8000ea0 <main>
  bx lr
 80014aa:	4770      	bx	lr
  ldr r3, =_sidata
 80014ac:	08006924 	.word	0x08006924
  ldr r0, =_sdata
 80014b0:	20000000 	.word	0x20000000
  ldr r3, =_edata
 80014b4:	200001e0 	.word	0x200001e0
  ldr r2, =_sbss
 80014b8:	200001e0 	.word	0x200001e0
  ldr r3, = _ebss
 80014bc:	20001d3c 	.word	0x20001d3c

080014c0 <CAN1_RX1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80014c0:	e7fe      	b.n	80014c0 <CAN1_RX1_IRQHandler>
	...

080014c4 <HAL_Init>:
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80014c4:	4a07      	ldr	r2, [pc, #28]	; (80014e4 <HAL_Init+0x20>)
{
 80014c6:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80014c8:	6813      	ldr	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80014ca:	2003      	movs	r0, #3
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80014cc:	f043 0310 	orr.w	r3, r3, #16
 80014d0:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80014d2:	f000 fb55 	bl	8001b80 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80014d6:	2000      	movs	r0, #0
 80014d8:	f7ff ff08 	bl	80012ec <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80014dc:	f7ff fdfa 	bl	80010d4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80014e0:	2000      	movs	r0, #0
 80014e2:	bd08      	pop	{r3, pc}
 80014e4:	40022000 	.word	0x40022000

080014e8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80014e8:	4a03      	ldr	r2, [pc, #12]	; (80014f8 <HAL_IncTick+0x10>)
 80014ea:	4b04      	ldr	r3, [pc, #16]	; (80014fc <HAL_IncTick+0x14>)
 80014ec:	6811      	ldr	r1, [r2, #0]
 80014ee:	781b      	ldrb	r3, [r3, #0]
 80014f0:	440b      	add	r3, r1
 80014f2:	6013      	str	r3, [r2, #0]
}
 80014f4:	4770      	bx	lr
 80014f6:	bf00      	nop
 80014f8:	20001cf4 	.word	0x20001cf4
 80014fc:	20000004 	.word	0x20000004

08001500 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001500:	4b01      	ldr	r3, [pc, #4]	; (8001508 <HAL_GetTick+0x8>)
 8001502:	6818      	ldr	r0, [r3, #0]
}
 8001504:	4770      	bx	lr
 8001506:	bf00      	nop
 8001508:	20001cf4 	.word	0x20001cf4

0800150c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800150c:	b538      	push	{r3, r4, r5, lr}
 800150e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001510:	f7ff fff6 	bl	8001500 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001514:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8001516:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 8001518:	d002      	beq.n	8001520 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800151a:	4b04      	ldr	r3, [pc, #16]	; (800152c <HAL_Delay+0x20>)
 800151c:	781b      	ldrb	r3, [r3, #0]
 800151e:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8001520:	f7ff ffee 	bl	8001500 <HAL_GetTick>
 8001524:	1b40      	subs	r0, r0, r5
 8001526:	42a0      	cmp	r0, r4
 8001528:	d3fa      	bcc.n	8001520 <HAL_Delay+0x14>
  {
  }
}
 800152a:	bd38      	pop	{r3, r4, r5, pc}
 800152c:	20000004 	.word	0x20000004

08001530 <HAL_ADC_PollForConversion>:
  * @param  hadc: ADC handle
  * @param  Timeout: Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 8001530:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001532:	4605      	mov	r5, r0
  uint32_t tickstart = 0U;
  
  /* Variables for polling in case of scan mode enabled and polling for each  */
  /* conversion.                                                              */
  __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
 8001534:	2700      	movs	r7, #0
{
 8001536:	b083      	sub	sp, #12
 8001538:	460c      	mov	r4, r1
  __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
 800153a:	9701      	str	r7, [sp, #4]
 
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 800153c:	f7ff ffe0 	bl	8001500 <HAL_GetTick>
  
  /* Verification that ADC configuration is compliant with polling for        */
  /* each conversion:                                                         */
  /* Particular case is ADC configured in DMA mode                            */
  if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
 8001540:	682b      	ldr	r3, [r5, #0]
 8001542:	689a      	ldr	r2, [r3, #8]
 8001544:	05d6      	lsls	r6, r2, #23
 8001546:	d462      	bmi.n	800160e <HAL_ADC_PollForConversion+0xde>
  /*    from ADC conversion time (selected sampling time + conversion time of */
  /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
  /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
  /*    As flag EOC is not set after each conversion, no timeout status can   */
  /*    be set.                                                               */
  if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
 8001548:	685a      	ldr	r2, [r3, #4]
 800154a:	4606      	mov	r6, r0
 800154c:	05d0      	lsls	r0, r2, #23
 800154e:	d403      	bmi.n	8001558 <HAL_ADC_PollForConversion+0x28>
      HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
 8001550:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
 8001552:	f412 0f70 	tst.w	r2, #15728640	; 0xf00000
 8001556:	d01e      	beq.n	8001596 <HAL_ADC_PollForConversion+0x66>
    /* Replace polling by wait for maximum conversion time */
    /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
    /*    and ADC maximum conversion cycles on all channels.                  */
    /*  - Wait for the expected ADC clock cycles delay                        */
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
                                          / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
 8001558:	4b45      	ldr	r3, [pc, #276]	; (8001670 <HAL_ADC_PollForConversion+0x140>)
 800155a:	2002      	movs	r0, #2
 800155c:	681f      	ldr	r7, [r3, #0]
 800155e:	f001 f9cb 	bl	80028f8 <HAL_RCCEx_GetPeriphCLKFreq>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 8001562:	682b      	ldr	r3, [r5, #0]
 8001564:	4a43      	ldr	r2, [pc, #268]	; (8001674 <HAL_ADC_PollForConversion+0x144>)
 8001566:	6919      	ldr	r1, [r3, #16]
                                          / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
 8001568:	fbb7 f0f0 	udiv	r0, r7, r0
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 800156c:	4211      	tst	r1, r2
 800156e:	d125      	bne.n	80015bc <HAL_ADC_PollForConversion+0x8c>
 8001570:	68d9      	ldr	r1, [r3, #12]
 8001572:	f102 425c 	add.w	r2, r2, #3690987520	; 0xdc000000
 8001576:	4211      	tst	r1, r2
 8001578:	d120      	bne.n	80015bc <HAL_ADC_PollForConversion+0x8c>
 800157a:	6919      	ldr	r1, [r3, #16]
 800157c:	4a3e      	ldr	r2, [pc, #248]	; (8001678 <HAL_ADC_PollForConversion+0x148>)
 800157e:	4211      	tst	r1, r2
 8001580:	d173      	bne.n	800166a <HAL_ADC_PollForConversion+0x13a>
 8001582:	68d9      	ldr	r1, [r3, #12]
 8001584:	f102 426e 	add.w	r2, r2, #3992977408	; 0xee000000
 8001588:	4211      	tst	r1, r2
 800158a:	bf14      	ite	ne
 800158c:	2729      	movne	r7, #41	; 0x29
 800158e:	2714      	moveq	r7, #20
 8001590:	e01e      	b.n	80015d0 <HAL_ADC_PollForConversion+0xa0>
      if(Timeout != HAL_MAX_DELAY)
 8001592:	1c61      	adds	r1, r4, #1
 8001594:	d150      	bne.n	8001638 <HAL_ADC_PollForConversion+0x108>
    while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
 8001596:	681a      	ldr	r2, [r3, #0]
 8001598:	0792      	lsls	r2, r2, #30
 800159a:	d5fa      	bpl.n	8001592 <HAL_ADC_PollForConversion+0x62>
      Conversion_Timeout_CPU_cycles ++;
    }
  }
  
  /* Clear regular group conversion flag */
  __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 800159c:	f06f 0212 	mvn.w	r2, #18
 80015a0:	601a      	str	r2, [r3, #0]
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80015a2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80015a4:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80015a8:	62aa      	str	r2, [r5, #40]	; 0x28
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  /* Note: On STM32F1 devices, in case of sequencer enabled                   */
  /*       (several ranks selected), end of conversion flag is raised         */
  /*       at the end of the sequence.                                        */
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80015aa:	689b      	ldr	r3, [r3, #8]
 80015ac:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
 80015b0:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
 80015b4:	d049      	beq.n	800164a <HAL_ADC_PollForConversion+0x11a>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
    }
  }
  
  /* Return ADC state */
  return HAL_OK;
 80015b6:	2000      	movs	r0, #0
}
 80015b8:	b003      	add	sp, #12
 80015ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 80015bc:	6919      	ldr	r1, [r3, #16]
 80015be:	4a2e      	ldr	r2, [pc, #184]	; (8001678 <HAL_ADC_PollForConversion+0x148>)
 80015c0:	4211      	tst	r1, r2
 80015c2:	d11a      	bne.n	80015fa <HAL_ADC_PollForConversion+0xca>
 80015c4:	68d9      	ldr	r1, [r3, #12]
 80015c6:	f102 426e 	add.w	r2, r2, #3992977408	; 0xee000000
 80015ca:	4211      	tst	r1, r2
 80015cc:	d115      	bne.n	80015fa <HAL_ADC_PollForConversion+0xca>
 80015ce:	2754      	movs	r7, #84	; 0x54
    Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
 80015d0:	fb07 f700 	mul.w	r7, r7, r0
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 80015d4:	9a01      	ldr	r2, [sp, #4]
 80015d6:	4297      	cmp	r7, r2
 80015d8:	d9e0      	bls.n	800159c <HAL_ADC_PollForConversion+0x6c>
      if(Timeout != HAL_MAX_DELAY)
 80015da:	1c63      	adds	r3, r4, #1
 80015dc:	d005      	beq.n	80015ea <HAL_ADC_PollForConversion+0xba>
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
 80015de:	b30c      	cbz	r4, 8001624 <HAL_ADC_PollForConversion+0xf4>
 80015e0:	f7ff ff8e 	bl	8001500 <HAL_GetTick>
 80015e4:	1b80      	subs	r0, r0, r6
 80015e6:	42a0      	cmp	r0, r4
 80015e8:	d81c      	bhi.n	8001624 <HAL_ADC_PollForConversion+0xf4>
      Conversion_Timeout_CPU_cycles ++;
 80015ea:	9b01      	ldr	r3, [sp, #4]
 80015ec:	3301      	adds	r3, #1
 80015ee:	9301      	str	r3, [sp, #4]
    while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
 80015f0:	9b01      	ldr	r3, [sp, #4]
 80015f2:	42bb      	cmp	r3, r7
 80015f4:	d3f1      	bcc.n	80015da <HAL_ADC_PollForConversion+0xaa>
 80015f6:	682b      	ldr	r3, [r5, #0]
 80015f8:	e7d0      	b.n	800159c <HAL_ADC_PollForConversion+0x6c>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 80015fa:	6919      	ldr	r1, [r3, #16]
 80015fc:	4a1f      	ldr	r2, [pc, #124]	; (800167c <HAL_ADC_PollForConversion+0x14c>)
 80015fe:	4211      	tst	r1, r2
 8001600:	d10e      	bne.n	8001620 <HAL_ADC_PollForConversion+0xf0>
 8001602:	68d9      	ldr	r1, [r3, #12]
 8001604:	4211      	tst	r1, r2
 8001606:	bf14      	ite	ne
 8001608:	27fc      	movne	r7, #252	; 0xfc
 800160a:	2754      	moveq	r7, #84	; 0x54
 800160c:	e7e0      	b.n	80015d0 <HAL_ADC_PollForConversion+0xa0>
    return HAL_ERROR;
 800160e:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001610:	6aab      	ldr	r3, [r5, #40]	; 0x28
    __HAL_UNLOCK(hadc);
 8001612:	f885 7024 	strb.w	r7, [r5, #36]	; 0x24
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001616:	f043 0320 	orr.w	r3, r3, #32
 800161a:	62ab      	str	r3, [r5, #40]	; 0x28
}
 800161c:	b003      	add	sp, #12
 800161e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 8001620:	27fc      	movs	r7, #252	; 0xfc
 8001622:	e7d5      	b.n	80015d0 <HAL_ADC_PollForConversion+0xa0>
          __HAL_UNLOCK(hadc);
 8001624:	2200      	movs	r2, #0
          return HAL_TIMEOUT;
 8001626:	2003      	movs	r0, #3
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8001628:	6aab      	ldr	r3, [r5, #40]	; 0x28
          __HAL_UNLOCK(hadc);
 800162a:	f885 2024 	strb.w	r2, [r5, #36]	; 0x24
          SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 800162e:	f043 0304 	orr.w	r3, r3, #4
 8001632:	62ab      	str	r3, [r5, #40]	; 0x28
}
 8001634:	b003      	add	sp, #12
 8001636:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
 8001638:	2c00      	cmp	r4, #0
 800163a:	d0f3      	beq.n	8001624 <HAL_ADC_PollForConversion+0xf4>
 800163c:	f7ff ff60 	bl	8001500 <HAL_GetTick>
 8001640:	1b80      	subs	r0, r0, r6
 8001642:	42a0      	cmp	r0, r4
 8001644:	d8ee      	bhi.n	8001624 <HAL_ADC_PollForConversion+0xf4>
 8001646:	682b      	ldr	r3, [r5, #0]
 8001648:	e7a5      	b.n	8001596 <HAL_ADC_PollForConversion+0x66>
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 800164a:	7b2b      	ldrb	r3, [r5, #12]
 800164c:	2b00      	cmp	r3, #0
 800164e:	d1b2      	bne.n	80015b6 <HAL_ADC_PollForConversion+0x86>
    CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 8001650:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001652:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001656:	62ab      	str	r3, [r5, #40]	; 0x28
    if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8001658:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 800165a:	f410 5080 	ands.w	r0, r0, #4096	; 0x1000
 800165e:	d1aa      	bne.n	80015b6 <HAL_ADC_PollForConversion+0x86>
      SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8001660:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001662:	f043 0301 	orr.w	r3, r3, #1
 8001666:	62ab      	str	r3, [r5, #40]	; 0x28
 8001668:	e7a6      	b.n	80015b8 <HAL_ADC_PollForConversion+0x88>
                                         * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
 800166a:	2729      	movs	r7, #41	; 0x29
 800166c:	e7b0      	b.n	80015d0 <HAL_ADC_PollForConversion+0xa0>
 800166e:	bf00      	nop
 8001670:	20000000 	.word	0x20000000
 8001674:	24924924 	.word	0x24924924
 8001678:	12492492 	.word	0x12492492
 800167c:	00249249 	.word	0x00249249

08001680 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8001680:	6803      	ldr	r3, [r0, #0]
 8001682:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
}
 8001684:	4770      	bx	lr
 8001686:	bf00      	nop

08001688 <HAL_ADC_LevelOutOfWindowCallback>:
 8001688:	4770      	bx	lr
 800168a:	bf00      	nop

0800168c <HAL_ADC_IRQHandler>:
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
  
  
  /* ========== Check End of Conversion flag for regular group ========== */
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
 800168c:	6803      	ldr	r3, [r0, #0]
{
 800168e:	b510      	push	{r4, lr}
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
 8001690:	685a      	ldr	r2, [r3, #4]
{
 8001692:	4604      	mov	r4, r0
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
 8001694:	0690      	lsls	r0, r2, #26
 8001696:	d502      	bpl.n	800169e <HAL_ADC_IRQHandler+0x12>
  {
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
 8001698:	681a      	ldr	r2, [r3, #0]
 800169a:	0791      	lsls	r1, r2, #30
 800169c:	d42a      	bmi.n	80016f4 <HAL_ADC_IRQHandler+0x68>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
    }
  }
  
  /* ========== Check End of Conversion flag for injected group ========== */
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
 800169e:	685a      	ldr	r2, [r3, #4]
 80016a0:	0610      	lsls	r0, r2, #24
 80016a2:	d502      	bpl.n	80016aa <HAL_ADC_IRQHandler+0x1e>
  {
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
 80016a4:	681a      	ldr	r2, [r3, #0]
 80016a6:	0751      	lsls	r1, r2, #29
 80016a8:	d406      	bmi.n	80016b8 <HAL_ADC_IRQHandler+0x2c>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
    }
  }
   
  /* ========== Check Analog watchdog flags ========== */
  if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
 80016aa:	685a      	ldr	r2, [r3, #4]
 80016ac:	0652      	lsls	r2, r2, #25
 80016ae:	d502      	bpl.n	80016b6 <HAL_ADC_IRQHandler+0x2a>
  {
    if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
 80016b0:	681b      	ldr	r3, [r3, #0]
 80016b2:	07db      	lsls	r3, r3, #31
 80016b4:	d433      	bmi.n	800171e <HAL_ADC_IRQHandler+0x92>
      /* Clear the ADC analog watchdog flag */
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
    }
  }
  
}
 80016b6:	bd10      	pop	{r4, pc}
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80016b8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016ba:	06d2      	lsls	r2, r2, #27
 80016bc:	d403      	bmi.n	80016c6 <HAL_ADC_IRQHandler+0x3a>
        SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 80016be:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016c0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80016c4:	62a2      	str	r2, [r4, #40]	; 0x28
      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 80016c6:	689a      	ldr	r2, [r3, #8]
 80016c8:	f402 42e0 	and.w	r2, r2, #28672	; 0x7000
 80016cc:	f5b2 4fe0 	cmp.w	r2, #28672	; 0x7000
 80016d0:	d034      	beq.n	800173c <HAL_ADC_IRQHandler+0xb0>
         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 80016d2:	685a      	ldr	r2, [r3, #4]
      if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
 80016d4:	0550      	lsls	r0, r2, #21
 80016d6:	d405      	bmi.n	80016e4 <HAL_ADC_IRQHandler+0x58>
         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 80016d8:	689a      	ldr	r2, [r3, #8]
 80016da:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
         (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
 80016de:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 80016e2:	d028      	beq.n	8001736 <HAL_ADC_IRQHandler+0xaa>
      HAL_ADCEx_InjectedConvCpltCallback(hadc);
 80016e4:	4620      	mov	r0, r4
 80016e6:	f000 fa49 	bl	8001b7c <HAL_ADCEx_InjectedConvCpltCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
 80016ea:	f06f 020c 	mvn.w	r2, #12
 80016ee:	6823      	ldr	r3, [r4, #0]
 80016f0:	601a      	str	r2, [r3, #0]
 80016f2:	e7da      	b.n	80016aa <HAL_ADC_IRQHandler+0x1e>
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80016f4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016f6:	06d2      	lsls	r2, r2, #27
 80016f8:	d403      	bmi.n	8001702 <HAL_ADC_IRQHandler+0x76>
        SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
 80016fa:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80016fc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001700:	62a2      	str	r2, [r4, #40]	; 0x28
      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 8001702:	689a      	ldr	r2, [r3, #8]
 8001704:	f402 2260 	and.w	r2, r2, #917504	; 0xe0000
 8001708:	f5b2 2f60 	cmp.w	r2, #917504	; 0xe0000
 800170c:	d026      	beq.n	800175c <HAL_ADC_IRQHandler+0xd0>
      HAL_ADC_ConvCpltCallback(hadc);
 800170e:	4620      	mov	r0, r4
 8001710:	f7ff fe9a 	bl	8001448 <HAL_ADC_ConvCpltCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
 8001714:	f06f 0212 	mvn.w	r2, #18
 8001718:	6823      	ldr	r3, [r4, #0]
 800171a:	601a      	str	r2, [r3, #0]
 800171c:	e7bf      	b.n	800169e <HAL_ADC_IRQHandler+0x12>
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 800171e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 8001720:	4620      	mov	r0, r4
      SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8001722:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001726:	62a3      	str	r3, [r4, #40]	; 0x28
      HAL_ADC_LevelOutOfWindowCallback(hadc);
 8001728:	f7ff ffae 	bl	8001688 <HAL_ADC_LevelOutOfWindowCallback>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
 800172c:	f06f 0201 	mvn.w	r2, #1
 8001730:	6823      	ldr	r3, [r4, #0]
 8001732:	601a      	str	r2, [r3, #0]
}
 8001734:	bd10      	pop	{r4, pc}
         (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
 8001736:	7b22      	ldrb	r2, [r4, #12]
 8001738:	2a00      	cmp	r2, #0
 800173a:	d1d3      	bne.n	80016e4 <HAL_ADC_IRQHandler+0x58>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
 800173c:	685a      	ldr	r2, [r3, #4]
 800173e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001742:	605a      	str	r2, [r3, #4]
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
 8001744:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001746:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800174a:	62a3      	str	r3, [r4, #40]	; 0x28
        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
 800174c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800174e:	05d9      	lsls	r1, r3, #23
 8001750:	d4c8      	bmi.n	80016e4 <HAL_ADC_IRQHandler+0x58>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8001752:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001754:	f043 0301 	orr.w	r3, r3, #1
 8001758:	62a3      	str	r3, [r4, #40]	; 0x28
 800175a:	e7c3      	b.n	80016e4 <HAL_ADC_IRQHandler+0x58>
      if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 800175c:	7b22      	ldrb	r2, [r4, #12]
 800175e:	2a00      	cmp	r2, #0
 8001760:	d1d5      	bne.n	800170e <HAL_ADC_IRQHandler+0x82>
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
 8001762:	685a      	ldr	r2, [r3, #4]
 8001764:	f022 0220 	bic.w	r2, r2, #32
 8001768:	605a      	str	r2, [r3, #4]
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
 800176a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800176c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001770:	62a3      	str	r3, [r4, #40]	; 0x28
        if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8001772:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001774:	04db      	lsls	r3, r3, #19
 8001776:	d4ca      	bmi.n	800170e <HAL_ADC_IRQHandler+0x82>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8001778:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800177a:	f043 0301 	orr.w	r3, r3, #1
 800177e:	62a3      	str	r3, [r4, #40]	; 0x28
 8001780:	e7c5      	b.n	800170e <HAL_ADC_IRQHandler+0x82>
 8001782:	bf00      	nop

08001784 <HAL_ADC_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{ 
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0U;
 8001784:	2200      	movs	r2, #0
{ 
 8001786:	b470      	push	{r4, r5, r6}
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001788:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
{ 
 800178c:	b083      	sub	sp, #12
  __HAL_LOCK(hadc);
 800178e:	2b01      	cmp	r3, #1
  __IO uint32_t wait_loop_index = 0U;
 8001790:	9201      	str	r2, [sp, #4]
  __HAL_LOCK(hadc);
 8001792:	d05f      	beq.n	8001854 <HAL_ADC_ConfigChannel+0xd0>
 8001794:	2301      	movs	r3, #1
  
  
  /* Regular sequence configuration */
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7U)
 8001796:	684d      	ldr	r5, [r1, #4]
 8001798:	6804      	ldr	r4, [r0, #0]
 800179a:	2d06      	cmp	r5, #6
  __HAL_LOCK(hadc);
 800179c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
 80017a0:	680a      	ldr	r2, [r1, #0]
 80017a2:	eb05 0385 	add.w	r3, r5, r5, lsl #2
  {
    MODIFY_REG(hadc->Instance->SQR3                        ,
 80017a6:	f04f 061f 	mov.w	r6, #31
  if (sConfig->Rank < 7U)
 80017aa:	d925      	bls.n	80017f8 <HAL_ADC_ConfigChannel+0x74>
               ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
               ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13U)
 80017ac:	2d0c      	cmp	r5, #12
 80017ae:	d847      	bhi.n	8001840 <HAL_ADC_ConfigChannel+0xbc>
  {
    MODIFY_REG(hadc->Instance->SQR2                        ,
 80017b0:	3b23      	subs	r3, #35	; 0x23
 80017b2:	6b25      	ldr	r5, [r4, #48]	; 0x30
 80017b4:	409e      	lsls	r6, r3
 80017b6:	ea25 0506 	bic.w	r5, r5, r6
 80017ba:	fa02 f303 	lsl.w	r3, r2, r3
 80017be:	432b      	orrs	r3, r5
 80017c0:	6323      	str	r3, [r4, #48]	; 0x30
  }
  
  
  /* Channel sampling time configuration */
  /* For channels 10 to 17 */
  if (sConfig->Channel >= ADC_CHANNEL_10)
 80017c2:	2a09      	cmp	r2, #9
 80017c4:	688b      	ldr	r3, [r1, #8]
  {
    MODIFY_REG(hadc->Instance->SMPR1                             ,
 80017c6:	f04f 0607 	mov.w	r6, #7
 80017ca:	eb02 0142 	add.w	r1, r2, r2, lsl #1
  if (sConfig->Channel >= ADC_CHANNEL_10)
 80017ce:	d923      	bls.n	8001818 <HAL_ADC_ConfigChannel+0x94>
    MODIFY_REG(hadc->Instance->SMPR1                             ,
 80017d0:	391e      	subs	r1, #30
 80017d2:	68e5      	ldr	r5, [r4, #12]
 80017d4:	408e      	lsls	r6, r1
 80017d6:	408b      	lsls	r3, r1
 80017d8:	ea25 0106 	bic.w	r1, r5, r6
 80017dc:	430b      	orrs	r3, r1
 80017de:	60e3      	str	r3, [r4, #12]
               ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
  }
  
  /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
  /* and VREFINT measurement path.                                            */
  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
 80017e0:	f1a2 0310 	sub.w	r3, r2, #16
 80017e4:	2b01      	cmp	r3, #1
 80017e6:	d922      	bls.n	800182e <HAL_ADC_ConfigChannel+0xaa>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80017e8:	2300      	movs	r3, #0
      tmp_hal_status = HAL_ERROR;
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80017ea:	2200      	movs	r2, #0
 80017ec:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
  
  /* Return function status */
  return tmp_hal_status;
}
 80017f0:	4618      	mov	r0, r3
 80017f2:	b003      	add	sp, #12
 80017f4:	bc70      	pop	{r4, r5, r6}
 80017f6:	4770      	bx	lr
    MODIFY_REG(hadc->Instance->SQR3                        ,
 80017f8:	3b05      	subs	r3, #5
 80017fa:	6b65      	ldr	r5, [r4, #52]	; 0x34
 80017fc:	409e      	lsls	r6, r3
 80017fe:	ea25 0506 	bic.w	r5, r5, r6
 8001802:	fa02 f303 	lsl.w	r3, r2, r3
 8001806:	432b      	orrs	r3, r5
  if (sConfig->Channel >= ADC_CHANNEL_10)
 8001808:	2a09      	cmp	r2, #9
    MODIFY_REG(hadc->Instance->SQR3                        ,
 800180a:	6363      	str	r3, [r4, #52]	; 0x34
    MODIFY_REG(hadc->Instance->SMPR1                             ,
 800180c:	f04f 0607 	mov.w	r6, #7
 8001810:	688b      	ldr	r3, [r1, #8]
 8001812:	eb02 0142 	add.w	r1, r2, r2, lsl #1
  if (sConfig->Channel >= ADC_CHANNEL_10)
 8001816:	d8db      	bhi.n	80017d0 <HAL_ADC_ConfigChannel+0x4c>
    MODIFY_REG(hadc->Instance->SMPR2                             ,
 8001818:	6925      	ldr	r5, [r4, #16]
 800181a:	408e      	lsls	r6, r1
 800181c:	408b      	lsls	r3, r1
 800181e:	ea25 0106 	bic.w	r1, r5, r6
 8001822:	430b      	orrs	r3, r1
 8001824:	6123      	str	r3, [r4, #16]
  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
 8001826:	f1a2 0310 	sub.w	r3, r2, #16
 800182a:	2b01      	cmp	r3, #1
 800182c:	d8dc      	bhi.n	80017e8 <HAL_ADC_ConfigChannel+0x64>
    if (hadc->Instance == ADC1)
 800182e:	4b1a      	ldr	r3, [pc, #104]	; (8001898 <HAL_ADC_ConfigChannel+0x114>)
 8001830:	429c      	cmp	r4, r3
 8001832:	d014      	beq.n	800185e <HAL_ADC_ConfigChannel+0xda>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001834:	6a82      	ldr	r2, [r0, #40]	; 0x28
      tmp_hal_status = HAL_ERROR;
 8001836:	2301      	movs	r3, #1
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001838:	f042 0220 	orr.w	r2, r2, #32
 800183c:	6282      	str	r2, [r0, #40]	; 0x28
 800183e:	e7d4      	b.n	80017ea <HAL_ADC_ConfigChannel+0x66>
    MODIFY_REG(hadc->Instance->SQR1                        ,
 8001840:	3b41      	subs	r3, #65	; 0x41
 8001842:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8001844:	409e      	lsls	r6, r3
 8001846:	ea25 0506 	bic.w	r5, r5, r6
 800184a:	fa02 f303 	lsl.w	r3, r2, r3
 800184e:	432b      	orrs	r3, r5
 8001850:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001852:	e7b6      	b.n	80017c2 <HAL_ADC_ConfigChannel+0x3e>
  __HAL_LOCK(hadc);
 8001854:	2302      	movs	r3, #2
}
 8001856:	4618      	mov	r0, r3
 8001858:	b003      	add	sp, #12
 800185a:	bc70      	pop	{r4, r5, r6}
 800185c:	4770      	bx	lr
      if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
 800185e:	68a3      	ldr	r3, [r4, #8]
 8001860:	021b      	lsls	r3, r3, #8
 8001862:	d4c1      	bmi.n	80017e8 <HAL_ADC_ConfigChannel+0x64>
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 8001864:	68a3      	ldr	r3, [r4, #8]
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 8001866:	2a10      	cmp	r2, #16
        SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
 8001868:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800186c:	60a3      	str	r3, [r4, #8]
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
 800186e:	d1bb      	bne.n	80017e8 <HAL_ADC_ConfigChannel+0x64>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8001870:	4b0a      	ldr	r3, [pc, #40]	; (800189c <HAL_ADC_ConfigChannel+0x118>)
 8001872:	4a0b      	ldr	r2, [pc, #44]	; (80018a0 <HAL_ADC_ConfigChannel+0x11c>)
 8001874:	681b      	ldr	r3, [r3, #0]
 8001876:	fba2 2303 	umull	r2, r3, r2, r3
 800187a:	0c9b      	lsrs	r3, r3, #18
 800187c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8001880:	005b      	lsls	r3, r3, #1
 8001882:	9301      	str	r3, [sp, #4]
          while(wait_loop_index != 0U)
 8001884:	9b01      	ldr	r3, [sp, #4]
 8001886:	2b00      	cmp	r3, #0
 8001888:	d0ae      	beq.n	80017e8 <HAL_ADC_ConfigChannel+0x64>
            wait_loop_index--;
 800188a:	9b01      	ldr	r3, [sp, #4]
 800188c:	3b01      	subs	r3, #1
 800188e:	9301      	str	r3, [sp, #4]
          while(wait_loop_index != 0U)
 8001890:	9b01      	ldr	r3, [sp, #4]
 8001892:	2b00      	cmp	r3, #0
 8001894:	d1f9      	bne.n	800188a <HAL_ADC_ConfigChannel+0x106>
 8001896:	e7a7      	b.n	80017e8 <HAL_ADC_ConfigChannel+0x64>
 8001898:	40012400 	.word	0x40012400
 800189c:	20000000 	.word	0x20000000
 80018a0:	431bde83 	.word	0x431bde83

080018a4 <ADC_Enable>:
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
  uint32_t tickstart = 0U;
  __IO uint32_t wait_loop_index = 0U;
 80018a4:	2300      	movs	r3, #0
{
 80018a6:	b570      	push	{r4, r5, r6, lr}
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 80018a8:	6802      	ldr	r2, [r0, #0]
{
 80018aa:	b082      	sub	sp, #8
  __IO uint32_t wait_loop_index = 0U;
 80018ac:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 80018ae:	6893      	ldr	r3, [r2, #8]
 80018b0:	07db      	lsls	r3, r3, #31
 80018b2:	d421      	bmi.n	80018f8 <ADC_Enable+0x54>
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80018b4:	4b18      	ldr	r3, [pc, #96]	; (8001918 <ADC_Enable+0x74>)
 80018b6:	4c19      	ldr	r4, [pc, #100]	; (800191c <ADC_Enable+0x78>)
 80018b8:	681b      	ldr	r3, [r3, #0]
    __HAL_ADC_ENABLE(hadc);
 80018ba:	6891      	ldr	r1, [r2, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80018bc:	fba4 4303 	umull	r4, r3, r4, r3
    __HAL_ADC_ENABLE(hadc);
 80018c0:	f041 0101 	orr.w	r1, r1, #1
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80018c4:	0c9b      	lsrs	r3, r3, #18
    __HAL_ADC_ENABLE(hadc);
 80018c6:	6091      	str	r1, [r2, #8]
    wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
 80018c8:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0U)
 80018ca:	9b01      	ldr	r3, [sp, #4]
 80018cc:	b12b      	cbz	r3, 80018da <ADC_Enable+0x36>
    {
      wait_loop_index--;
 80018ce:	9b01      	ldr	r3, [sp, #4]
 80018d0:	3b01      	subs	r3, #1
 80018d2:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0U)
 80018d4:	9b01      	ldr	r3, [sp, #4]
 80018d6:	2b00      	cmp	r3, #0
 80018d8:	d1f9      	bne.n	80018ce <ADC_Enable+0x2a>
 80018da:	4605      	mov	r5, r0
    }
    
    /* Get tick count */
    tickstart = HAL_GetTick();
 80018dc:	f7ff fe10 	bl	8001500 <HAL_GetTick>
 80018e0:	4606      	mov	r6, r0

    /* Wait for ADC effectively enabled */
    while(ADC_IS_ENABLE(hadc) == RESET)
 80018e2:	e004      	b.n	80018ee <ADC_Enable+0x4a>
    {
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 80018e4:	f7ff fe0c 	bl	8001500 <HAL_GetTick>
 80018e8:	1b80      	subs	r0, r0, r6
 80018ea:	2802      	cmp	r0, #2
 80018ec:	d807      	bhi.n	80018fe <ADC_Enable+0x5a>
    while(ADC_IS_ENABLE(hadc) == RESET)
 80018ee:	682b      	ldr	r3, [r5, #0]
 80018f0:	689c      	ldr	r4, [r3, #8]
 80018f2:	f014 0401 	ands.w	r4, r4, #1
 80018f6:	d0f5      	beq.n	80018e4 <ADC_Enable+0x40>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 80018f8:	2000      	movs	r0, #0
}
 80018fa:	b002      	add	sp, #8
 80018fc:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_UNLOCK(hadc);
 80018fe:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001900:	6aab      	ldr	r3, [r5, #40]	; 0x28
        __HAL_UNLOCK(hadc);
 8001902:	f885 4024 	strb.w	r4, [r5, #36]	; 0x24
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001906:	f043 0310 	orr.w	r3, r3, #16
 800190a:	62ab      	str	r3, [r5, #40]	; 0x28
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800190c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800190e:	4303      	orrs	r3, r0
 8001910:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 8001912:	b002      	add	sp, #8
 8001914:	bd70      	pop	{r4, r5, r6, pc}
 8001916:	bf00      	nop
 8001918:	20000000 	.word	0x20000000
 800191c:	431bde83 	.word	0x431bde83

08001920 <HAL_ADC_Start>:
  __HAL_LOCK(hadc);
 8001920:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 8001924:	2b01      	cmp	r3, #1
 8001926:	d038      	beq.n	800199a <HAL_ADC_Start+0x7a>
 8001928:	2301      	movs	r3, #1
{
 800192a:	b510      	push	{r4, lr}
  __HAL_LOCK(hadc);
 800192c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
 8001930:	4604      	mov	r4, r0
  tmp_hal_status = ADC_Enable(hadc);
 8001932:	f7ff ffb7 	bl	80018a4 <ADC_Enable>
  if (tmp_hal_status == HAL_OK)
 8001936:	bb60      	cbnz	r0, 8001992 <HAL_ADC_Start+0x72>
    ADC_STATE_CLR_SET(hadc->State,
 8001938:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800193a:	6822      	ldr	r2, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 800193c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 8001940:	4928      	ldr	r1, [pc, #160]	; (80019e4 <HAL_ADC_Start+0xc4>)
    ADC_STATE_CLR_SET(hadc->State,
 8001942:	f023 0301 	bic.w	r3, r3, #1
 8001946:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800194a:	428a      	cmp	r2, r1
    ADC_STATE_CLR_SET(hadc->State,
 800194c:	62a3      	str	r3, [r4, #40]	; 0x28
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800194e:	d026      	beq.n	800199e <HAL_ADC_Start+0x7e>
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8001950:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001952:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8001956:	62a3      	str	r3, [r4, #40]	; 0x28
      if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
 8001958:	6853      	ldr	r3, [r2, #4]
 800195a:	0559      	lsls	r1, r3, #21
 800195c:	d42b      	bmi.n	80019b6 <HAL_ADC_Start+0x96>
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 800195e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    __HAL_UNLOCK(hadc);
 8001960:	2100      	movs	r1, #0
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 8001962:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 8001966:	bf18      	it	ne
 8001968:	6ae3      	ldrne	r3, [r4, #44]	; 0x2c
    __HAL_UNLOCK(hadc);
 800196a:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 800196e:	bf18      	it	ne
 8001970:	f023 0306 	bicne.w	r3, r3, #6
      ADC_CLEAR_ERRORCODE(hadc);
 8001974:	62e3      	str	r3, [r4, #44]	; 0x2c
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
 8001976:	f06f 0302 	mvn.w	r3, #2
 800197a:	6013      	str	r3, [r2, #0]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 800197c:	6893      	ldr	r3, [r2, #8]
 800197e:	f403 2360 	and.w	r3, r3, #917504	; 0xe0000
 8001982:	f5b3 2f60 	cmp.w	r3, #917504	; 0xe0000
 8001986:	d01d      	beq.n	80019c4 <HAL_ADC_Start+0xa4>
      SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
 8001988:	6893      	ldr	r3, [r2, #8]
 800198a:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 800198e:	6093      	str	r3, [r2, #8]
}
 8001990:	bd10      	pop	{r4, pc}
    __HAL_UNLOCK(hadc);
 8001992:	2300      	movs	r3, #0
 8001994:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
}
 8001998:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hadc);
 800199a:	2002      	movs	r0, #2
}
 800199c:	4770      	bx	lr
    if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
 800199e:	4b12      	ldr	r3, [pc, #72]	; (80019e8 <HAL_ADC_Start+0xc8>)
 80019a0:	6859      	ldr	r1, [r3, #4]
 80019a2:	f411 2f70 	tst.w	r1, #983040	; 0xf0000
 80019a6:	d0d3      	beq.n	8001950 <HAL_ADC_Start+0x30>
      SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80019a8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80019aa:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80019ae:	62a1      	str	r1, [r4, #40]	; 0x28
      if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
 80019b0:	685b      	ldr	r3, [r3, #4]
 80019b2:	055b      	lsls	r3, r3, #21
 80019b4:	d5d3      	bpl.n	800195e <HAL_ADC_Start+0x3e>
        ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
 80019b6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80019b8:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80019bc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80019c0:	62a3      	str	r3, [r4, #40]	; 0x28
 80019c2:	e7cc      	b.n	800195e <HAL_ADC_Start+0x3e>
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 80019c4:	4b07      	ldr	r3, [pc, #28]	; (80019e4 <HAL_ADC_Start+0xc4>)
 80019c6:	429a      	cmp	r2, r3
 80019c8:	d004      	beq.n	80019d4 <HAL_ADC_Start+0xb4>
      SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
 80019ca:	6893      	ldr	r3, [r2, #8]
 80019cc:	f443 03a0 	orr.w	r3, r3, #5242880	; 0x500000
 80019d0:	6093      	str	r3, [r2, #8]
}
 80019d2:	bd10      	pop	{r4, pc}
        ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
 80019d4:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 80019d8:	685b      	ldr	r3, [r3, #4]
    if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
 80019da:	f413 2f70 	tst.w	r3, #983040	; 0xf0000
 80019de:	d1d3      	bne.n	8001988 <HAL_ADC_Start+0x68>
 80019e0:	e7f3      	b.n	80019ca <HAL_ADC_Start+0xaa>
 80019e2:	bf00      	nop
 80019e4:	40012800 	.word	0x40012800
 80019e8:	40012400 	.word	0x40012400

080019ec <ADC_ConversionStop_Disable>:
  *         stopped to disable the ADC.
  * @param  hadc: ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
{
 80019ec:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0U;
  
  /* Verification if ADC is not already disabled */
  if (ADC_IS_ENABLE(hadc) != RESET)
 80019ee:	6803      	ldr	r3, [r0, #0]
 80019f0:	689a      	ldr	r2, [r3, #8]
 80019f2:	07d2      	lsls	r2, r2, #31
 80019f4:	d401      	bmi.n	80019fa <ADC_ConversionStop_Disable+0xe>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 80019f6:	2000      	movs	r0, #0
}
 80019f8:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_ADC_DISABLE(hadc);
 80019fa:	689a      	ldr	r2, [r3, #8]
 80019fc:	4604      	mov	r4, r0
 80019fe:	f022 0201 	bic.w	r2, r2, #1
 8001a02:	609a      	str	r2, [r3, #8]
    tickstart = HAL_GetTick();
 8001a04:	f7ff fd7c 	bl	8001500 <HAL_GetTick>
 8001a08:	4605      	mov	r5, r0
    while(ADC_IS_ENABLE(hadc) != RESET)
 8001a0a:	6823      	ldr	r3, [r4, #0]
 8001a0c:	689b      	ldr	r3, [r3, #8]
 8001a0e:	07db      	lsls	r3, r3, #31
 8001a10:	d5f1      	bpl.n	80019f6 <ADC_ConversionStop_Disable+0xa>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8001a12:	f7ff fd75 	bl	8001500 <HAL_GetTick>
 8001a16:	1b40      	subs	r0, r0, r5
 8001a18:	2802      	cmp	r0, #2
 8001a1a:	d9f6      	bls.n	8001a0a <ADC_ConversionStop_Disable+0x1e>
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001a1c:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001a1e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001a20:	f043 0310 	orr.w	r3, r3, #16
 8001a24:	62a3      	str	r3, [r4, #40]	; 0x28
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001a26:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001a28:	4303      	orrs	r3, r0
 8001a2a:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8001a2c:	bd38      	pop	{r3, r4, r5, pc}
 8001a2e:	bf00      	nop

08001a30 <HAL_ADC_Init>:
  if(hadc == NULL)
 8001a30:	2800      	cmp	r0, #0
 8001a32:	d057      	beq.n	8001ae4 <HAL_ADC_Init+0xb4>
{
 8001a34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (hadc->State == HAL_ADC_STATE_RESET)
 8001a36:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8001a38:	4604      	mov	r4, r0
 8001a3a:	2b00      	cmp	r3, #0
 8001a3c:	d045      	beq.n	8001aca <HAL_ADC_Init+0x9a>
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8001a3e:	4620      	mov	r0, r4
 8001a40:	f7ff ffd4 	bl	80019ec <ADC_ConversionStop_Disable>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 8001a44:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001a46:	f013 0310 	ands.w	r3, r3, #16
 8001a4a:	d138      	bne.n	8001abe <HAL_ADC_Init+0x8e>
 8001a4c:	2800      	cmp	r0, #0
 8001a4e:	d136      	bne.n	8001abe <HAL_ADC_Init+0x8e>
    ADC_STATE_CLR_SET(hadc->State,
 8001a50:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    tmp_cr2 |= (hadc->Init.DataAlign                                          |
 8001a52:	69e6      	ldr	r6, [r4, #28]
 8001a54:	6861      	ldr	r1, [r4, #4]
    ADC_STATE_CLR_SET(hadc->State,
 8001a56:	f422 5288 	bic.w	r2, r2, #4352	; 0x1100
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001a5a:	68a5      	ldr	r5, [r4, #8]
    ADC_STATE_CLR_SET(hadc->State,
 8001a5c:	f022 0202 	bic.w	r2, r2, #2
                ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)   );
 8001a60:	7b27      	ldrb	r7, [r4, #12]
    ADC_STATE_CLR_SET(hadc->State,
 8001a62:	f042 0202 	orr.w	r2, r2, #2
    tmp_cr2 |= (hadc->Init.DataAlign                                          |
 8001a66:	4331      	orrs	r1, r6
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001a68:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
    ADC_STATE_CLR_SET(hadc->State,
 8001a6c:	62a2      	str	r2, [r4, #40]	; 0x28
                ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv)            |
 8001a6e:	ea41 0147 	orr.w	r1, r1, r7, lsl #1
 8001a72:	7d26      	ldrb	r6, [r4, #20]
 8001a74:	6822      	ldr	r2, [r4, #0]
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001a76:	d037      	beq.n	8001ae8 <HAL_ADC_Init+0xb8>
 8001a78:	2d01      	cmp	r5, #1
 8001a7a:	d04f      	beq.n	8001b1c <HAL_ADC_Init+0xec>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001a7c:	2e01      	cmp	r6, #1
 8001a7e:	d052      	beq.n	8001b26 <HAL_ADC_Init+0xf6>
      MODIFY_REG(hadc->Instance->CR1,
 8001a80:	6855      	ldr	r5, [r2, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8001a82:	4b3c      	ldr	r3, [pc, #240]	; (8001b74 <HAL_ADC_Init+0x144>)
      MODIFY_REG(hadc->Instance->CR1,
 8001a84:	f425 4569 	bic.w	r5, r5, #59648	; 0xe900
 8001a88:	6055      	str	r5, [r2, #4]
  uint32_t tmp_sqr1 = 0U;
 8001a8a:	4605      	mov	r5, r0
      MODIFY_REG(hadc->Instance->CR2,
 8001a8c:	6896      	ldr	r6, [r2, #8]
 8001a8e:	4033      	ands	r3, r6
 8001a90:	430b      	orrs	r3, r1
 8001a92:	6093      	str	r3, [r2, #8]
    MODIFY_REG(hadc->Instance->SQR1,
 8001a94:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
 8001a96:	4e38      	ldr	r6, [pc, #224]	; (8001b78 <HAL_ADC_Init+0x148>)
    MODIFY_REG(hadc->Instance->SQR1,
 8001a98:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8001a9c:	432b      	orrs	r3, r5
 8001a9e:	62d3      	str	r3, [r2, #44]	; 0x2c
    if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
 8001aa0:	6893      	ldr	r3, [r2, #8]
 8001aa2:	401e      	ands	r6, r3
 8001aa4:	42b1      	cmp	r1, r6
 8001aa6:	d030      	beq.n	8001b0a <HAL_ADC_Init+0xda>
      tmp_hal_status = HAL_ERROR;
 8001aa8:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 8001aaa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001aac:	f023 0312 	bic.w	r3, r3, #18
 8001ab0:	f043 0310 	orr.w	r3, r3, #16
 8001ab4:	62a3      	str	r3, [r4, #40]	; 0x28
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001ab6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001ab8:	4303      	orrs	r3, r0
 8001aba:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 8001abc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001abe:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    tmp_hal_status = HAL_ERROR;
 8001ac0:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ac2:	f043 0310 	orr.w	r3, r3, #16
 8001ac6:	62a3      	str	r3, [r4, #40]	; 0x28
}
 8001ac8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ADC_CLEAR_ERRORCODE(hadc);
 8001aca:	62c3      	str	r3, [r0, #44]	; 0x2c
    hadc->Lock = HAL_UNLOCKED;
 8001acc:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24
    HAL_ADC_MspInit(hadc);
 8001ad0:	f7ff fb2a 	bl	8001128 <HAL_ADC_MspInit>
  tmp_hal_status = ADC_ConversionStop_Disable(hadc);
 8001ad4:	4620      	mov	r0, r4
 8001ad6:	f7ff ff89 	bl	80019ec <ADC_ConversionStop_Disable>
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 8001ada:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001adc:	f013 0310 	ands.w	r3, r3, #16
 8001ae0:	d1ed      	bne.n	8001abe <HAL_ADC_Init+0x8e>
 8001ae2:	e7b3      	b.n	8001a4c <HAL_ADC_Init+0x1c>
    return HAL_ERROR;
 8001ae4:	2001      	movs	r0, #1
}
 8001ae6:	4770      	bx	lr
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001ae8:	2e01      	cmp	r6, #1
 8001aea:	d03f      	beq.n	8001b6c <HAL_ADC_Init+0x13c>
      MODIFY_REG(hadc->Instance->CR1,
 8001aec:	6855      	ldr	r5, [r2, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8001aee:	4b21      	ldr	r3, [pc, #132]	; (8001b74 <HAL_ADC_Init+0x144>)
      MODIFY_REG(hadc->Instance->CR1,
 8001af0:	f425 4569 	bic.w	r5, r5, #59648	; 0xe900
 8001af4:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 8001af8:	6055      	str	r5, [r2, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8001afa:	6895      	ldr	r5, [r2, #8]
 8001afc:	402b      	ands	r3, r5
 8001afe:	430b      	orrs	r3, r1
 8001b00:	6093      	str	r3, [r2, #8]
      tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
 8001b02:	6923      	ldr	r3, [r4, #16]
 8001b04:	3b01      	subs	r3, #1
 8001b06:	051d      	lsls	r5, r3, #20
 8001b08:	e7c4      	b.n	8001a94 <HAL_ADC_Init+0x64>
      ADC_CLEAR_ERRORCODE(hadc);
 8001b0a:	2300      	movs	r3, #0
 8001b0c:	62e3      	str	r3, [r4, #44]	; 0x2c
      ADC_STATE_CLR_SET(hadc->State,
 8001b0e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001b10:	f023 0303 	bic.w	r3, r3, #3
 8001b14:	f043 0301 	orr.w	r3, r3, #1
 8001b18:	62a3      	str	r3, [r4, #40]	; 0x28
}
 8001b1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001b1c:	2e01      	cmp	r6, #1
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001b1e:	bf08      	it	eq
 8001b20:	f44f 7380 	moveq.w	r3, #256	; 0x100
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001b24:	d1e2      	bne.n	8001aec <HAL_ADC_Init+0xbc>
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8001b26:	b1d7      	cbz	r7, 8001b5e <HAL_ADC_Init+0x12e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001b28:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8001b2a:	f046 0620 	orr.w	r6, r6, #32
 8001b2e:	62a6      	str	r6, [r4, #40]	; 0x28
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001b30:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8001b32:	f046 0601 	orr.w	r6, r6, #1
 8001b36:	62e6      	str	r6, [r4, #44]	; 0x2c
      MODIFY_REG(hadc->Instance->CR1,
 8001b38:	6857      	ldr	r7, [r2, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8001b3a:	4e0e      	ldr	r6, [pc, #56]	; (8001b74 <HAL_ADC_Init+0x144>)
      MODIFY_REG(hadc->Instance->CR1,
 8001b3c:	f427 4769 	bic.w	r7, r7, #59648	; 0xe900
 8001b40:	433b      	orrs	r3, r7
 8001b42:	6053      	str	r3, [r2, #4]
      MODIFY_REG(hadc->Instance->CR2,
 8001b44:	6893      	ldr	r3, [r2, #8]
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
 8001b46:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
      MODIFY_REG(hadc->Instance->CR2,
 8001b4a:	ea06 0603 	and.w	r6, r6, r3
 8001b4e:	ea46 0601 	orr.w	r6, r6, r1
 8001b52:	6096      	str	r6, [r2, #8]
    if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
 8001b54:	d0d5      	beq.n	8001b02 <HAL_ADC_Init+0xd2>
 8001b56:	2d01      	cmp	r5, #1
 8001b58:	d0d3      	beq.n	8001b02 <HAL_ADC_Init+0xd2>
  uint32_t tmp_sqr1 = 0U;
 8001b5a:	2500      	movs	r5, #0
 8001b5c:	e79a      	b.n	8001a94 <HAL_ADC_Init+0x64>
        SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
 8001b5e:	69a6      	ldr	r6, [r4, #24]
 8001b60:	3e01      	subs	r6, #1
 8001b62:	ea43 3346 	orr.w	r3, r3, r6, lsl #13
 8001b66:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001b6a:	e7e5      	b.n	8001b38 <HAL_ADC_Init+0x108>
    tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
 8001b6c:	462b      	mov	r3, r5
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8001b6e:	2f00      	cmp	r7, #0
 8001b70:	d1da      	bne.n	8001b28 <HAL_ADC_Init+0xf8>
 8001b72:	e7f4      	b.n	8001b5e <HAL_ADC_Init+0x12e>
 8001b74:	ffe1f7fd 	.word	0xffe1f7fd
 8001b78:	ff1f0efe 	.word	0xff1f0efe

08001b7c <HAL_ADCEx_InjectedConvCpltCallback>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hadc);
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_ADCEx_InjectedConvCpltCallback could be implemented in the user file
  */
}
 8001b7c:	4770      	bx	lr
 8001b7e:	bf00      	nop

08001b80 <HAL_NVIC_SetPriorityGrouping>:
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001b80:	f64f 01ff 	movw	r1, #63743	; 0xf8ff
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001b84:	4a06      	ldr	r2, [pc, #24]	; (8001ba0 <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8001b86:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001b88:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 8001b8a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001b8e:	400b      	ands	r3, r1
 8001b90:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8001b94:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 8001b98:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001b9a:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001b9c:	4770      	bx	lr
 8001b9e:	bf00      	nop
 8001ba0:	e000ed00 	.word	0xe000ed00

08001ba4 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001ba4:	4b18      	ldr	r3, [pc, #96]	; (8001c08 <HAL_NVIC_SetPriority+0x64>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001ba6:	b430      	push	{r4, r5}
 8001ba8:	68db      	ldr	r3, [r3, #12]
 8001baa:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001bae:	f1c3 0507 	rsb	r5, r3, #7
 8001bb2:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bb4:	f103 0404 	add.w	r4, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001bb8:	bf28      	it	cs
 8001bba:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bbc:	2c06      	cmp	r4, #6
 8001bbe:	d919      	bls.n	8001bf4 <HAL_NVIC_SetPriority+0x50>
 8001bc0:	f04f 34ff 	mov.w	r4, #4294967295
 8001bc4:	3b03      	subs	r3, #3
 8001bc6:	409c      	lsls	r4, r3
 8001bc8:	ea22 0404 	bic.w	r4, r2, r4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001bcc:	f04f 32ff 	mov.w	r2, #4294967295
 8001bd0:	40aa      	lsls	r2, r5
 8001bd2:	ea21 0102 	bic.w	r1, r1, r2
 8001bd6:	fa01 f203 	lsl.w	r2, r1, r3
 8001bda:	4322      	orrs	r2, r4
 8001bdc:	0112      	lsls	r2, r2, #4
  if ((int32_t)(IRQn) >= 0)
 8001bde:	2800      	cmp	r0, #0
 8001be0:	b2d2      	uxtb	r2, r2
 8001be2:	db0a      	blt.n	8001bfa <HAL_NVIC_SetPriority+0x56>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001be4:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8001be8:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8001bec:	f880 2300 	strb.w	r2, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001bf0:	bc30      	pop	{r4, r5}
 8001bf2:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001bf4:	2400      	movs	r4, #0
 8001bf6:	4623      	mov	r3, r4
 8001bf8:	e7e8      	b.n	8001bcc <HAL_NVIC_SetPriority+0x28>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001bfa:	4b04      	ldr	r3, [pc, #16]	; (8001c0c <HAL_NVIC_SetPriority+0x68>)
 8001bfc:	f000 000f 	and.w	r0, r0, #15
 8001c00:	4403      	add	r3, r0
 8001c02:	761a      	strb	r2, [r3, #24]
 8001c04:	bc30      	pop	{r4, r5}
 8001c06:	4770      	bx	lr
 8001c08:	e000ed00 	.word	0xe000ed00
 8001c0c:	e000ecfc 	.word	0xe000ecfc

08001c10 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001c10:	2800      	cmp	r0, #0
 8001c12:	db07      	blt.n	8001c24 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001c14:	2301      	movs	r3, #1
 8001c16:	f000 011f 	and.w	r1, r0, #31
 8001c1a:	4a03      	ldr	r2, [pc, #12]	; (8001c28 <HAL_NVIC_EnableIRQ+0x18>)
 8001c1c:	408b      	lsls	r3, r1
 8001c1e:	0940      	lsrs	r0, r0, #5
 8001c20:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8001c24:	4770      	bx	lr
 8001c26:	bf00      	nop
 8001c28:	e000e100 	.word	0xe000e100

08001c2c <HAL_DMA_Init>:
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  uint32_t tmp = 0U;

  /* Check the DMA handle allocation */
  if(hdma == NULL)
 8001c2c:	b350      	cbz	r0, 8001c84 <HAL_DMA_Init+0x58>
 8001c2e:	4602      	mov	r2, r0
{
 8001c30:	b4f0      	push	{r4, r5, r6, r7}
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));

  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8001c32:	e9d0 3601 	ldrd	r3, r6, [r0, #4]

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;

  /* Initialise the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001c36:	2400      	movs	r4, #0

  /* Initialize the DMA state*/
  hdma->State = HAL_DMA_STATE_READY;
 8001c38:	2501      	movs	r5, #1
  tmp |=  hdma->Init.Direction        |
 8001c3a:	4333      	orrs	r3, r6
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001c3c:	68d6      	ldr	r6, [r2, #12]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c3e:	6800      	ldr	r0, [r0, #0]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001c40:	4333      	orrs	r3, r6
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c42:	4911      	ldr	r1, [pc, #68]	; (8001c88 <HAL_DMA_Init+0x5c>)
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001c44:	6916      	ldr	r6, [r2, #16]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c46:	4f11      	ldr	r7, [pc, #68]	; (8001c8c <HAL_DMA_Init+0x60>)
 8001c48:	4401      	add	r1, r0
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001c4a:	4333      	orrs	r3, r6
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c4c:	6956      	ldr	r6, [r2, #20]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c4e:	fba7 7101 	umull	r7, r1, r7, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c52:	4333      	orrs	r3, r6
 8001c54:	6996      	ldr	r6, [r2, #24]
          hdma->Init.Mode                | hdma->Init.Priority;
 8001c56:	69d7      	ldr	r7, [r2, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c58:	4333      	orrs	r3, r6
  tmp = hdma->Instance->CCR;
 8001c5a:	6806      	ldr	r6, [r0, #0]
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c5c:	0909      	lsrs	r1, r1, #4
 8001c5e:	0089      	lsls	r1, r1, #2
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8001c60:	f426 567f 	bic.w	r6, r6, #16320	; 0x3fc0
          hdma->Init.Mode                | hdma->Init.Priority;
 8001c64:	433b      	orrs	r3, r7
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8001c66:	f026 0630 	bic.w	r6, r6, #48	; 0x30
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2;
 8001c6a:	6411      	str	r1, [r2, #64]	; 0x40
  hdma->DmaBaseAddress = DMA1;
 8001c6c:	4908      	ldr	r1, [pc, #32]	; (8001c90 <HAL_DMA_Init+0x64>)
  tmp |=  hdma->Init.Direction        |
 8001c6e:	4333      	orrs	r3, r6
  hdma->DmaBaseAddress = DMA1;
 8001c70:	63d1      	str	r1, [r2, #60]	; 0x3c
  hdma->Instance->CCR = tmp;
 8001c72:	6003      	str	r3, [r0, #0]
  /* Allocate lock resource and initialize it */
  hdma->Lock = HAL_UNLOCKED;

  return HAL_OK;
 8001c74:	4620      	mov	r0, r4
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001c76:	6394      	str	r4, [r2, #56]	; 0x38
  hdma->Lock = HAL_UNLOCKED;
 8001c78:	f882 4020 	strb.w	r4, [r2, #32]
  hdma->State = HAL_DMA_STATE_READY;
 8001c7c:	f882 5021 	strb.w	r5, [r2, #33]	; 0x21
}
 8001c80:	bcf0      	pop	{r4, r5, r6, r7}
 8001c82:	4770      	bx	lr
    return HAL_ERROR;
 8001c84:	2001      	movs	r0, #1
}
 8001c86:	4770      	bx	lr
 8001c88:	bffdfff8 	.word	0xbffdfff8
 8001c8c:	cccccccd 	.word	0xcccccccd
 8001c90:	40020000 	.word	0x40020000

08001c94 <HAL_DMA_Abort_IT>:
  * @param  hdma  : pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Channel.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{  
 8001c94:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8001c96:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8001c9a:	2b02      	cmp	r3, #2
 8001c9c:	d004      	beq.n	8001ca8 <HAL_DMA_Abort_IT+0x14>
  {
    /* no transfer ongoing */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001c9e:	2204      	movs	r2, #4
        
    status = HAL_ERROR;
 8001ca0:	2401      	movs	r4, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001ca2:	6382      	str	r2, [r0, #56]	; 0x38
    {
      hdma->XferAbortCallback(hdma);
    } 
  }
  return status;
}
 8001ca4:	4620      	mov	r0, r4
 8001ca6:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001ca8:	6803      	ldr	r3, [r0, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001caa:	491d      	ldr	r1, [pc, #116]	; (8001d20 <HAL_DMA_Abort_IT+0x8c>)
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001cac:	681a      	ldr	r2, [r3, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001cae:	428b      	cmp	r3, r1
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001cb0:	f022 020e 	bic.w	r2, r2, #14
 8001cb4:	601a      	str	r2, [r3, #0]
    __HAL_DMA_DISABLE(hdma);
 8001cb6:	681a      	ldr	r2, [r3, #0]
 8001cb8:	f022 0201 	bic.w	r2, r2, #1
 8001cbc:	601a      	str	r2, [r3, #0]
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001cbe:	d021      	beq.n	8001d04 <HAL_DMA_Abort_IT+0x70>
 8001cc0:	4a18      	ldr	r2, [pc, #96]	; (8001d24 <HAL_DMA_Abort_IT+0x90>)
 8001cc2:	4293      	cmp	r3, r2
 8001cc4:	d01c      	beq.n	8001d00 <HAL_DMA_Abort_IT+0x6c>
 8001cc6:	3214      	adds	r2, #20
 8001cc8:	4293      	cmp	r3, r2
 8001cca:	d01d      	beq.n	8001d08 <HAL_DMA_Abort_IT+0x74>
 8001ccc:	3214      	adds	r2, #20
 8001cce:	4293      	cmp	r3, r2
 8001cd0:	d01d      	beq.n	8001d0e <HAL_DMA_Abort_IT+0x7a>
 8001cd2:	3214      	adds	r2, #20
 8001cd4:	4293      	cmp	r3, r2
 8001cd6:	d01d      	beq.n	8001d14 <HAL_DMA_Abort_IT+0x80>
 8001cd8:	3214      	adds	r2, #20
 8001cda:	4293      	cmp	r3, r2
 8001cdc:	bf0c      	ite	eq
 8001cde:	f44f 1380 	moveq.w	r3, #1048576	; 0x100000
 8001ce2:	f04f 7380 	movne.w	r3, #16777216	; 0x1000000
    hdma->State = HAL_DMA_STATE_READY;
 8001ce6:	2101      	movs	r1, #1
    __HAL_UNLOCK(hdma);
 8001ce8:	2400      	movs	r4, #0
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001cea:	4d0f      	ldr	r5, [pc, #60]	; (8001d28 <HAL_DMA_Abort_IT+0x94>)
    if(hdma->XferAbortCallback != NULL)
 8001cec:	6b42      	ldr	r2, [r0, #52]	; 0x34
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001cee:	606b      	str	r3, [r5, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8001cf0:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 8001cf4:	f880 4020 	strb.w	r4, [r0, #32]
    if(hdma->XferAbortCallback != NULL)
 8001cf8:	b17a      	cbz	r2, 8001d1a <HAL_DMA_Abort_IT+0x86>
      hdma->XferAbortCallback(hdma);
 8001cfa:	4790      	blx	r2
}
 8001cfc:	4620      	mov	r0, r4
 8001cfe:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_GI_FLAG_INDEX(hdma));
 8001d00:	2310      	movs	r3, #16
 8001d02:	e7f0      	b.n	8001ce6 <HAL_DMA_Abort_IT+0x52>
 8001d04:	2301      	movs	r3, #1
 8001d06:	e7ee      	b.n	8001ce6 <HAL_DMA_Abort_IT+0x52>
 8001d08:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001d0c:	e7eb      	b.n	8001ce6 <HAL_DMA_Abort_IT+0x52>
 8001d0e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001d12:	e7e8      	b.n	8001ce6 <HAL_DMA_Abort_IT+0x52>
 8001d14:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001d18:	e7e5      	b.n	8001ce6 <HAL_DMA_Abort_IT+0x52>
  HAL_StatusTypeDef status = HAL_OK;
 8001d1a:	4614      	mov	r4, r2
 8001d1c:	e7c2      	b.n	8001ca4 <HAL_DMA_Abort_IT+0x10>
 8001d1e:	bf00      	nop
 8001d20:	40020008 	.word	0x40020008
 8001d24:	4002001c 	.word	0x4002001c
 8001d28:	40020000 	.word	0x40020000

08001d2c <HAL_DMA_IRQHandler>:
{
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
  uint32_t source_it = hdma->Instance->CCR;
  
  /* Half Transfer Complete Interrupt management ******************************/
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8001d2c:	2204      	movs	r2, #4
{
 8001d2e:	b470      	push	{r4, r5, r6}
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8001d30:	e9d0 610f 	ldrd	r6, r1, [r0, #60]	; 0x3c
  uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8001d34:	6834      	ldr	r4, [r6, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8001d36:	6803      	ldr	r3, [r0, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8001d38:	408a      	lsls	r2, r1
 8001d3a:	4222      	tst	r2, r4
  uint32_t source_it = hdma->Instance->CCR;
 8001d3c:	681d      	ldr	r5, [r3, #0]
  if (((flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_HT) != RESET))
 8001d3e:	d01f      	beq.n	8001d80 <HAL_DMA_IRQHandler+0x54>
 8001d40:	076a      	lsls	r2, r5, #29
 8001d42:	d51d      	bpl.n	8001d80 <HAL_DMA_IRQHandler+0x54>
  {
    /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8001d44:	681a      	ldr	r2, [r3, #0]
 8001d46:	0691      	lsls	r1, r2, #26
 8001d48:	d403      	bmi.n	8001d52 <HAL_DMA_IRQHandler+0x26>
    {
      /* Disable the half transfer interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8001d4a:	681a      	ldr	r2, [r3, #0]
 8001d4c:	f022 0204 	bic.w	r2, r2, #4
 8001d50:	601a      	str	r2, [r3, #0]
    }
    /* Clear the half transfer complete flag */
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001d52:	4a3f      	ldr	r2, [pc, #252]	; (8001e50 <HAL_DMA_IRQHandler+0x124>)
 8001d54:	4293      	cmp	r3, r2
 8001d56:	d05c      	beq.n	8001e12 <HAL_DMA_IRQHandler+0xe6>
 8001d58:	3214      	adds	r2, #20
 8001d5a:	4293      	cmp	r3, r2
 8001d5c:	d061      	beq.n	8001e22 <HAL_DMA_IRQHandler+0xf6>
 8001d5e:	3214      	adds	r2, #20
 8001d60:	4293      	cmp	r3, r2
 8001d62:	d068      	beq.n	8001e36 <HAL_DMA_IRQHandler+0x10a>
 8001d64:	3214      	adds	r2, #20
 8001d66:	4293      	cmp	r3, r2
 8001d68:	d06b      	beq.n	8001e42 <HAL_DMA_IRQHandler+0x116>
 8001d6a:	3214      	adds	r2, #20
 8001d6c:	4293      	cmp	r3, r2
 8001d6e:	d05d      	beq.n	8001e2c <HAL_DMA_IRQHandler+0x100>
 8001d70:	3214      	adds	r2, #20
 8001d72:	4293      	cmp	r3, r2
 8001d74:	bf0c      	ite	eq
 8001d76:	f44f 0380 	moveq.w	r3, #4194304	; 0x400000
 8001d7a:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 8001d7e:	e049      	b.n	8001e14 <HAL_DMA_IRQHandler+0xe8>
      hdma->XferHalfCpltCallback(hdma);
    }
  }

  /* Transfer Complete Interrupt management ***********************************/
  else if (((flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex)) != RESET) && ((source_it & DMA_IT_TC) != RESET))
 8001d80:	2202      	movs	r2, #2
 8001d82:	408a      	lsls	r2, r1
 8001d84:	4222      	tst	r2, r4
 8001d86:	d022      	beq.n	8001dce <HAL_DMA_IRQHandler+0xa2>
 8001d88:	07aa      	lsls	r2, r5, #30
 8001d8a:	d520      	bpl.n	8001dce <HAL_DMA_IRQHandler+0xa2>
  {
    if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8001d8c:	681a      	ldr	r2, [r3, #0]
 8001d8e:	0691      	lsls	r1, r2, #26
 8001d90:	d406      	bmi.n	8001da0 <HAL_DMA_IRQHandler+0x74>
    {
      /* Disable the transfer complete and error interrupt */
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8001d92:	2101      	movs	r1, #1
      __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);  
 8001d94:	681a      	ldr	r2, [r3, #0]
 8001d96:	f022 020a 	bic.w	r2, r2, #10
 8001d9a:	601a      	str	r2, [r3, #0]
      hdma->State = HAL_DMA_STATE_READY;
 8001d9c:	f880 1021 	strb.w	r1, [r0, #33]	; 0x21
    }
    /* Clear the transfer complete flag */
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001da0:	4a2b      	ldr	r2, [pc, #172]	; (8001e50 <HAL_DMA_IRQHandler+0x124>)
 8001da2:	4293      	cmp	r3, r2
 8001da4:	d02b      	beq.n	8001dfe <HAL_DMA_IRQHandler+0xd2>
 8001da6:	3214      	adds	r2, #20
 8001da8:	4293      	cmp	r3, r2
 8001daa:	d042      	beq.n	8001e32 <HAL_DMA_IRQHandler+0x106>
 8001dac:	3214      	adds	r2, #20
 8001dae:	4293      	cmp	r3, r2
 8001db0:	d044      	beq.n	8001e3c <HAL_DMA_IRQHandler+0x110>
 8001db2:	3214      	adds	r2, #20
 8001db4:	4293      	cmp	r3, r2
 8001db6:	d036      	beq.n	8001e26 <HAL_DMA_IRQHandler+0xfa>
 8001db8:	3214      	adds	r2, #20
 8001dba:	4293      	cmp	r3, r2
 8001dbc:	d044      	beq.n	8001e48 <HAL_DMA_IRQHandler+0x11c>
 8001dbe:	3214      	adds	r2, #20
 8001dc0:	4293      	cmp	r3, r2
 8001dc2:	bf0c      	ite	eq
 8001dc4:	f44f 1300 	moveq.w	r3, #2097152	; 0x200000
 8001dc8:	f04f 7300 	movne.w	r3, #33554432	; 0x2000000
 8001dcc:	e018      	b.n	8001e00 <HAL_DMA_IRQHandler+0xd4>
      hdma->XferCpltCallback(hdma);
    }
  }

  /* Transfer Error Interrupt management **************************************/
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8001dce:	2208      	movs	r2, #8
 8001dd0:	408a      	lsls	r2, r1
 8001dd2:	4222      	tst	r2, r4
 8001dd4:	d01b      	beq.n	8001e0e <HAL_DMA_IRQHandler+0xe2>
 8001dd6:	072a      	lsls	r2, r5, #28
 8001dd8:	d519      	bpl.n	8001e0e <HAL_DMA_IRQHandler+0xe2>
    /* A hardware clear of its EN bits is performed */
    /* Disable ALL DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8001dda:	2201      	movs	r2, #1

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 8001ddc:	2500      	movs	r5, #0
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001dde:	681c      	ldr	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8001de0:	fa02 f101 	lsl.w	r1, r2, r1
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8001de4:	f024 040e 	bic.w	r4, r4, #14
 8001de8:	601c      	str	r4, [r3, #0]

    if (hdma->XferErrorCallback != NULL)
 8001dea:	6b03      	ldr	r3, [r0, #48]	; 0x30
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << hdma->ChannelIndex);
 8001dec:	6071      	str	r1, [r6, #4]
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8001dee:	6382      	str	r2, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;
 8001df0:	f880 2021 	strb.w	r2, [r0, #33]	; 0x21
    __HAL_UNLOCK(hdma);
 8001df4:	f880 5020 	strb.w	r5, [r0, #32]
    if (hdma->XferErrorCallback != NULL)
 8001df8:	b14b      	cbz	r3, 8001e0e <HAL_DMA_IRQHandler+0xe2>
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
    }
  }
  return;
}
 8001dfa:	bc70      	pop	{r4, r5, r6}
      hdma->XferErrorCallback(hdma);
 8001dfc:	4718      	bx	r3
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001dfe:	2302      	movs	r3, #2
    __HAL_UNLOCK(hdma);
 8001e00:	2100      	movs	r1, #0
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e02:	4c14      	ldr	r4, [pc, #80]	; (8001e54 <HAL_DMA_IRQHandler+0x128>)
    if(hdma->XferCpltCallback != NULL)
 8001e04:	6a82      	ldr	r2, [r0, #40]	; 0x28
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e06:	6063      	str	r3, [r4, #4]
    __HAL_UNLOCK(hdma);
 8001e08:	f880 1020 	strb.w	r1, [r0, #32]
    if(hdma->XferCpltCallback != NULL)
 8001e0c:	b93a      	cbnz	r2, 8001e1e <HAL_DMA_IRQHandler+0xf2>
}
 8001e0e:	bc70      	pop	{r4, r5, r6}
 8001e10:	4770      	bx	lr
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e12:	2304      	movs	r3, #4
 8001e14:	490f      	ldr	r1, [pc, #60]	; (8001e54 <HAL_DMA_IRQHandler+0x128>)
    if(hdma->XferHalfCpltCallback != NULL)
 8001e16:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e18:	604b      	str	r3, [r1, #4]
    if(hdma->XferHalfCpltCallback != NULL)
 8001e1a:	2a00      	cmp	r2, #0
 8001e1c:	d0f7      	beq.n	8001e0e <HAL_DMA_IRQHandler+0xe2>
}
 8001e1e:	bc70      	pop	{r4, r5, r6}
      hdma->XferCpltCallback(hdma);
 8001e20:	4710      	bx	r2
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e22:	2340      	movs	r3, #64	; 0x40
 8001e24:	e7f6      	b.n	8001e14 <HAL_DMA_IRQHandler+0xe8>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e26:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001e2a:	e7e9      	b.n	8001e00 <HAL_DMA_IRQHandler+0xd4>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e2c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 8001e30:	e7f0      	b.n	8001e14 <HAL_DMA_IRQHandler+0xe8>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e32:	2320      	movs	r3, #32
 8001e34:	e7e4      	b.n	8001e00 <HAL_DMA_IRQHandler+0xd4>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e36:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8001e3a:	e7eb      	b.n	8001e14 <HAL_DMA_IRQHandler+0xe8>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e3c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001e40:	e7de      	b.n	8001e00 <HAL_DMA_IRQHandler+0xd4>
    __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_HT_FLAG_INDEX(hdma));
 8001e42:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8001e46:	e7e5      	b.n	8001e14 <HAL_DMA_IRQHandler+0xe8>
      __HAL_DMA_CLEAR_FLAG(hdma, __HAL_DMA_GET_TC_FLAG_INDEX(hdma));
 8001e48:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001e4c:	e7d8      	b.n	8001e00 <HAL_DMA_IRQHandler+0xd4>
 8001e4e:	bf00      	nop
 8001e50:	40020008 	.word	0x40020008
 8001e54:	40020000 	.word	0x40020000

08001e58 <HAL_GPIO_Init>:
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001e58:	680a      	ldr	r2, [r1, #0]
 8001e5a:	2a00      	cmp	r2, #0
 8001e5c:	f000 80d9 	beq.w	8002012 <HAL_GPIO_Init+0x1ba>
{
 8001e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t config = 0x00u;
 8001e64:	f04f 0a00 	mov.w	sl, #0
{
 8001e68:	b085      	sub	sp, #20
  uint32_t position = 0x00u;
 8001e6a:	4655      	mov	r5, sl
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001e6c:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 8002024 <HAL_GPIO_Init+0x1cc>
        temp = AFIO->EXTICR[position >> 2u];
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001e70:	f8df e1b4 	ldr.w	lr, [pc, #436]	; 8002028 <HAL_GPIO_Init+0x1d0>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8001e74:	4f67      	ldr	r7, [pc, #412]	; (8002014 <HAL_GPIO_Init+0x1bc>)
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001e76:	f8df 81b4 	ldr.w	r8, [pc, #436]	; 800202c <HAL_GPIO_Init+0x1d4>
 8001e7a:	e003      	b.n	8001e84 <HAL_GPIO_Init+0x2c>
        }
      }
    }

	position++;
 8001e7c:	3501      	adds	r5, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001e7e:	fa32 f305 	lsrs.w	r3, r2, r5
 8001e82:	d076      	beq.n	8001f72 <HAL_GPIO_Init+0x11a>
    ioposition = (0x01uL << position);
 8001e84:	2301      	movs	r3, #1
 8001e86:	40ab      	lsls	r3, r5
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001e88:	ea02 0403 	and.w	r4, r2, r3
    if (iocurrent == ioposition)
 8001e8c:	42a3      	cmp	r3, r4
 8001e8e:	d1f5      	bne.n	8001e7c <HAL_GPIO_Init+0x24>
      switch (GPIO_Init->Mode)
 8001e90:	684a      	ldr	r2, [r1, #4]
 8001e92:	2a12      	cmp	r2, #18
 8001e94:	f000 809c 	beq.w	8001fd0 <HAL_GPIO_Init+0x178>
 8001e98:	f200 8085 	bhi.w	8001fa6 <HAL_GPIO_Init+0x14e>
 8001e9c:	2a02      	cmp	r2, #2
 8001e9e:	f000 809b 	beq.w	8001fd8 <HAL_GPIO_Init+0x180>
 8001ea2:	d97a      	bls.n	8001f9a <HAL_GPIO_Init+0x142>
 8001ea4:	2a03      	cmp	r2, #3
 8001ea6:	d067      	beq.n	8001f78 <HAL_GPIO_Init+0x120>
 8001ea8:	2a11      	cmp	r2, #17
 8001eaa:	d102      	bne.n	8001eb2 <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8001eac:	68cb      	ldr	r3, [r1, #12]
 8001eae:	f103 0a04 	add.w	sl, r3, #4
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001eb2:	2cff      	cmp	r4, #255	; 0xff
 8001eb4:	d864      	bhi.n	8001f80 <HAL_GPIO_Init+0x128>
 8001eb6:	4681      	mov	r9, r0
 8001eb8:	6803      	ldr	r3, [r0, #0]
 8001eba:	00aa      	lsls	r2, r5, #2
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8001ebc:	260f      	movs	r6, #15
 8001ebe:	fa06 fb02 	lsl.w	fp, r6, r2
 8001ec2:	ea23 030b 	bic.w	r3, r3, fp
 8001ec6:	fa0a f202 	lsl.w	r2, sl, r2
 8001eca:	4313      	orrs	r3, r2
 8001ecc:	f8c9 3000 	str.w	r3, [r9]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001ed0:	684a      	ldr	r2, [r1, #4]
 8001ed2:	00d3      	lsls	r3, r2, #3
 8001ed4:	d55f      	bpl.n	8001f96 <HAL_GPIO_Init+0x13e>
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001ed6:	f8dc 9018 	ldr.w	r9, [ip, #24]
 8001eda:	f025 0303 	bic.w	r3, r5, #3
 8001ede:	f049 0901 	orr.w	r9, r9, #1
 8001ee2:	f8cc 9018 	str.w	r9, [ip, #24]
 8001ee6:	f8dc 9018 	ldr.w	r9, [ip, #24]
 8001eea:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8001eee:	f009 0901 	and.w	r9, r9, #1
 8001ef2:	f8cd 900c 	str.w	r9, [sp, #12]
 8001ef6:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001efa:	f005 0903 	and.w	r9, r5, #3
        __HAL_RCC_AFIO_CLK_ENABLE();
 8001efe:	f8dd b00c 	ldr.w	fp, [sp, #12]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001f02:	ea4f 0989 	mov.w	r9, r9, lsl #2
        temp = AFIO->EXTICR[position >> 2u];
 8001f06:	f8d3 b008 	ldr.w	fp, [r3, #8]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001f0a:	fa06 f609 	lsl.w	r6, r6, r9
 8001f0e:	ea2b 0606 	bic.w	r6, fp, r6
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001f12:	4570      	cmp	r0, lr
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8001f14:	9601      	str	r6, [sp, #4]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8001f16:	d00e      	beq.n	8001f36 <HAL_GPIO_Init+0xde>
 8001f18:	4540      	cmp	r0, r8
 8001f1a:	d061      	beq.n	8001fe0 <HAL_GPIO_Init+0x188>
 8001f1c:	4e3e      	ldr	r6, [pc, #248]	; (8002018 <HAL_GPIO_Init+0x1c0>)
 8001f1e:	42b0      	cmp	r0, r6
 8001f20:	bf0c      	ite	eq
 8001f22:	f04f 0b02 	moveq.w	fp, #2
 8001f26:	f04f 0b03 	movne.w	fp, #3
 8001f2a:	9e01      	ldr	r6, [sp, #4]
 8001f2c:	fa0b f909 	lsl.w	r9, fp, r9
 8001f30:	ea46 0609 	orr.w	r6, r6, r9
 8001f34:	9601      	str	r6, [sp, #4]
        AFIO->EXTICR[position >> 2u] = temp;
 8001f36:	9e01      	ldr	r6, [sp, #4]
 8001f38:	609e      	str	r6, [r3, #8]
          SET_BIT(EXTI->IMR, iocurrent);
 8001f3a:	683b      	ldr	r3, [r7, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001f3c:	03d6      	lsls	r6, r2, #15
          SET_BIT(EXTI->IMR, iocurrent);
 8001f3e:	bf4c      	ite	mi
 8001f40:	4323      	orrmi	r3, r4
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8001f42:	43a3      	bicpl	r3, r4
 8001f44:	603b      	str	r3, [r7, #0]
          SET_BIT(EXTI->EMR, iocurrent);
 8001f46:	687b      	ldr	r3, [r7, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001f48:	0396      	lsls	r6, r2, #14
          SET_BIT(EXTI->EMR, iocurrent);
 8001f4a:	bf4c      	ite	mi
 8001f4c:	4323      	orrmi	r3, r4
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8001f4e:	43a3      	bicpl	r3, r4
 8001f50:	607b      	str	r3, [r7, #4]
          SET_BIT(EXTI->RTSR, iocurrent);
 8001f52:	68bb      	ldr	r3, [r7, #8]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001f54:	02d6      	lsls	r6, r2, #11
          SET_BIT(EXTI->RTSR, iocurrent);
 8001f56:	bf4c      	ite	mi
 8001f58:	4323      	orrmi	r3, r4
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 8001f5a:	43a3      	bicpl	r3, r4
 8001f5c:	60bb      	str	r3, [r7, #8]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001f5e:	0292      	lsls	r2, r2, #10
          SET_BIT(EXTI->FTSR, iocurrent);
 8001f60:	68fb      	ldr	r3, [r7, #12]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001f62:	d515      	bpl.n	8001f90 <HAL_GPIO_Init+0x138>
          SET_BIT(EXTI->FTSR, iocurrent);
 8001f64:	431c      	orrs	r4, r3
 8001f66:	60fc      	str	r4, [r7, #12]
 8001f68:	680a      	ldr	r2, [r1, #0]
	position++;
 8001f6a:	3501      	adds	r5, #1
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001f6c:	fa32 f305 	lsrs.w	r3, r2, r5
 8001f70:	d188      	bne.n	8001e84 <HAL_GPIO_Init+0x2c>
  }
}
 8001f72:	b005      	add	sp, #20
 8001f74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001f78:	2cff      	cmp	r4, #255	; 0xff
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8001f7a:	f04f 0a00 	mov.w	sl, #0
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8001f7e:	d99a      	bls.n	8001eb6 <HAL_GPIO_Init+0x5e>
 8001f80:	f105 4280 	add.w	r2, r5, #1073741824	; 0x40000000
 8001f84:	3a08      	subs	r2, #8
 8001f86:	6843      	ldr	r3, [r0, #4]
 8001f88:	0092      	lsls	r2, r2, #2
 8001f8a:	f100 0904 	add.w	r9, r0, #4
 8001f8e:	e795      	b.n	8001ebc <HAL_GPIO_Init+0x64>
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8001f90:	ea23 0404 	bic.w	r4, r3, r4
 8001f94:	60fc      	str	r4, [r7, #12]
 8001f96:	680a      	ldr	r2, [r1, #0]
 8001f98:	e770      	b.n	8001e7c <HAL_GPIO_Init+0x24>
      switch (GPIO_Init->Mode)
 8001f9a:	b1a2      	cbz	r2, 8001fc6 <HAL_GPIO_Init+0x16e>
 8001f9c:	2a01      	cmp	r2, #1
 8001f9e:	d188      	bne.n	8001eb2 <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8001fa0:	f8d1 a00c 	ldr.w	sl, [r1, #12]
          break;
 8001fa4:	e785      	b.n	8001eb2 <HAL_GPIO_Init+0x5a>
      switch (GPIO_Init->Mode)
 8001fa6:	4e1d      	ldr	r6, [pc, #116]	; (800201c <HAL_GPIO_Init+0x1c4>)
 8001fa8:	42b2      	cmp	r2, r6
 8001faa:	d00c      	beq.n	8001fc6 <HAL_GPIO_Init+0x16e>
 8001fac:	d920      	bls.n	8001ff0 <HAL_GPIO_Init+0x198>
 8001fae:	4e1c      	ldr	r6, [pc, #112]	; (8002020 <HAL_GPIO_Init+0x1c8>)
 8001fb0:	42b2      	cmp	r2, r6
 8001fb2:	d008      	beq.n	8001fc6 <HAL_GPIO_Init+0x16e>
 8001fb4:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 8001fb8:	42b2      	cmp	r2, r6
 8001fba:	d004      	beq.n	8001fc6 <HAL_GPIO_Init+0x16e>
 8001fbc:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 8001fc0:	42b2      	cmp	r2, r6
 8001fc2:	f47f af76 	bne.w	8001eb2 <HAL_GPIO_Init+0x5a>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8001fc6:	688a      	ldr	r2, [r1, #8]
 8001fc8:	b9e2      	cbnz	r2, 8002004 <HAL_GPIO_Init+0x1ac>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8001fca:	f04f 0a04 	mov.w	sl, #4
 8001fce:	e770      	b.n	8001eb2 <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8001fd0:	68cb      	ldr	r3, [r1, #12]
 8001fd2:	f103 0a0c 	add.w	sl, r3, #12
          break;
 8001fd6:	e76c      	b.n	8001eb2 <HAL_GPIO_Init+0x5a>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8001fd8:	68cb      	ldr	r3, [r1, #12]
 8001fda:	f103 0a08 	add.w	sl, r3, #8
          break;
 8001fde:	e768      	b.n	8001eb2 <HAL_GPIO_Init+0x5a>
 8001fe0:	f04f 0b01 	mov.w	fp, #1
 8001fe4:	fa0b f909 	lsl.w	r9, fp, r9
 8001fe8:	ea46 0609 	orr.w	r6, r6, r9
 8001fec:	9601      	str	r6, [sp, #4]
 8001fee:	e7a2      	b.n	8001f36 <HAL_GPIO_Init+0xde>
      switch (GPIO_Init->Mode)
 8001ff0:	f5a6 1680 	sub.w	r6, r6, #1048576	; 0x100000
 8001ff4:	42b2      	cmp	r2, r6
 8001ff6:	d0e6      	beq.n	8001fc6 <HAL_GPIO_Init+0x16e>
 8001ff8:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
 8001ffc:	42b2      	cmp	r2, r6
 8001ffe:	f47f af58 	bne.w	8001eb2 <HAL_GPIO_Init+0x5a>
 8002002:	e7e0      	b.n	8001fc6 <HAL_GPIO_Init+0x16e>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8002004:	2a01      	cmp	r2, #1
            GPIOx->BSRR = ioposition;
 8002006:	bf0c      	ite	eq
 8002008:	6103      	streq	r3, [r0, #16]
            GPIOx->BRR = ioposition;
 800200a:	6143      	strne	r3, [r0, #20]
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 800200c:	f04f 0a08 	mov.w	sl, #8
 8002010:	e74f      	b.n	8001eb2 <HAL_GPIO_Init+0x5a>
 8002012:	4770      	bx	lr
 8002014:	40010400 	.word	0x40010400
 8002018:	40011000 	.word	0x40011000
 800201c:	10210000 	.word	0x10210000
 8002020:	10310000 	.word	0x10310000
 8002024:	40021000 	.word	0x40021000
 8002028:	40010800 	.word	0x40010800
 800202c:	40010c00 	.word	0x40010c00

08002030 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8002030:	6883      	ldr	r3, [r0, #8]
 8002032:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8002034:	bf14      	ite	ne
 8002036:	2001      	movne	r0, #1
 8002038:	2000      	moveq	r0, #0
 800203a:	4770      	bx	lr

0800203c <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 800203c:	b902      	cbnz	r2, 8002040 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 800203e:	0409      	lsls	r1, r1, #16
 8002040:	6101      	str	r1, [r0, #16]
  }
}
 8002042:	4770      	bx	lr

08002044 <HAL_GPIO_TogglePin>:

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Ouput Data Register value */
  odr = GPIOx->ODR;
 8002044:	68c3      	ldr	r3, [r0, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8002046:	ea01 0203 	and.w	r2, r1, r3
 800204a:	ea21 0103 	bic.w	r1, r1, r3
 800204e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8002052:	6101      	str	r1, [r0, #16]
}
 8002054:	4770      	bx	lr
 8002056:	bf00      	nop

08002058 <HAL_I2C_Init>:
{
  uint32_t freqrange;
  uint32_t pclk1;

  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8002058:	2800      	cmp	r0, #0
 800205a:	f000 809f 	beq.w	800219c <HAL_I2C_Init+0x144>
{
 800205e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8002060:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002064:	4604      	mov	r4, r0
 8002066:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800206a:	2b00      	cmp	r3, #0
 800206c:	f000 808f 	beq.w	800218e <HAL_I2C_Init+0x136>
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002070:	2224      	movs	r2, #36	; 0x24

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8002072:	6823      	ldr	r3, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8002074:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_I2C_DISABLE(hi2c);
 8002078:	681a      	ldr	r2, [r3, #0]
 800207a:	f022 0201 	bic.w	r2, r2, #1
 800207e:	601a      	str	r2, [r3, #0]

  /*Reset I2C*/
  hi2c->Instance->CR1 |= I2C_CR1_SWRST;
 8002080:	681a      	ldr	r2, [r3, #0]
 8002082:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002086:	601a      	str	r2, [r3, #0]
  hi2c->Instance->CR1 &= ~I2C_CR1_SWRST;
 8002088:	681a      	ldr	r2, [r3, #0]
 800208a:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800208e:	601a      	str	r2, [r3, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 8002090:	f000 fb70 	bl	8002774 <HAL_RCC_GetPCLK1Freq>

  /* Check the minimum allowed PCLK1 frequency */
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8002094:	6862      	ldr	r2, [r4, #4]
 8002096:	4b4b      	ldr	r3, [pc, #300]	; (80021c4 <HAL_I2C_Init+0x16c>)
 8002098:	429a      	cmp	r2, r3
 800209a:	d84b      	bhi.n	8002134 <HAL_I2C_Init+0xdc>
 800209c:	4b4a      	ldr	r3, [pc, #296]	; (80021c8 <HAL_I2C_Init+0x170>)
 800209e:	4298      	cmp	r0, r3
 80020a0:	d97a      	bls.n	8002198 <HAL_I2C_Init+0x140>
  /* Configure I2Cx: Rise Time */
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80020a2:	1e43      	subs	r3, r0, #1
 80020a4:	0052      	lsls	r2, r2, #1
 80020a6:	fbb3 f2f2 	udiv	r2, r3, r2
  freqrange = I2C_FREQRANGE(pclk1);
 80020aa:	4948      	ldr	r1, [pc, #288]	; (80021cc <HAL_I2C_Init+0x174>)
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80020ac:	6823      	ldr	r3, [r4, #0]
  freqrange = I2C_FREQRANGE(pclk1);
 80020ae:	fba1 1000 	umull	r1, r0, r1, r0
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80020b2:	6859      	ldr	r1, [r3, #4]
  freqrange = I2C_FREQRANGE(pclk1);
 80020b4:	0c80      	lsrs	r0, r0, #18
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 80020b6:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80020ba:	4301      	orrs	r1, r0
 80020bc:	6059      	str	r1, [r3, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 80020be:	6a19      	ldr	r1, [r3, #32]
 80020c0:	3001      	adds	r0, #1
 80020c2:	f021 013f 	bic.w	r1, r1, #63	; 0x3f
 80020c6:	4308      	orrs	r0, r1
 80020c8:	6218      	str	r0, [r3, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80020ca:	1c50      	adds	r0, r2, #1
 80020cc:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80020d0:	2804      	cmp	r0, #4
 80020d2:	bf38      	it	cc
 80020d4:	2004      	movcc	r0, #4
 80020d6:	69d9      	ldr	r1, [r3, #28]
 80020d8:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 80020dc:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80020e0:	2500      	movs	r5, #0
  hi2c->State = HAL_I2C_STATE_READY;
 80020e2:	2620      	movs	r6, #32
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80020e4:	4308      	orrs	r0, r1
 80020e6:	61d8      	str	r0, [r3, #28]
  MODIFY_REG(hi2c->Instance->CR1, (I2C_CR1_ENGC | I2C_CR1_NOSTRETCH), (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode));
 80020e8:	6819      	ldr	r1, [r3, #0]
 80020ea:	e9d4 2007 	ldrd	r2, r0, [r4, #28]
 80020ee:	f021 01c0 	bic.w	r1, r1, #192	; 0xc0
 80020f2:	4302      	orrs	r2, r0
 80020f4:	430a      	orrs	r2, r1
 80020f6:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hi2c->Instance->OAR1, (I2C_OAR1_ADDMODE | I2C_OAR1_ADD8_9 | I2C_OAR1_ADD1_7 | I2C_OAR1_ADD0), (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1));
 80020f8:	6899      	ldr	r1, [r3, #8]
 80020fa:	e9d4 0203 	ldrd	r0, r2, [r4, #12]
 80020fe:	f421 4103 	bic.w	r1, r1, #33536	; 0x8300
 8002102:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8002106:	4302      	orrs	r2, r0
 8002108:	430a      	orrs	r2, r1
 800210a:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hi2c->Instance->OAR2, (I2C_OAR2_ENDUAL | I2C_OAR2_ADD2), (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2));
 800210c:	68d9      	ldr	r1, [r3, #12]
 800210e:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
 8002112:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8002116:	4302      	orrs	r2, r0
 8002118:	430a      	orrs	r2, r1
 800211a:	60da      	str	r2, [r3, #12]
  __HAL_I2C_ENABLE(hi2c);
 800211c:	681a      	ldr	r2, [r3, #0]
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  return HAL_OK;
 800211e:	4628      	mov	r0, r5
  __HAL_I2C_ENABLE(hi2c);
 8002120:	f042 0201 	orr.w	r2, r2, #1
 8002124:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002126:	6425      	str	r5, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 8002128:	f884 603d 	strb.w	r6, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800212c:	6325      	str	r5, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800212e:	f884 503e 	strb.w	r5, [r4, #62]	; 0x3e
}
 8002132:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (I2C_MIN_PCLK_FREQ(pclk1, hi2c->Init.ClockSpeed) == 1U)
 8002134:	4b26      	ldr	r3, [pc, #152]	; (80021d0 <HAL_I2C_Init+0x178>)
 8002136:	4298      	cmp	r0, r3
 8002138:	d92e      	bls.n	8002198 <HAL_I2C_Init+0x140>
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800213a:	f44f 7196 	mov.w	r1, #300	; 0x12c
  freqrange = I2C_FREQRANGE(pclk1);
 800213e:	4d23      	ldr	r5, [pc, #140]	; (80021cc <HAL_I2C_Init+0x174>)
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 8002140:	6823      	ldr	r3, [r4, #0]
  freqrange = I2C_FREQRANGE(pclk1);
 8002142:	fba5 6500 	umull	r6, r5, r5, r0
 8002146:	0cad      	lsrs	r5, r5, #18
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8002148:	fb01 f105 	mul.w	r1, r1, r5
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 800214c:	685e      	ldr	r6, [r3, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800214e:	4f21      	ldr	r7, [pc, #132]	; (80021d4 <HAL_I2C_Init+0x17c>)
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 8002150:	f026 063f 	bic.w	r6, r6, #63	; 0x3f
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 8002154:	fba7 7101 	umull	r7, r1, r7, r1
  MODIFY_REG(hi2c->Instance->CR2, I2C_CR2_FREQ, freqrange);
 8002158:	4335      	orrs	r5, r6
 800215a:	605d      	str	r5, [r3, #4]
  MODIFY_REG(hi2c->Instance->TRISE, I2C_TRISE_TRISE, I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed));
 800215c:	6a1d      	ldr	r5, [r3, #32]
 800215e:	0989      	lsrs	r1, r1, #6
 8002160:	f025 053f 	bic.w	r5, r5, #63	; 0x3f
 8002164:	3101      	adds	r1, #1
 8002166:	4329      	orrs	r1, r5
 8002168:	6219      	str	r1, [r3, #32]
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 800216a:	69d9      	ldr	r1, [r3, #28]
 800216c:	68a5      	ldr	r5, [r4, #8]
 800216e:	f421 414f 	bic.w	r1, r1, #52992	; 0xcf00
 8002172:	3801      	subs	r0, #1
 8002174:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 8002178:	b995      	cbnz	r5, 80021a0 <HAL_I2C_Init+0x148>
 800217a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800217e:	fbb0 f0f2 	udiv	r0, r0, r2
 8002182:	3001      	adds	r0, #1
 8002184:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8002188:	b9c0      	cbnz	r0, 80021bc <HAL_I2C_Init+0x164>
 800218a:	2001      	movs	r0, #1
 800218c:	e7a8      	b.n	80020e0 <HAL_I2C_Init+0x88>
    hi2c->Lock = HAL_UNLOCKED;
 800218e:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_I2C_MspInit(hi2c);
 8002192:	f7ff f801 	bl	8001198 <HAL_I2C_MspInit>
 8002196:	e76b      	b.n	8002070 <HAL_I2C_Init+0x18>
    return HAL_ERROR;
 8002198:	2001      	movs	r0, #1
}
 800219a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800219c:	2001      	movs	r0, #1
}
 800219e:	4770      	bx	lr
  MODIFY_REG(hi2c->Instance->CCR, (I2C_CCR_FS | I2C_CCR_DUTY | I2C_CCR_CCR), I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle));
 80021a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80021a4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 80021a8:	fbb0 f0f2 	udiv	r0, r0, r2
 80021ac:	3001      	adds	r0, #1
 80021ae:	f3c0 000b 	ubfx	r0, r0, #0, #12
 80021b2:	2800      	cmp	r0, #0
 80021b4:	d0e9      	beq.n	800218a <HAL_I2C_Init+0x132>
 80021b6:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 80021ba:	e791      	b.n	80020e0 <HAL_I2C_Init+0x88>
 80021bc:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 80021c0:	e78e      	b.n	80020e0 <HAL_I2C_Init+0x88>
 80021c2:	bf00      	nop
 80021c4:	000186a0 	.word	0x000186a0
 80021c8:	001e847f 	.word	0x001e847f
 80021cc:	431bde83 	.word	0x431bde83
 80021d0:	003d08ff 	.word	0x003d08ff
 80021d4:	10624dd3 	.word	0x10624dd3

080021d8 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t pll_config;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80021d8:	2800      	cmp	r0, #0
 80021da:	f000 8155 	beq.w	8002488 <HAL_RCC_OscConfig+0x2b0>
{
 80021de:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80021e2:	6803      	ldr	r3, [r0, #0]
{
 80021e4:	b082      	sub	sp, #8
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80021e6:	07dd      	lsls	r5, r3, #31
 80021e8:	4604      	mov	r4, r0
 80021ea:	d535      	bpl.n	8002258 <HAL_RCC_OscConfig+0x80>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80021ec:	49a8      	ldr	r1, [pc, #672]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 80021ee:	684a      	ldr	r2, [r1, #4]
 80021f0:	f002 020c 	and.w	r2, r2, #12
 80021f4:	2a04      	cmp	r2, #4
 80021f6:	f000 8105 	beq.w	8002404 <HAL_RCC_OscConfig+0x22c>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80021fa:	684a      	ldr	r2, [r1, #4]
 80021fc:	f002 020c 	and.w	r2, r2, #12
 8002200:	2a08      	cmp	r2, #8
 8002202:	f000 80fb 	beq.w	80023fc <HAL_RCC_OscConfig+0x224>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002206:	6863      	ldr	r3, [r4, #4]
 8002208:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800220c:	d010      	beq.n	8002230 <HAL_RCC_OscConfig+0x58>
 800220e:	2b00      	cmp	r3, #0
 8002210:	f000 8120 	beq.w	8002454 <HAL_RCC_OscConfig+0x27c>
 8002214:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002218:	f000 8178 	beq.w	800250c <HAL_RCC_OscConfig+0x334>
 800221c:	4b9c      	ldr	r3, [pc, #624]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 800221e:	681a      	ldr	r2, [r3, #0]
 8002220:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002224:	601a      	str	r2, [r3, #0]
 8002226:	681a      	ldr	r2, [r3, #0]
 8002228:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800222c:	601a      	str	r2, [r3, #0]
 800222e:	e004      	b.n	800223a <HAL_RCC_OscConfig+0x62>
 8002230:	4a97      	ldr	r2, [pc, #604]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 8002232:	6813      	ldr	r3, [r2, #0]
 8002234:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002238:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
      {
        /* Get Start Tick */
        tickstart = HAL_GetTick();
 800223a:	f7ff f961 	bl	8001500 <HAL_GetTick>

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800223e:	4d94      	ldr	r5, [pc, #592]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
        tickstart = HAL_GetTick();
 8002240:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002242:	e005      	b.n	8002250 <HAL_RCC_OscConfig+0x78>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002244:	f7ff f95c 	bl	8001500 <HAL_GetTick>
 8002248:	1b80      	subs	r0, r0, r6
 800224a:	2864      	cmp	r0, #100	; 0x64
 800224c:	f200 80f5 	bhi.w	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002250:	682b      	ldr	r3, [r5, #0]
 8002252:	039a      	lsls	r2, r3, #14
 8002254:	d5f6      	bpl.n	8002244 <HAL_RCC_OscConfig+0x6c>
 8002256:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002258:	079f      	lsls	r7, r3, #30
 800225a:	d44d      	bmi.n	80022f8 <HAL_RCC_OscConfig+0x120>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 800225c:	071a      	lsls	r2, r3, #28
 800225e:	d522      	bpl.n	80022a6 <HAL_RCC_OscConfig+0xce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002260:	69a3      	ldr	r3, [r4, #24]
 8002262:	2b00      	cmp	r3, #0
 8002264:	f000 80ba 	beq.w	80023dc <HAL_RCC_OscConfig+0x204>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002268:	2201      	movs	r2, #1
 800226a:	4b8a      	ldr	r3, [pc, #552]	; (8002494 <HAL_RCC_OscConfig+0x2bc>)

      /* Get Start Tick */
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800226c:	4d88      	ldr	r5, [pc, #544]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
      __HAL_RCC_LSI_ENABLE();
 800226e:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002270:	f7ff f946 	bl	8001500 <HAL_GetTick>
 8002274:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002276:	e005      	b.n	8002284 <HAL_RCC_OscConfig+0xac>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002278:	f7ff f942 	bl	8001500 <HAL_GetTick>
 800227c:	1b80      	subs	r0, r0, r6
 800227e:	2802      	cmp	r0, #2
 8002280:	f200 80db 	bhi.w	800243a <HAL_RCC_OscConfig+0x262>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002284:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002286:	079b      	lsls	r3, r3, #30
 8002288:	d5f6      	bpl.n	8002278 <HAL_RCC_OscConfig+0xa0>
  * @param  mdelay: specifies the delay time length, in milliseconds.
  * @retval None
  */
static void RCC_Delay(uint32_t mdelay)
{
  __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
 800228a:	4b83      	ldr	r3, [pc, #524]	; (8002498 <HAL_RCC_OscConfig+0x2c0>)
 800228c:	4a83      	ldr	r2, [pc, #524]	; (800249c <HAL_RCC_OscConfig+0x2c4>)
 800228e:	681b      	ldr	r3, [r3, #0]
 8002290:	fba2 2303 	umull	r2, r3, r2, r3
 8002294:	0a5b      	lsrs	r3, r3, #9
 8002296:	9301      	str	r3, [sp, #4]
  do
  {
    __NOP();
 8002298:	bf00      	nop
  }
  while (Delay --);
 800229a:	9b01      	ldr	r3, [sp, #4]
 800229c:	1e5a      	subs	r2, r3, #1
 800229e:	9201      	str	r2, [sp, #4]
 80022a0:	2b00      	cmp	r3, #0
 80022a2:	d1f9      	bne.n	8002298 <HAL_RCC_OscConfig+0xc0>
 80022a4:	6823      	ldr	r3, [r4, #0]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80022a6:	075d      	lsls	r5, r3, #29
 80022a8:	d569      	bpl.n	800237e <HAL_RCC_OscConfig+0x1a6>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 80022aa:	4b79      	ldr	r3, [pc, #484]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 80022ac:	69da      	ldr	r2, [r3, #28]
 80022ae:	00d0      	lsls	r0, r2, #3
 80022b0:	f100 80ec 	bmi.w	800248c <HAL_RCC_OscConfig+0x2b4>
      pwrclkchanged = SET;
 80022b4:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 80022b6:	69da      	ldr	r2, [r3, #28]
 80022b8:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80022bc:	61da      	str	r2, [r3, #28]
 80022be:	69db      	ldr	r3, [r3, #28]
 80022c0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80022c4:	9300      	str	r3, [sp, #0]
 80022c6:	9b00      	ldr	r3, [sp, #0]
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80022c8:	4b75      	ldr	r3, [pc, #468]	; (80024a0 <HAL_RCC_OscConfig+0x2c8>)
 80022ca:	681a      	ldr	r2, [r3, #0]
 80022cc:	05d1      	lsls	r1, r2, #23
 80022ce:	f140 80a3 	bpl.w	8002418 <HAL_RCC_OscConfig+0x240>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80022d2:	68e3      	ldr	r3, [r4, #12]
 80022d4:	2b01      	cmp	r3, #1
 80022d6:	d037      	beq.n	8002348 <HAL_RCC_OscConfig+0x170>
 80022d8:	2b00      	cmp	r3, #0
 80022da:	f000 80e7 	beq.w	80024ac <HAL_RCC_OscConfig+0x2d4>
 80022de:	2b05      	cmp	r3, #5
 80022e0:	4b6b      	ldr	r3, [pc, #428]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 80022e2:	6a1a      	ldr	r2, [r3, #32]
 80022e4:	f000 811f 	beq.w	8002526 <HAL_RCC_OscConfig+0x34e>
 80022e8:	f022 0201 	bic.w	r2, r2, #1
 80022ec:	621a      	str	r2, [r3, #32]
 80022ee:	6a1a      	ldr	r2, [r3, #32]
 80022f0:	f022 0204 	bic.w	r2, r2, #4
 80022f4:	621a      	str	r2, [r3, #32]
 80022f6:	e02c      	b.n	8002352 <HAL_RCC_OscConfig+0x17a>
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80022f8:	4a65      	ldr	r2, [pc, #404]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 80022fa:	6851      	ldr	r1, [r2, #4]
 80022fc:	f011 0f0c 	tst.w	r1, #12
 8002300:	d061      	beq.n	80023c6 <HAL_RCC_OscConfig+0x1ee>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 8002302:	6851      	ldr	r1, [r2, #4]
 8002304:	f001 010c 	and.w	r1, r1, #12
 8002308:	2908      	cmp	r1, #8
 800230a:	d059      	beq.n	80023c0 <HAL_RCC_OscConfig+0x1e8>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800230c:	6923      	ldr	r3, [r4, #16]
 800230e:	2b00      	cmp	r3, #0
 8002310:	f000 80eb 	beq.w	80024ea <HAL_RCC_OscConfig+0x312>
        __HAL_RCC_HSI_ENABLE();
 8002314:	2201      	movs	r2, #1
 8002316:	4b63      	ldr	r3, [pc, #396]	; (80024a4 <HAL_RCC_OscConfig+0x2cc>)
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002318:	4d5d      	ldr	r5, [pc, #372]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
        __HAL_RCC_HSI_ENABLE();
 800231a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800231c:	f7ff f8f0 	bl	8001500 <HAL_GetTick>
 8002320:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002322:	e005      	b.n	8002330 <HAL_RCC_OscConfig+0x158>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002324:	f7ff f8ec 	bl	8001500 <HAL_GetTick>
 8002328:	1b80      	subs	r0, r0, r6
 800232a:	2802      	cmp	r0, #2
 800232c:	f200 8085 	bhi.w	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002330:	682b      	ldr	r3, [r5, #0]
 8002332:	0798      	lsls	r0, r3, #30
 8002334:	d5f6      	bpl.n	8002324 <HAL_RCC_OscConfig+0x14c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002336:	682b      	ldr	r3, [r5, #0]
 8002338:	6962      	ldr	r2, [r4, #20]
 800233a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800233e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8002342:	602b      	str	r3, [r5, #0]
 8002344:	6823      	ldr	r3, [r4, #0]
 8002346:	e789      	b.n	800225c <HAL_RCC_OscConfig+0x84>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002348:	4a51      	ldr	r2, [pc, #324]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 800234a:	6a13      	ldr	r3, [r2, #32]
 800234c:	f043 0301 	orr.w	r3, r3, #1
 8002350:	6213      	str	r3, [r2, #32]
      tickstart = HAL_GetTick();
 8002352:	f7ff f8d5 	bl	8001500 <HAL_GetTick>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002356:	4e4e      	ldr	r6, [pc, #312]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
      tickstart = HAL_GetTick();
 8002358:	4680      	mov	r8, r0
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800235a:	f241 3788 	movw	r7, #5000	; 0x1388
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800235e:	e005      	b.n	800236c <HAL_RCC_OscConfig+0x194>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002360:	f7ff f8ce 	bl	8001500 <HAL_GetTick>
 8002364:	eba0 0008 	sub.w	r0, r0, r8
 8002368:	42b8      	cmp	r0, r7
 800236a:	d866      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800236c:	6a33      	ldr	r3, [r6, #32]
 800236e:	079b      	lsls	r3, r3, #30
 8002370:	d5f6      	bpl.n	8002360 <HAL_RCC_OscConfig+0x188>
    if (pwrclkchanged == SET)
 8002372:	b125      	cbz	r5, 800237e <HAL_RCC_OscConfig+0x1a6>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002374:	4a46      	ldr	r2, [pc, #280]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 8002376:	69d3      	ldr	r3, [r2, #28]
 8002378:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800237c:	61d3      	str	r3, [r2, #28]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800237e:	69e0      	ldr	r0, [r4, #28]
 8002380:	b1d0      	cbz	r0, 80023b8 <HAL_RCC_OscConfig+0x1e0>
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8002382:	4d43      	ldr	r5, [pc, #268]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 8002384:	686a      	ldr	r2, [r5, #4]
 8002386:	f002 020c 	and.w	r2, r2, #12
 800238a:	2a08      	cmp	r2, #8
 800238c:	f000 80d3 	beq.w	8002536 <HAL_RCC_OscConfig+0x35e>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002390:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8002392:	f04f 0100 	mov.w	r1, #0
 8002396:	4a44      	ldr	r2, [pc, #272]	; (80024a8 <HAL_RCC_OscConfig+0x2d0>)
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8002398:	f000 80de 	beq.w	8002558 <HAL_RCC_OscConfig+0x380>
        __HAL_RCC_PLL_DISABLE();
 800239c:	6011      	str	r1, [r2, #0]
        tickstart = HAL_GetTick();
 800239e:	f7ff f8af 	bl	8001500 <HAL_GetTick>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80023a2:	462c      	mov	r4, r5
        tickstart = HAL_GetTick();
 80023a4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80023a6:	e004      	b.n	80023b2 <HAL_RCC_OscConfig+0x1da>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80023a8:	f7ff f8aa 	bl	8001500 <HAL_GetTick>
 80023ac:	1b40      	subs	r0, r0, r5
 80023ae:	2802      	cmp	r0, #2
 80023b0:	d843      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80023b2:	6823      	ldr	r3, [r4, #0]
 80023b4:	019b      	lsls	r3, r3, #6
 80023b6:	d4f7      	bmi.n	80023a8 <HAL_RCC_OscConfig+0x1d0>
  return HAL_OK;
 80023b8:	2000      	movs	r0, #0
}
 80023ba:	b002      	add	sp, #8
 80023bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI_DIV2)))
 80023c0:	6852      	ldr	r2, [r2, #4]
 80023c2:	03d6      	lsls	r6, r2, #15
 80023c4:	d4a2      	bmi.n	800230c <HAL_RCC_OscConfig+0x134>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80023c6:	4a32      	ldr	r2, [pc, #200]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 80023c8:	6812      	ldr	r2, [r2, #0]
 80023ca:	0795      	lsls	r5, r2, #30
 80023cc:	d539      	bpl.n	8002442 <HAL_RCC_OscConfig+0x26a>
 80023ce:	6922      	ldr	r2, [r4, #16]
 80023d0:	2a01      	cmp	r2, #1
 80023d2:	d036      	beq.n	8002442 <HAL_RCC_OscConfig+0x26a>
        return HAL_ERROR;
 80023d4:	2001      	movs	r0, #1
}
 80023d6:	b002      	add	sp, #8
 80023d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_LSI_DISABLE();
 80023dc:	4a2d      	ldr	r2, [pc, #180]	; (8002494 <HAL_RCC_OscConfig+0x2bc>)
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80023de:	4d2c      	ldr	r5, [pc, #176]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
      __HAL_RCC_LSI_DISABLE();
 80023e0:	6013      	str	r3, [r2, #0]
      tickstart = HAL_GetTick();
 80023e2:	f7ff f88d 	bl	8001500 <HAL_GetTick>
 80023e6:	4606      	mov	r6, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80023e8:	e004      	b.n	80023f4 <HAL_RCC_OscConfig+0x21c>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80023ea:	f7ff f889 	bl	8001500 <HAL_GetTick>
 80023ee:	1b80      	subs	r0, r0, r6
 80023f0:	2802      	cmp	r0, #2
 80023f2:	d822      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80023f4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80023f6:	079f      	lsls	r7, r3, #30
 80023f8:	d4f7      	bmi.n	80023ea <HAL_RCC_OscConfig+0x212>
 80023fa:	e753      	b.n	80022a4 <HAL_RCC_OscConfig+0xcc>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 80023fc:	684a      	ldr	r2, [r1, #4]
 80023fe:	03d0      	lsls	r0, r2, #15
 8002400:	f57f af01 	bpl.w	8002206 <HAL_RCC_OscConfig+0x2e>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002404:	4a22      	ldr	r2, [pc, #136]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 8002406:	6812      	ldr	r2, [r2, #0]
 8002408:	0391      	lsls	r1, r2, #14
 800240a:	f57f af25 	bpl.w	8002258 <HAL_RCC_OscConfig+0x80>
 800240e:	6862      	ldr	r2, [r4, #4]
 8002410:	2a00      	cmp	r2, #0
 8002412:	f47f af21 	bne.w	8002258 <HAL_RCC_OscConfig+0x80>
 8002416:	e7dd      	b.n	80023d4 <HAL_RCC_OscConfig+0x1fc>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002418:	681a      	ldr	r2, [r3, #0]
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800241a:	461e      	mov	r6, r3
      SET_BIT(PWR->CR, PWR_CR_DBP);
 800241c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002420:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8002422:	f7ff f86d 	bl	8001500 <HAL_GetTick>
 8002426:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002428:	6833      	ldr	r3, [r6, #0]
 800242a:	05da      	lsls	r2, r3, #23
 800242c:	f53f af51 	bmi.w	80022d2 <HAL_RCC_OscConfig+0xfa>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002430:	f7ff f866 	bl	8001500 <HAL_GetTick>
 8002434:	1bc0      	subs	r0, r0, r7
 8002436:	2864      	cmp	r0, #100	; 0x64
 8002438:	d9f6      	bls.n	8002428 <HAL_RCC_OscConfig+0x250>
            return HAL_TIMEOUT;
 800243a:	2003      	movs	r0, #3
}
 800243c:	b002      	add	sp, #8
 800243e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002442:	4913      	ldr	r1, [pc, #76]	; (8002490 <HAL_RCC_OscConfig+0x2b8>)
 8002444:	6960      	ldr	r0, [r4, #20]
 8002446:	680a      	ldr	r2, [r1, #0]
 8002448:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 800244c:	ea42 02c0 	orr.w	r2, r2, r0, lsl #3
 8002450:	600a      	str	r2, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002452:	e703      	b.n	800225c <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002454:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002458:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 800245c:	681a      	ldr	r2, [r3, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 800245e:	461d      	mov	r5, r3
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002460:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002464:	601a      	str	r2, [r3, #0]
 8002466:	681a      	ldr	r2, [r3, #0]
 8002468:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800246c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800246e:	f7ff f847 	bl	8001500 <HAL_GetTick>
 8002472:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002474:	e004      	b.n	8002480 <HAL_RCC_OscConfig+0x2a8>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002476:	f7ff f843 	bl	8001500 <HAL_GetTick>
 800247a:	1b80      	subs	r0, r0, r6
 800247c:	2864      	cmp	r0, #100	; 0x64
 800247e:	d8dc      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002480:	682b      	ldr	r3, [r5, #0]
 8002482:	039b      	lsls	r3, r3, #14
 8002484:	d4f7      	bmi.n	8002476 <HAL_RCC_OscConfig+0x29e>
 8002486:	e6e6      	b.n	8002256 <HAL_RCC_OscConfig+0x7e>
    return HAL_ERROR;
 8002488:	2001      	movs	r0, #1
}
 800248a:	4770      	bx	lr
    FlagStatus       pwrclkchanged = RESET;
 800248c:	2500      	movs	r5, #0
 800248e:	e71b      	b.n	80022c8 <HAL_RCC_OscConfig+0xf0>
 8002490:	40021000 	.word	0x40021000
 8002494:	42420480 	.word	0x42420480
 8002498:	20000000 	.word	0x20000000
 800249c:	10624dd3 	.word	0x10624dd3
 80024a0:	40007000 	.word	0x40007000
 80024a4:	42420000 	.word	0x42420000
 80024a8:	42420060 	.word	0x42420060
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024ac:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80024b0:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 80024b4:	6a1a      	ldr	r2, [r3, #32]
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024b6:	461e      	mov	r6, r3
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024b8:	f022 0201 	bic.w	r2, r2, #1
 80024bc:	621a      	str	r2, [r3, #32]
 80024be:	6a1a      	ldr	r2, [r3, #32]
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80024c0:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024c4:	f022 0204 	bic.w	r2, r2, #4
 80024c8:	621a      	str	r2, [r3, #32]
      tickstart = HAL_GetTick();
 80024ca:	f7ff f819 	bl	8001500 <HAL_GetTick>
 80024ce:	4607      	mov	r7, r0
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024d0:	e004      	b.n	80024dc <HAL_RCC_OscConfig+0x304>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80024d2:	f7ff f815 	bl	8001500 <HAL_GetTick>
 80024d6:	1bc0      	subs	r0, r0, r7
 80024d8:	4540      	cmp	r0, r8
 80024da:	d8ae      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80024dc:	6a33      	ldr	r3, [r6, #32]
 80024de:	0798      	lsls	r0, r3, #30
 80024e0:	d4f7      	bmi.n	80024d2 <HAL_RCC_OscConfig+0x2fa>
    if (pwrclkchanged == SET)
 80024e2:	2d00      	cmp	r5, #0
 80024e4:	f43f af4b 	beq.w	800237e <HAL_RCC_OscConfig+0x1a6>
 80024e8:	e744      	b.n	8002374 <HAL_RCC_OscConfig+0x19c>
        __HAL_RCC_HSI_DISABLE();
 80024ea:	4a34      	ldr	r2, [pc, #208]	; (80025bc <HAL_RCC_OscConfig+0x3e4>)
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80024ec:	4d34      	ldr	r5, [pc, #208]	; (80025c0 <HAL_RCC_OscConfig+0x3e8>)
        __HAL_RCC_HSI_DISABLE();
 80024ee:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 80024f0:	f7ff f806 	bl	8001500 <HAL_GetTick>
 80024f4:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80024f6:	e004      	b.n	8002502 <HAL_RCC_OscConfig+0x32a>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80024f8:	f7ff f802 	bl	8001500 <HAL_GetTick>
 80024fc:	1b80      	subs	r0, r0, r6
 80024fe:	2802      	cmp	r0, #2
 8002500:	d89b      	bhi.n	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002502:	682b      	ldr	r3, [r5, #0]
 8002504:	0799      	lsls	r1, r3, #30
 8002506:	d4f7      	bmi.n	80024f8 <HAL_RCC_OscConfig+0x320>
 8002508:	6823      	ldr	r3, [r4, #0]
 800250a:	e6a7      	b.n	800225c <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800250c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002510:	f5a3 333c 	sub.w	r3, r3, #192512	; 0x2f000
 8002514:	681a      	ldr	r2, [r3, #0]
 8002516:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800251a:	601a      	str	r2, [r3, #0]
 800251c:	681a      	ldr	r2, [r3, #0]
 800251e:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002522:	601a      	str	r2, [r3, #0]
 8002524:	e689      	b.n	800223a <HAL_RCC_OscConfig+0x62>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002526:	f042 0204 	orr.w	r2, r2, #4
 800252a:	621a      	str	r2, [r3, #32]
 800252c:	6a1a      	ldr	r2, [r3, #32]
 800252e:	f042 0201 	orr.w	r2, r2, #1
 8002532:	621a      	str	r2, [r3, #32]
 8002534:	e70d      	b.n	8002352 <HAL_RCC_OscConfig+0x17a>
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 8002536:	2801      	cmp	r0, #1
 8002538:	f43f af4d 	beq.w	80023d6 <HAL_RCC_OscConfig+0x1fe>
        pll_config = RCC->CFGR;
 800253c:	686b      	ldr	r3, [r5, #4]
        if ((READ_BIT(pll_config, RCC_CFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800253e:	6a22      	ldr	r2, [r4, #32]
 8002540:	f403 3180 	and.w	r1, r3, #65536	; 0x10000
 8002544:	4291      	cmp	r1, r2
 8002546:	f47f af45 	bne.w	80023d4 <HAL_RCC_OscConfig+0x1fc>
 800254a:	6a60      	ldr	r0, [r4, #36]	; 0x24
            (READ_BIT(pll_config, RCC_CFGR_PLLMULL) != RCC_OscInitStruct->PLL.PLLMUL))
 800254c:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
    return HAL_ERROR;
 8002550:	1a18      	subs	r0, r3, r0
 8002552:	bf18      	it	ne
 8002554:	2001      	movne	r0, #1
 8002556:	e73e      	b.n	80023d6 <HAL_RCC_OscConfig+0x1fe>
        __HAL_RCC_PLL_DISABLE();
 8002558:	6011      	str	r1, [r2, #0]
        tickstart = HAL_GetTick();
 800255a:	f7fe ffd1 	bl	8001500 <HAL_GetTick>
 800255e:	4606      	mov	r6, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002560:	e005      	b.n	800256e <HAL_RCC_OscConfig+0x396>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002562:	f7fe ffcd 	bl	8001500 <HAL_GetTick>
 8002566:	1b80      	subs	r0, r0, r6
 8002568:	2802      	cmp	r0, #2
 800256a:	f63f af66 	bhi.w	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800256e:	682b      	ldr	r3, [r5, #0]
 8002570:	0199      	lsls	r1, r3, #6
 8002572:	d4f6      	bmi.n	8002562 <HAL_RCC_OscConfig+0x38a>
        if (RCC_OscInitStruct->PLL.PLLSource == RCC_PLLSOURCE_HSE)
 8002574:	6a22      	ldr	r2, [r4, #32]
 8002576:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800257a:	d105      	bne.n	8002588 <HAL_RCC_OscConfig+0x3b0>
          __HAL_RCC_HSE_PREDIV_CONFIG(RCC_OscInitStruct->HSEPredivValue);
 800257c:	686b      	ldr	r3, [r5, #4]
 800257e:	68a1      	ldr	r1, [r4, #8]
 8002580:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8002584:	430b      	orrs	r3, r1
 8002586:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002588:	2501      	movs	r5, #1
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800258a:	4b0d      	ldr	r3, [pc, #52]	; (80025c0 <HAL_RCC_OscConfig+0x3e8>)
 800258c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800258e:	6859      	ldr	r1, [r3, #4]
 8002590:	4302      	orrs	r2, r0
 8002592:	f421 1174 	bic.w	r1, r1, #3997696	; 0x3d0000
        __HAL_RCC_PLL_ENABLE();
 8002596:	480b      	ldr	r0, [pc, #44]	; (80025c4 <HAL_RCC_OscConfig+0x3ec>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002598:	430a      	orrs	r2, r1
 800259a:	605a      	str	r2, [r3, #4]
        __HAL_RCC_PLL_ENABLE();
 800259c:	6005      	str	r5, [r0, #0]
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800259e:	461c      	mov	r4, r3
        tickstart = HAL_GetTick();
 80025a0:	f7fe ffae 	bl	8001500 <HAL_GetTick>
 80025a4:	4605      	mov	r5, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80025a6:	e005      	b.n	80025b4 <HAL_RCC_OscConfig+0x3dc>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80025a8:	f7fe ffaa 	bl	8001500 <HAL_GetTick>
 80025ac:	1b40      	subs	r0, r0, r5
 80025ae:	2802      	cmp	r0, #2
 80025b0:	f63f af43 	bhi.w	800243a <HAL_RCC_OscConfig+0x262>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 80025b4:	6823      	ldr	r3, [r4, #0]
 80025b6:	019a      	lsls	r2, r3, #6
 80025b8:	d5f6      	bpl.n	80025a8 <HAL_RCC_OscConfig+0x3d0>
 80025ba:	e6fd      	b.n	80023b8 <HAL_RCC_OscConfig+0x1e0>
 80025bc:	42420000 	.word	0x42420000
 80025c0:	40021000 	.word	0x40021000
 80025c4:	42420060 	.word	0x42420060

080025c8 <HAL_RCC_GetSysClockFreq>:
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80025c8:	f240 2201 	movw	r2, #513	; 0x201
{
 80025cc:	b086      	sub	sp, #24
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 80025ce:	4b15      	ldr	r3, [pc, #84]	; (8002624 <HAL_RCC_GetSysClockFreq+0x5c>)
 80025d0:	f10d 0c18 	add.w	ip, sp, #24
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80025d4:	f8ad 2004 	strh.w	r2, [sp, #4]
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 80025d8:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80025da:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
  tmpreg = RCC->CFGR;
 80025de:	4912      	ldr	r1, [pc, #72]	; (8002628 <HAL_RCC_GetSysClockFreq+0x60>)
 80025e0:	684b      	ldr	r3, [r1, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 80025e2:	f003 020c 	and.w	r2, r3, #12
 80025e6:	2a08      	cmp	r2, #8
 80025e8:	d002      	beq.n	80025f0 <HAL_RCC_GetSysClockFreq+0x28>
      sysclockfreq = HSE_VALUE;
 80025ea:	4810      	ldr	r0, [pc, #64]	; (800262c <HAL_RCC_GetSysClockFreq+0x64>)
}
 80025ec:	b006      	add	sp, #24
 80025ee:	4770      	bx	lr
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 80025f0:	f3c3 4283 	ubfx	r2, r3, #18, #4
 80025f4:	4462      	add	r2, ip
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80025f6:	03db      	lsls	r3, r3, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 80025f8:	f812 2c10 	ldrb.w	r2, [r2, #-16]
      if ((tmpreg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 80025fc:	d404      	bmi.n	8002608 <HAL_RCC_GetSysClockFreq+0x40>
        pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 80025fe:	480c      	ldr	r0, [pc, #48]	; (8002630 <HAL_RCC_GetSysClockFreq+0x68>)
 8002600:	fb00 f002 	mul.w	r0, r0, r2
}
 8002604:	b006      	add	sp, #24
 8002606:	4770      	bx	lr
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002608:	684b      	ldr	r3, [r1, #4]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800260a:	4808      	ldr	r0, [pc, #32]	; (800262c <HAL_RCC_GetSysClockFreq+0x64>)
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 800260c:	f3c3 4340 	ubfx	r3, r3, #17, #1
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 8002610:	fb00 f002 	mul.w	r0, r0, r2
        prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002614:	4463      	add	r3, ip
 8002616:	f813 3c14 	ldrb.w	r3, [r3, #-20]
        pllclk = (uint32_t)((HSE_VALUE  * pllmul) / prediv);
 800261a:	fbb0 f0f3 	udiv	r0, r0, r3
}
 800261e:	b006      	add	sp, #24
 8002620:	4770      	bx	lr
 8002622:	bf00      	nop
 8002624:	08006594 	.word	0x08006594
 8002628:	40021000 	.word	0x40021000
 800262c:	007a1200 	.word	0x007a1200
 8002630:	003d0900 	.word	0x003d0900

08002634 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8002634:	b178      	cbz	r0, 8002656 <HAL_RCC_ClockConfig+0x22>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002636:	4a4a      	ldr	r2, [pc, #296]	; (8002760 <HAL_RCC_ClockConfig+0x12c>)
 8002638:	6813      	ldr	r3, [r2, #0]
 800263a:	f003 0307 	and.w	r3, r3, #7
 800263e:	428b      	cmp	r3, r1
 8002640:	d20b      	bcs.n	800265a <HAL_RCC_ClockConfig+0x26>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002642:	6813      	ldr	r3, [r2, #0]
 8002644:	f023 0307 	bic.w	r3, r3, #7
 8002648:	430b      	orrs	r3, r1
 800264a:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 800264c:	6813      	ldr	r3, [r2, #0]
 800264e:	f003 0307 	and.w	r3, r3, #7
 8002652:	428b      	cmp	r3, r1
 8002654:	d001      	beq.n	800265a <HAL_RCC_ClockConfig+0x26>
    return HAL_ERROR;
 8002656:	2001      	movs	r0, #1
}
 8002658:	4770      	bx	lr
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800265a:	6803      	ldr	r3, [r0, #0]
{
 800265c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002660:	079d      	lsls	r5, r3, #30
 8002662:	d514      	bpl.n	800268e <HAL_RCC_ClockConfig+0x5a>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002664:	075c      	lsls	r4, r3, #29
 8002666:	d504      	bpl.n	8002672 <HAL_RCC_ClockConfig+0x3e>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 8002668:	4c3e      	ldr	r4, [pc, #248]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 800266a:	6862      	ldr	r2, [r4, #4]
 800266c:	f442 62e0 	orr.w	r2, r2, #1792	; 0x700
 8002670:	6062      	str	r2, [r4, #4]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002672:	071a      	lsls	r2, r3, #28
 8002674:	d504      	bpl.n	8002680 <HAL_RCC_ClockConfig+0x4c>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 8002676:	4c3b      	ldr	r4, [pc, #236]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 8002678:	6862      	ldr	r2, [r4, #4]
 800267a:	f442 5260 	orr.w	r2, r2, #14336	; 0x3800
 800267e:	6062      	str	r2, [r4, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002680:	4c38      	ldr	r4, [pc, #224]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 8002682:	6885      	ldr	r5, [r0, #8]
 8002684:	6862      	ldr	r2, [r4, #4]
 8002686:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 800268a:	432a      	orrs	r2, r5
 800268c:	6062      	str	r2, [r4, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800268e:	07df      	lsls	r7, r3, #31
 8002690:	4604      	mov	r4, r0
 8002692:	460d      	mov	r5, r1
 8002694:	d520      	bpl.n	80026d8 <HAL_RCC_ClockConfig+0xa4>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002696:	6842      	ldr	r2, [r0, #4]
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002698:	4b32      	ldr	r3, [pc, #200]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800269a:	2a01      	cmp	r2, #1
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800269c:	681b      	ldr	r3, [r3, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800269e:	d056      	beq.n	800274e <HAL_RCC_ClockConfig+0x11a>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80026a0:	2a02      	cmp	r2, #2
 80026a2:	d059      	beq.n	8002758 <HAL_RCC_ClockConfig+0x124>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80026a4:	0799      	lsls	r1, r3, #30
 80026a6:	d527      	bpl.n	80026f8 <HAL_RCC_ClockConfig+0xc4>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80026a8:	4e2e      	ldr	r6, [pc, #184]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80026aa:	f241 3888 	movw	r8, #5000	; 0x1388
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80026ae:	6873      	ldr	r3, [r6, #4]
 80026b0:	f023 0303 	bic.w	r3, r3, #3
 80026b4:	4313      	orrs	r3, r2
 80026b6:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 80026b8:	f7fe ff22 	bl	8001500 <HAL_GetTick>
 80026bc:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80026be:	e004      	b.n	80026ca <HAL_RCC_ClockConfig+0x96>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80026c0:	f7fe ff1e 	bl	8001500 <HAL_GetTick>
 80026c4:	1bc0      	subs	r0, r0, r7
 80026c6:	4540      	cmp	r0, r8
 80026c8:	d844      	bhi.n	8002754 <HAL_RCC_ClockConfig+0x120>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80026ca:	6873      	ldr	r3, [r6, #4]
 80026cc:	6862      	ldr	r2, [r4, #4]
 80026ce:	f003 030c 	and.w	r3, r3, #12
 80026d2:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80026d6:	d1f3      	bne.n	80026c0 <HAL_RCC_ClockConfig+0x8c>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80026d8:	4a21      	ldr	r2, [pc, #132]	; (8002760 <HAL_RCC_ClockConfig+0x12c>)
 80026da:	6813      	ldr	r3, [r2, #0]
 80026dc:	f003 0307 	and.w	r3, r3, #7
 80026e0:	42ab      	cmp	r3, r5
 80026e2:	d90c      	bls.n	80026fe <HAL_RCC_ClockConfig+0xca>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80026e4:	6813      	ldr	r3, [r2, #0]
 80026e6:	f023 0307 	bic.w	r3, r3, #7
 80026ea:	432b      	orrs	r3, r5
 80026ec:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 80026ee:	6813      	ldr	r3, [r2, #0]
 80026f0:	f003 0307 	and.w	r3, r3, #7
 80026f4:	42ab      	cmp	r3, r5
 80026f6:	d002      	beq.n	80026fe <HAL_RCC_ClockConfig+0xca>
    return HAL_ERROR;
 80026f8:	2001      	movs	r0, #1
}
 80026fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80026fe:	6823      	ldr	r3, [r4, #0]
 8002700:	075a      	lsls	r2, r3, #29
 8002702:	d506      	bpl.n	8002712 <HAL_RCC_ClockConfig+0xde>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8002704:	4917      	ldr	r1, [pc, #92]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 8002706:	68e0      	ldr	r0, [r4, #12]
 8002708:	684a      	ldr	r2, [r1, #4]
 800270a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 800270e:	4302      	orrs	r2, r0
 8002710:	604a      	str	r2, [r1, #4]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002712:	071b      	lsls	r3, r3, #28
 8002714:	d412      	bmi.n	800273c <HAL_RCC_ClockConfig+0x108>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002716:	f7ff ff57 	bl	80025c8 <HAL_RCC_GetSysClockFreq>
 800271a:	4b12      	ldr	r3, [pc, #72]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 800271c:	4a12      	ldr	r2, [pc, #72]	; (8002768 <HAL_RCC_ClockConfig+0x134>)
 800271e:	685b      	ldr	r3, [r3, #4]
  HAL_InitTick(uwTickPrio);
 8002720:	4912      	ldr	r1, [pc, #72]	; (800276c <HAL_RCC_ClockConfig+0x138>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002722:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002726:	5cd3      	ldrb	r3, [r2, r3]
 8002728:	4a11      	ldr	r2, [pc, #68]	; (8002770 <HAL_RCC_ClockConfig+0x13c>)
 800272a:	fa20 f303 	lsr.w	r3, r0, r3
  HAL_InitTick(uwTickPrio);
 800272e:	6808      	ldr	r0, [r1, #0]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002730:	6013      	str	r3, [r2, #0]
  HAL_InitTick(uwTickPrio);
 8002732:	f7fe fddb 	bl	80012ec <HAL_InitTick>
  return HAL_OK;
 8002736:	2000      	movs	r0, #0
}
 8002738:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 800273c:	4a09      	ldr	r2, [pc, #36]	; (8002764 <HAL_RCC_ClockConfig+0x130>)
 800273e:	6921      	ldr	r1, [r4, #16]
 8002740:	6853      	ldr	r3, [r2, #4]
 8002742:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002746:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800274a:	6053      	str	r3, [r2, #4]
 800274c:	e7e3      	b.n	8002716 <HAL_RCC_ClockConfig+0xe2>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800274e:	039e      	lsls	r6, r3, #14
 8002750:	d4aa      	bmi.n	80026a8 <HAL_RCC_ClockConfig+0x74>
 8002752:	e7d1      	b.n	80026f8 <HAL_RCC_ClockConfig+0xc4>
        return HAL_TIMEOUT;
 8002754:	2003      	movs	r0, #3
 8002756:	e7ef      	b.n	8002738 <HAL_RCC_ClockConfig+0x104>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8002758:	0198      	lsls	r0, r3, #6
 800275a:	d4a5      	bmi.n	80026a8 <HAL_RCC_ClockConfig+0x74>
 800275c:	e7cc      	b.n	80026f8 <HAL_RCC_ClockConfig+0xc4>
 800275e:	bf00      	nop
 8002760:	40022000 	.word	0x40022000
 8002764:	40021000 	.word	0x40021000
 8002768:	080066d0 	.word	0x080066d0
 800276c:	20000008 	.word	0x20000008
 8002770:	20000000 	.word	0x20000000

08002774 <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 8002774:	4b04      	ldr	r3, [pc, #16]	; (8002788 <HAL_RCC_GetPCLK1Freq+0x14>)
 8002776:	4905      	ldr	r1, [pc, #20]	; (800278c <HAL_RCC_GetPCLK1Freq+0x18>)
 8002778:	685b      	ldr	r3, [r3, #4]
  return SystemCoreClock;
 800277a:	4a05      	ldr	r2, [pc, #20]	; (8002790 <HAL_RCC_GetPCLK1Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800277c:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002780:	5ccb      	ldrb	r3, [r1, r3]
 8002782:	6810      	ldr	r0, [r2, #0]
}
 8002784:	40d8      	lsrs	r0, r3
 8002786:	4770      	bx	lr
 8002788:	40021000 	.word	0x40021000
 800278c:	080066e0 	.word	0x080066e0
 8002790:	20000000 	.word	0x20000000

08002794 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 8002794:	4b04      	ldr	r3, [pc, #16]	; (80027a8 <HAL_RCC_GetPCLK2Freq+0x14>)
 8002796:	4905      	ldr	r1, [pc, #20]	; (80027ac <HAL_RCC_GetPCLK2Freq+0x18>)
 8002798:	685b      	ldr	r3, [r3, #4]
  return SystemCoreClock;
 800279a:	4a05      	ldr	r2, [pc, #20]	; (80027b0 <HAL_RCC_GetPCLK2Freq+0x1c>)
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800279c:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 80027a0:	5ccb      	ldrb	r3, [r1, r3]
 80027a2:	6810      	ldr	r0, [r2, #0]
}
 80027a4:	40d8      	lsrs	r0, r3
 80027a6:	4770      	bx	lr
 80027a8:	40021000 	.word	0x40021000
 80027ac:	080066e0 	.word	0x080066e0
 80027b0:	20000000 	.word	0x20000000

080027b4 <HAL_RCC_GetClockConfig>:
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80027b4:	220f      	movs	r2, #15
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80027b6:	4b0d      	ldr	r3, [pc, #52]	; (80027ec <HAL_RCC_GetClockConfig+0x38>)
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80027b8:	6002      	str	r2, [r0, #0]
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80027ba:	685a      	ldr	r2, [r3, #4]
{
 80027bc:	b410      	push	{r4}
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80027be:	f002 0203 	and.w	r2, r2, #3
 80027c2:	6042      	str	r2, [r0, #4]
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80027c4:	685a      	ldr	r2, [r3, #4]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80027c6:	4c0a      	ldr	r4, [pc, #40]	; (80027f0 <HAL_RCC_GetClockConfig+0x3c>)
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 80027c8:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80027cc:	6082      	str	r2, [r0, #8]
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 80027ce:	685a      	ldr	r2, [r3, #4]
 80027d0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80027d4:	60c2      	str	r2, [r0, #12]
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 80027d6:	685b      	ldr	r3, [r3, #4]
 80027d8:	08db      	lsrs	r3, r3, #3
 80027da:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80027de:	6103      	str	r3, [r0, #16]
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80027e0:	6823      	ldr	r3, [r4, #0]
}
 80027e2:	bc10      	pop	{r4}
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 80027e4:	f003 0307 	and.w	r3, r3, #7
 80027e8:	600b      	str	r3, [r1, #0]
}
 80027ea:	4770      	bx	lr
 80027ec:	40021000 	.word	0x40021000
 80027f0:	40022000 	.word	0x40022000

080027f4 <HAL_RCCEx_PeriphCLKConfig>:
  *         manually disable it.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 80027f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80027f8:	4604      	mov	r4, r0

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*------------------------------- RTC/LCD Configuration ------------------------*/
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 80027fa:	6800      	ldr	r0, [r0, #0]
{
 80027fc:	b082      	sub	sp, #8
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC))
 80027fe:	07c5      	lsls	r5, r0, #31
 8002800:	d52a      	bpl.n	8002858 <HAL_RCCEx_PeriphCLKConfig+0x64>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002802:	4b3a      	ldr	r3, [pc, #232]	; (80028ec <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002804:	69da      	ldr	r2, [r3, #28]
 8002806:	00d1      	lsls	r1, r2, #3
 8002808:	d53d      	bpl.n	8002886 <HAL_RCCEx_PeriphCLKConfig+0x92>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }

    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800280a:	4b39      	ldr	r3, [pc, #228]	; (80028f0 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
    FlagStatus       pwrclkchanged = RESET;
 800280c:	2500      	movs	r5, #0
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800280e:	681a      	ldr	r2, [r3, #0]
 8002810:	05d2      	lsls	r2, r2, #23
 8002812:	d546      	bpl.n	80028a2 <HAL_RCCEx_PeriphCLKConfig+0xae>
        }
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8002814:	4935      	ldr	r1, [pc, #212]	; (80028ec <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002816:	6860      	ldr	r0, [r4, #4]
 8002818:	6a0a      	ldr	r2, [r1, #32]
    if ((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800281a:	f412 7240 	ands.w	r2, r2, #768	; 0x300
 800281e:	d00f      	beq.n	8002840 <HAL_RCCEx_PeriphCLKConfig+0x4c>
 8002820:	f400 7340 	and.w	r3, r0, #768	; 0x300
 8002824:	4293      	cmp	r3, r2
 8002826:	d00b      	beq.n	8002840 <HAL_RCCEx_PeriphCLKConfig+0x4c>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8002828:	2701      	movs	r7, #1
      __HAL_RCC_BACKUPRESET_RELEASE();
 800282a:	2600      	movs	r6, #0
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800282c:	6a0b      	ldr	r3, [r1, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 800282e:	4a31      	ldr	r2, [pc, #196]	; (80028f4 <HAL_RCCEx_PeriphCLKConfig+0x100>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002830:	f423 7040 	bic.w	r0, r3, #768	; 0x300
      __HAL_RCC_BACKUPRESET_FORCE();
 8002834:	6017      	str	r7, [r2, #0]
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002836:	6016      	str	r6, [r2, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = temp_reg;
 8002838:	6208      	str	r0, [r1, #32]

      /* Wait for LSERDY if LSE was enabled */
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 800283a:	07d8      	lsls	r0, r3, #31
 800283c:	d445      	bmi.n	80028ca <HAL_RCCEx_PeriphCLKConfig+0xd6>
 800283e:	6860      	ldr	r0, [r4, #4]
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002840:	4a2a      	ldr	r2, [pc, #168]	; (80028ec <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002842:	6a13      	ldr	r3, [r2, #32]
 8002844:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002848:	4303      	orrs	r3, r0
 800284a:	6213      	str	r3, [r2, #32]

    /* Require to disable power clock if necessary */
    if (pwrclkchanged == SET)
 800284c:	b11d      	cbz	r5, 8002856 <HAL_RCCEx_PeriphCLKConfig+0x62>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800284e:	69d3      	ldr	r3, [r2, #28]
 8002850:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002854:	61d3      	str	r3, [r2, #28]
 8002856:	6820      	ldr	r0, [r4, #0]
    }
  }

  /*------------------------------ ADC clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8002858:	0783      	lsls	r3, r0, #30
 800285a:	d506      	bpl.n	800286a <HAL_RCCEx_PeriphCLKConfig+0x76>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCPLLCLK_DIV(PeriphClkInit->AdcClockSelection));

    /* Configure the ADC clock source */
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800285c:	4a23      	ldr	r2, [pc, #140]	; (80028ec <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 800285e:	68a1      	ldr	r1, [r4, #8]
 8002860:	6853      	ldr	r3, [r2, #4]
 8002862:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 8002866:	430b      	orrs	r3, r1
 8002868:	6053      	str	r3, [r2, #4]

#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6)\
 || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)\
 || defined(STM32F105xC) || defined(STM32F107xC)
  /*------------------------------ USB clock Configuration ------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800286a:	f010 0010 	ands.w	r0, r0, #16
 800286e:	d007      	beq.n	8002880 <HAL_RCCEx_PeriphCLKConfig+0x8c>
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
  }
#endif /* STM32F102x6 || STM32F102xB || STM32F103x6 || STM32F103xB || STM32F103xE || STM32F103xG || STM32F105xC || STM32F107xC */

  return HAL_OK;
 8002870:	2000      	movs	r0, #0
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002872:	4a1e      	ldr	r2, [pc, #120]	; (80028ec <HAL_RCCEx_PeriphCLKConfig+0xf8>)
 8002874:	68e1      	ldr	r1, [r4, #12]
 8002876:	6853      	ldr	r3, [r2, #4]
 8002878:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800287c:	430b      	orrs	r3, r1
 800287e:	6053      	str	r3, [r2, #4]
}
 8002880:	b002      	add	sp, #8
 8002882:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 8002886:	69da      	ldr	r2, [r3, #28]
      pwrclkchanged = SET;
 8002888:	2501      	movs	r5, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 800288a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800288e:	61da      	str	r2, [r3, #28]
 8002890:	69db      	ldr	r3, [r3, #28]
 8002892:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002896:	9301      	str	r3, [sp, #4]
 8002898:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800289a:	4b15      	ldr	r3, [pc, #84]	; (80028f0 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
 800289c:	681a      	ldr	r2, [r3, #0]
 800289e:	05d2      	lsls	r2, r2, #23
 80028a0:	d4b8      	bmi.n	8002814 <HAL_RCCEx_PeriphCLKConfig+0x20>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80028a2:	681a      	ldr	r2, [r3, #0]
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80028a4:	461e      	mov	r6, r3
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80028a6:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80028aa:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 80028ac:	f7fe fe28 	bl	8001500 <HAL_GetTick>
 80028b0:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80028b2:	6833      	ldr	r3, [r6, #0]
 80028b4:	05db      	lsls	r3, r3, #23
 80028b6:	d4ad      	bmi.n	8002814 <HAL_RCCEx_PeriphCLKConfig+0x20>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80028b8:	f7fe fe22 	bl	8001500 <HAL_GetTick>
 80028bc:	1bc0      	subs	r0, r0, r7
 80028be:	2864      	cmp	r0, #100	; 0x64
 80028c0:	d9f7      	bls.n	80028b2 <HAL_RCCEx_PeriphCLKConfig+0xbe>
          return HAL_TIMEOUT;
 80028c2:	2003      	movs	r0, #3
}
 80028c4:	b002      	add	sp, #8
 80028c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80028ca:	460e      	mov	r6, r1
        tickstart = HAL_GetTick();
 80028cc:	f7fe fe18 	bl	8001500 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80028d0:	f241 3788 	movw	r7, #5000	; 0x1388
        tickstart = HAL_GetTick();
 80028d4:	4680      	mov	r8, r0
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80028d6:	6a33      	ldr	r3, [r6, #32]
 80028d8:	079a      	lsls	r2, r3, #30
 80028da:	d4b0      	bmi.n	800283e <HAL_RCCEx_PeriphCLKConfig+0x4a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80028dc:	f7fe fe10 	bl	8001500 <HAL_GetTick>
 80028e0:	eba0 0008 	sub.w	r0, r0, r8
 80028e4:	42b8      	cmp	r0, r7
 80028e6:	d9f6      	bls.n	80028d6 <HAL_RCCEx_PeriphCLKConfig+0xe2>
 80028e8:	e7eb      	b.n	80028c2 <HAL_RCCEx_PeriphCLKConfig+0xce>
 80028ea:	bf00      	nop
 80028ec:	40021000 	.word	0x40021000
 80028f0:	40007000 	.word	0x40007000
 80028f4:	42420440 	.word	0x42420440

080028f8 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg @ref RCC_PERIPHCLK_USB  USB peripheral clock
  @endif
  * @retval Frequency in Hz (0: means that no available frequency for the peripheral)
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 80028f8:	b510      	push	{r4, lr}
 80028fa:	4604      	mov	r4, r0
  uint32_t pll2mul = 0U, pll3mul = 0U, prediv2 = 0U;
#endif /* STM32F105xC || STM32F107xC */
#if defined(STM32F102x6) || defined(STM32F102xB) || defined(STM32F103x6) || \
    defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG)
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
  const uint8_t aPredivFactorTable[2] = {1, 2};
 80028fc:	f240 2201 	movw	r2, #513	; 0x201
{
 8002900:	b086      	sub	sp, #24
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 8002902:	4b34      	ldr	r3, [pc, #208]	; (80029d4 <HAL_RCCEx_GetPeriphCLKFreq+0xdc>)
 8002904:	f10d 0c18 	add.w	ip, sp, #24
  uint32_t temp_reg = 0U, frequency = 0U;

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClk));

  switch (PeriphClk)
 8002908:	2c02      	cmp	r4, #2
  const uint8_t aPredivFactorTable[2] = {1, 2};
 800290a:	f8ad 2004 	strh.w	r2, [sp, #4]
  const uint8_t aPLLMULFactorTable[16] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 16};
 800290e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002910:	e90c 000f 	stmdb	ip, {r0, r1, r2, r3}
  switch (PeriphClk)
 8002914:	d042      	beq.n	800299c <HAL_RCCEx_GetPeriphCLKFreq+0xa4>
 8002916:	2c10      	cmp	r4, #16
 8002918:	d01c      	beq.n	8002954 <HAL_RCCEx_GetPeriphCLKFreq+0x5c>
 800291a:	2c01      	cmp	r4, #1
 800291c:	d002      	beq.n	8002924 <HAL_RCCEx_GetPeriphCLKFreq+0x2c>
  uint32_t temp_reg = 0U, frequency = 0U;
 800291e:	2000      	movs	r0, #0
    {
      break;
    }
  }
  return (frequency);
}
 8002920:	b006      	add	sp, #24
 8002922:	bd10      	pop	{r4, pc}
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
 8002924:	f240 3202 	movw	r2, #770	; 0x302
      temp_reg = RCC->BDCR;
 8002928:	492b      	ldr	r1, [pc, #172]	; (80029d8 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 800292a:	6a0b      	ldr	r3, [r1, #32]
      if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSE) && (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSERDY)))
 800292c:	401a      	ands	r2, r3
 800292e:	f5b2 7f81 	cmp.w	r2, #258	; 0x102
 8002932:	d04b      	beq.n	80029cc <HAL_RCCEx_GetPeriphCLKFreq+0xd4>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 8002934:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8002938:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800293c:	d03a      	beq.n	80029b4 <HAL_RCCEx_GetPeriphCLKFreq+0xbc>
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 800293e:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8002942:	d1ec      	bne.n	800291e <HAL_RCCEx_GetPeriphCLKFreq+0x26>
 8002944:	680b      	ldr	r3, [r1, #0]
        frequency = HSE_VALUE / 128U;
 8002946:	f24f 4024 	movw	r0, #62500	; 0xf424
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_HSE_DIV128) && (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)))
 800294a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        frequency = HSE_VALUE / 128U;
 800294e:	bf08      	it	eq
 8002950:	2000      	moveq	r0, #0
 8002952:	e7e5      	b.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      temp_reg = RCC->CFGR;
 8002954:	4b20      	ldr	r3, [pc, #128]	; (80029d8 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 8002956:	6859      	ldr	r1, [r3, #4]
      if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLLON))
 8002958:	6818      	ldr	r0, [r3, #0]
 800295a:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 800295e:	d0df      	beq.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
        pllmul = aPLLMULFactorTable[(uint32_t)(temp_reg & RCC_CFGR_PLLMULL) >> RCC_CFGR_PLLMULL_Pos];
 8002960:	a806      	add	r0, sp, #24
 8002962:	f3c1 4283 	ubfx	r2, r1, #18, #4
 8002966:	4402      	add	r2, r0
 8002968:	f812 0c10 	ldrb.w	r0, [r2, #-16]
        if ((temp_reg & RCC_CFGR_PLLSRC) != RCC_PLLSOURCE_HSI_DIV2)
 800296c:	03ca      	lsls	r2, r1, #15
 800296e:	d529      	bpl.n	80029c4 <HAL_RCCEx_GetPeriphCLKFreq+0xcc>
          prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 8002970:	685b      	ldr	r3, [r3, #4]
 8002972:	a906      	add	r1, sp, #24
 8002974:	f3c3 4340 	ubfx	r3, r3, #17, #1
 8002978:	440b      	add	r3, r1
            pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
 800297a:	4a18      	ldr	r2, [pc, #96]	; (80029dc <HAL_RCCEx_GetPeriphCLKFreq+0xe4>)
          prediv1 = aPredivFactorTable[(uint32_t)(RCC->CFGR & RCC_CFGR_PLLXTPRE) >> RCC_CFGR_PLLXTPRE_Pos];
 800297c:	f813 3c14 	ldrb.w	r3, [r3, #-20]
            pllclk = (uint32_t)((HSE_VALUE / prediv1) * pllmul);
 8002980:	fbb2 f3f3 	udiv	r3, r2, r3
 8002984:	fb00 f003 	mul.w	r0, r0, r3
        if (__HAL_RCC_GET_USB_SOURCE() == RCC_USBCLKSOURCE_PLL)
 8002988:	4b13      	ldr	r3, [pc, #76]	; (80029d8 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 800298a:	685b      	ldr	r3, [r3, #4]
 800298c:	025b      	lsls	r3, r3, #9
 800298e:	d4c7      	bmi.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
          frequency = (pllclk * 2) / 3;
 8002990:	4b13      	ldr	r3, [pc, #76]	; (80029e0 <HAL_RCCEx_GetPeriphCLKFreq+0xe8>)
 8002992:	0040      	lsls	r0, r0, #1
 8002994:	fba3 3000 	umull	r3, r0, r3, r0
 8002998:	0840      	lsrs	r0, r0, #1
 800299a:	e7c1      	b.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
      frequency = HAL_RCC_GetPCLK2Freq() / (((__HAL_RCC_GET_ADC_SOURCE() >> RCC_CFGR_ADCPRE_Pos) + 1) * 2);
 800299c:	f7ff fefa 	bl	8002794 <HAL_RCC_GetPCLK2Freq>
 80029a0:	4b0d      	ldr	r3, [pc, #52]	; (80029d8 <HAL_RCCEx_GetPeriphCLKFreq+0xe0>)
 80029a2:	685b      	ldr	r3, [r3, #4]
 80029a4:	f3c3 3381 	ubfx	r3, r3, #14, #2
 80029a8:	3301      	adds	r3, #1
 80029aa:	005b      	lsls	r3, r3, #1
 80029ac:	fbb0 f0f3 	udiv	r0, r0, r3
}
 80029b0:	b006      	add	sp, #24
 80029b2:	bd10      	pop	{r4, pc}
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 80029b4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
        frequency = LSI_VALUE;
 80029b6:	f649 4040 	movw	r0, #40000	; 0x9c40
      else if (((temp_reg & RCC_BDCR_RTCSEL) == RCC_RTCCLKSOURCE_LSI) && (HAL_IS_BIT_SET(RCC->CSR, RCC_CSR_LSIRDY)))
 80029ba:	f013 0f02 	tst.w	r3, #2
        frequency = LSI_VALUE;
 80029be:	bf08      	it	eq
 80029c0:	2000      	moveq	r0, #0
 80029c2:	e7ad      	b.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
          pllclk = (uint32_t)((HSI_VALUE >> 1) * pllmul);
 80029c4:	4b07      	ldr	r3, [pc, #28]	; (80029e4 <HAL_RCCEx_GetPeriphCLKFreq+0xec>)
 80029c6:	fb03 f000 	mul.w	r0, r3, r0
 80029ca:	e7dd      	b.n	8002988 <HAL_RCCEx_GetPeriphCLKFreq+0x90>
        frequency = LSE_VALUE;
 80029cc:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80029d0:	e7a6      	b.n	8002920 <HAL_RCCEx_GetPeriphCLKFreq+0x28>
 80029d2:	bf00      	nop
 80029d4:	080065a4 	.word	0x080065a4
 80029d8:	40021000 	.word	0x40021000
 80029dc:	007a1200 	.word	0x007a1200
 80029e0:	aaaaaaab 	.word	0xaaaaaaab
 80029e4:	003d0900 	.word	0x003d0900

080029e8 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80029e8:	4770      	bx	lr
 80029ea:	bf00      	nop

080029ec <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 80029ec:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80029f0:	2b01      	cmp	r3, #1
 80029f2:	d001      	beq.n	80029f8 <HAL_TIM_Base_Start_IT+0xc>
  {
    return HAL_ERROR;
 80029f4:	2001      	movs	r0, #1
 80029f6:	4770      	bx	lr
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80029f8:	2202      	movs	r2, #2

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80029fa:	6803      	ldr	r3, [r0, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 80029fc:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002a00:	68da      	ldr	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002a02:	490c      	ldr	r1, [pc, #48]	; (8002a34 <HAL_TIM_Base_Start_IT+0x48>)
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002a04:	f042 0201 	orr.w	r2, r2, #1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002a08:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002a0a:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002a0c:	d00b      	beq.n	8002a26 <HAL_TIM_Base_Start_IT+0x3a>
 8002a0e:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002a12:	d008      	beq.n	8002a26 <HAL_TIM_Base_Start_IT+0x3a>
 8002a14:	4a08      	ldr	r2, [pc, #32]	; (8002a38 <HAL_TIM_Base_Start_IT+0x4c>)
 8002a16:	4293      	cmp	r3, r2
 8002a18:	d005      	beq.n	8002a26 <HAL_TIM_Base_Start_IT+0x3a>
      __HAL_TIM_ENABLE(htim);
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8002a1a:	681a      	ldr	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8002a1c:	2000      	movs	r0, #0
    __HAL_TIM_ENABLE(htim);
 8002a1e:	f042 0201 	orr.w	r2, r2, #1
 8002a22:	601a      	str	r2, [r3, #0]
 8002a24:	4770      	bx	lr
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002a26:	689a      	ldr	r2, [r3, #8]
 8002a28:	f002 0207 	and.w	r2, r2, #7
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002a2c:	2a06      	cmp	r2, #6
 8002a2e:	d1f4      	bne.n	8002a1a <HAL_TIM_Base_Start_IT+0x2e>
  return HAL_OK;
 8002a30:	2000      	movs	r0, #0
}
 8002a32:	4770      	bx	lr
 8002a34:	40012c00 	.word	0x40012c00
 8002a38:	40000400 	.word	0x40000400

08002a3c <HAL_TIM_OC_DelayElapsedCallback>:
 8002a3c:	4770      	bx	lr
 8002a3e:	bf00      	nop

08002a40 <HAL_TIM_IC_CaptureCallback>:
 8002a40:	4770      	bx	lr
 8002a42:	bf00      	nop

08002a44 <HAL_TIM_PWM_PulseFinishedCallback>:
 8002a44:	4770      	bx	lr
 8002a46:	bf00      	nop

08002a48 <HAL_TIM_TriggerCallback>:
 8002a48:	4770      	bx	lr
 8002a4a:	bf00      	nop

08002a4c <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002a4c:	6803      	ldr	r3, [r0, #0]
{
 8002a4e:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002a50:	691a      	ldr	r2, [r3, #16]
{
 8002a52:	4604      	mov	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002a54:	0791      	lsls	r1, r2, #30
 8002a56:	d502      	bpl.n	8002a5e <HAL_TIM_IRQHandler+0x12>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002a58:	68da      	ldr	r2, [r3, #12]
 8002a5a:	0792      	lsls	r2, r2, #30
 8002a5c:	d45f      	bmi.n	8002b1e <HAL_TIM_IRQHandler+0xd2>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8002a5e:	691a      	ldr	r2, [r3, #16]
 8002a60:	0750      	lsls	r0, r2, #29
 8002a62:	d502      	bpl.n	8002a6a <HAL_TIM_IRQHandler+0x1e>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002a64:	68da      	ldr	r2, [r3, #12]
 8002a66:	0751      	lsls	r1, r2, #29
 8002a68:	d446      	bmi.n	8002af8 <HAL_TIM_IRQHandler+0xac>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002a6a:	691a      	ldr	r2, [r3, #16]
 8002a6c:	0712      	lsls	r2, r2, #28
 8002a6e:	d502      	bpl.n	8002a76 <HAL_TIM_IRQHandler+0x2a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8002a70:	68da      	ldr	r2, [r3, #12]
 8002a72:	0710      	lsls	r0, r2, #28
 8002a74:	d42e      	bmi.n	8002ad4 <HAL_TIM_IRQHandler+0x88>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002a76:	691a      	ldr	r2, [r3, #16]
 8002a78:	06d2      	lsls	r2, r2, #27
 8002a7a:	d502      	bpl.n	8002a82 <HAL_TIM_IRQHandler+0x36>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8002a7c:	68da      	ldr	r2, [r3, #12]
 8002a7e:	06d0      	lsls	r0, r2, #27
 8002a80:	d418      	bmi.n	8002ab4 <HAL_TIM_IRQHandler+0x68>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8002a82:	691a      	ldr	r2, [r3, #16]
 8002a84:	07d1      	lsls	r1, r2, #31
 8002a86:	d502      	bpl.n	8002a8e <HAL_TIM_IRQHandler+0x42>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8002a88:	68da      	ldr	r2, [r3, #12]
 8002a8a:	07d2      	lsls	r2, r2, #31
 8002a8c:	d45d      	bmi.n	8002b4a <HAL_TIM_IRQHandler+0xfe>
      HAL_TIM_PeriodElapsedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8002a8e:	691a      	ldr	r2, [r3, #16]
 8002a90:	0610      	lsls	r0, r2, #24
 8002a92:	d502      	bpl.n	8002a9a <HAL_TIM_IRQHandler+0x4e>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8002a94:	68da      	ldr	r2, [r3, #12]
 8002a96:	0611      	lsls	r1, r2, #24
 8002a98:	d45f      	bmi.n	8002b5a <HAL_TIM_IRQHandler+0x10e>
      HAL_TIMEx_BreakCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8002a9a:	691a      	ldr	r2, [r3, #16]
 8002a9c:	0652      	lsls	r2, r2, #25
 8002a9e:	d502      	bpl.n	8002aa6 <HAL_TIM_IRQHandler+0x5a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8002aa0:	68da      	ldr	r2, [r3, #12]
 8002aa2:	0650      	lsls	r0, r2, #25
 8002aa4:	d461      	bmi.n	8002b6a <HAL_TIM_IRQHandler+0x11e>
      HAL_TIM_TriggerCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8002aa6:	691a      	ldr	r2, [r3, #16]
 8002aa8:	0691      	lsls	r1, r2, #26
 8002aaa:	d502      	bpl.n	8002ab2 <HAL_TIM_IRQHandler+0x66>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8002aac:	68da      	ldr	r2, [r3, #12]
 8002aae:	0692      	lsls	r2, r2, #26
 8002ab0:	d443      	bmi.n	8002b3a <HAL_TIM_IRQHandler+0xee>
#else
      HAL_TIMEx_CommutCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8002ab2:	bd10      	pop	{r4, pc}
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002ab4:	f06f 0110 	mvn.w	r1, #16
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002ab8:	2208      	movs	r2, #8
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002aba:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002abc:	69db      	ldr	r3, [r3, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8002abe:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002ac0:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002ac4:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002ac6:	d064      	beq.n	8002b92 <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8002ac8:	f7ff ffba 	bl	8002a40 <HAL_TIM_IC_CaptureCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002acc:	2200      	movs	r2, #0
 8002ace:	6823      	ldr	r3, [r4, #0]
 8002ad0:	7722      	strb	r2, [r4, #28]
 8002ad2:	e7d6      	b.n	8002a82 <HAL_TIM_IRQHandler+0x36>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002ad4:	f06f 0108 	mvn.w	r1, #8
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002ad8:	2204      	movs	r2, #4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002ada:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002adc:	69db      	ldr	r3, [r3, #28]
        HAL_TIM_IC_CaptureCallback(htim);
 8002ade:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002ae0:	0799      	lsls	r1, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002ae2:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002ae4:	d152      	bne.n	8002b8c <HAL_TIM_IRQHandler+0x140>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002ae6:	f7ff ffa9 	bl	8002a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002aea:	4620      	mov	r0, r4
 8002aec:	f7ff ffaa 	bl	8002a44 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002af0:	2200      	movs	r2, #0
 8002af2:	6823      	ldr	r3, [r4, #0]
 8002af4:	7722      	strb	r2, [r4, #28]
 8002af6:	e7be      	b.n	8002a76 <HAL_TIM_IRQHandler+0x2a>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8002af8:	f06f 0104 	mvn.w	r1, #4
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002afc:	2202      	movs	r2, #2
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8002afe:	6119      	str	r1, [r3, #16]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002b00:	699b      	ldr	r3, [r3, #24]
        HAL_TIM_IC_CaptureCallback(htim);
 8002b02:	4620      	mov	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002b04:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002b08:	7722      	strb	r2, [r4, #28]
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002b0a:	d13c      	bne.n	8002b86 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002b0c:	f7ff ff96 	bl	8002a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002b10:	4620      	mov	r0, r4
 8002b12:	f7ff ff97 	bl	8002a44 <HAL_TIM_PWM_PulseFinishedCallback>
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002b16:	2200      	movs	r2, #0
 8002b18:	6823      	ldr	r3, [r4, #0]
 8002b1a:	7722      	strb	r2, [r4, #28]
 8002b1c:	e7a5      	b.n	8002a6a <HAL_TIM_IRQHandler+0x1e>
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002b1e:	f06f 0102 	mvn.w	r1, #2
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002b22:	2201      	movs	r2, #1
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002b24:	6119      	str	r1, [r3, #16]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002b26:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002b28:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002b2a:	079b      	lsls	r3, r3, #30
 8002b2c:	d025      	beq.n	8002b7a <HAL_TIM_IRQHandler+0x12e>
          HAL_TIM_IC_CaptureCallback(htim);
 8002b2e:	f7ff ff87 	bl	8002a40 <HAL_TIM_IC_CaptureCallback>
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002b32:	2200      	movs	r2, #0
 8002b34:	6823      	ldr	r3, [r4, #0]
 8002b36:	7722      	strb	r2, [r4, #28]
 8002b38:	e791      	b.n	8002a5e <HAL_TIM_IRQHandler+0x12>
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8002b3a:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutCallback(htim);
 8002b3e:	4620      	mov	r0, r4
}
 8002b40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8002b44:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutCallback(htim);
 8002b46:	f000 b891 	b.w	8002c6c <HAL_TIMEx_CommutCallback>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8002b4a:	f06f 0201 	mvn.w	r2, #1
      HAL_TIM_PeriodElapsedCallback(htim);
 8002b4e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8002b50:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8002b52:	f7fe fab3 	bl	80010bc <HAL_TIM_PeriodElapsedCallback>
 8002b56:	6823      	ldr	r3, [r4, #0]
 8002b58:	e799      	b.n	8002a8e <HAL_TIM_IRQHandler+0x42>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8002b5a:	f06f 0280 	mvn.w	r2, #128	; 0x80
      HAL_TIMEx_BreakCallback(htim);
 8002b5e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8002b60:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8002b62:	f000 f885 	bl	8002c70 <HAL_TIMEx_BreakCallback>
 8002b66:	6823      	ldr	r3, [r4, #0]
 8002b68:	e797      	b.n	8002a9a <HAL_TIM_IRQHandler+0x4e>
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8002b6a:	f06f 0240 	mvn.w	r2, #64	; 0x40
      HAL_TIM_TriggerCallback(htim);
 8002b6e:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8002b70:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8002b72:	f7ff ff69 	bl	8002a48 <HAL_TIM_TriggerCallback>
 8002b76:	6823      	ldr	r3, [r4, #0]
 8002b78:	e795      	b.n	8002aa6 <HAL_TIM_IRQHandler+0x5a>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8002b7a:	f7ff ff5f 	bl	8002a3c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002b7e:	4620      	mov	r0, r4
 8002b80:	f7ff ff60 	bl	8002a44 <HAL_TIM_PWM_PulseFinishedCallback>
 8002b84:	e7d5      	b.n	8002b32 <HAL_TIM_IRQHandler+0xe6>
        HAL_TIM_IC_CaptureCallback(htim);
 8002b86:	f7ff ff5b 	bl	8002a40 <HAL_TIM_IC_CaptureCallback>
 8002b8a:	e7c4      	b.n	8002b16 <HAL_TIM_IRQHandler+0xca>
        HAL_TIM_IC_CaptureCallback(htim);
 8002b8c:	f7ff ff58 	bl	8002a40 <HAL_TIM_IC_CaptureCallback>
 8002b90:	e7ae      	b.n	8002af0 <HAL_TIM_IRQHandler+0xa4>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002b92:	f7ff ff53 	bl	8002a3c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002b96:	4620      	mov	r0, r4
 8002b98:	f7ff ff54 	bl	8002a44 <HAL_TIM_PWM_PulseFinishedCallback>
 8002b9c:	e796      	b.n	8002acc <HAL_TIM_IRQHandler+0x80>
 8002b9e:	bf00      	nop

08002ba0 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 8002ba0:	b470      	push	{r4, r5, r6}
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002ba2:	4e1a      	ldr	r6, [pc, #104]	; (8002c0c <TIM_Base_SetConfig+0x6c>)
  tmpcr1 = TIMx->CR1;
 8002ba4:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002ba6:	42b0      	cmp	r0, r6
 8002ba8:	694d      	ldr	r5, [r1, #20]
 8002baa:	688c      	ldr	r4, [r1, #8]
 8002bac:	680a      	ldr	r2, [r1, #0]
 8002bae:	d019      	beq.n	8002be4 <TIM_Base_SetConfig+0x44>
 8002bb0:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8002bb4:	d00d      	beq.n	8002bd2 <TIM_Base_SetConfig+0x32>
 8002bb6:	f5a6 3694 	sub.w	r6, r6, #75776	; 0x12800
 8002bba:	42b0      	cmp	r0, r6
 8002bbc:	d009      	beq.n	8002bd2 <TIM_Base_SetConfig+0x32>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002bbe:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002bc2:	432b      	orrs	r3, r5

  TIMx->CR1 = tmpcr1;
 8002bc4:	6003      	str	r3, [r0, #0]
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002bc6:	2301      	movs	r3, #1
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002bc8:	62c4      	str	r4, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002bca:	6282      	str	r2, [r0, #40]	; 0x28
}
 8002bcc:	bc70      	pop	{r4, r5, r6}
  TIMx->EGR = TIM_EGR_UG;
 8002bce:	6143      	str	r3, [r0, #20]
}
 8002bd0:	4770      	bx	lr
    tmpcr1 |= Structure->CounterMode;
 8002bd2:	684e      	ldr	r6, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002bd4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002bd8:	4333      	orrs	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002bda:	68c9      	ldr	r1, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8002bdc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002be0:	430b      	orrs	r3, r1
 8002be2:	e7ec      	b.n	8002bbe <TIM_Base_SetConfig+0x1e>
    tmpcr1 |= Structure->CounterMode;
 8002be4:	684e      	ldr	r6, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002be6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8002bea:	4333      	orrs	r3, r6
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002bec:	68ce      	ldr	r6, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8002bee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002bf2:	4333      	orrs	r3, r6
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002bf4:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8002bf8:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8002bfa:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002bfc:	62c4      	str	r4, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002bfe:	6282      	str	r2, [r0, #40]	; 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8002c00:	690b      	ldr	r3, [r1, #16]
}
 8002c02:	bc70      	pop	{r4, r5, r6}
    TIMx->RCR = Structure->RepetitionCounter;
 8002c04:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8002c06:	2301      	movs	r3, #1
 8002c08:	6143      	str	r3, [r0, #20]
}
 8002c0a:	4770      	bx	lr
 8002c0c:	40012c00 	.word	0x40012c00

08002c10 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8002c10:	b348      	cbz	r0, 8002c66 <HAL_TIM_Base_Init+0x56>
  if (htim->State == HAL_TIM_STATE_RESET)
 8002c12:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
{
 8002c16:	b510      	push	{r4, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8002c18:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002c1c:	4604      	mov	r4, r0
 8002c1e:	b1eb      	cbz	r3, 8002c5c <HAL_TIM_Base_Init+0x4c>
  htim->State = HAL_TIM_STATE_BUSY;
 8002c20:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002c22:	6820      	ldr	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002c24:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002c28:	1d21      	adds	r1, r4, #4
 8002c2a:	f7ff ffb9 	bl	8002ba0 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8002c2e:	2301      	movs	r3, #1
  return HAL_OK;
 8002c30:	2000      	movs	r0, #0
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8002c32:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002c36:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
 8002c3a:	f884 303f 	strb.w	r3, [r4, #63]	; 0x3f
 8002c3e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8002c42:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002c46:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8002c4a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8002c4e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
 8002c52:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  htim->State = HAL_TIM_STATE_READY;
 8002c56:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 8002c5a:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 8002c5c:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8002c60:	f7ff fec2 	bl	80029e8 <HAL_TIM_Base_MspInit>
 8002c64:	e7dc      	b.n	8002c20 <HAL_TIM_Base_Init+0x10>
    return HAL_ERROR;
 8002c66:	2001      	movs	r0, #1
}
 8002c68:	4770      	bx	lr
 8002c6a:	bf00      	nop

08002c6c <HAL_TIMEx_CommutCallback>:
 8002c6c:	4770      	bx	lr
 8002c6e:	bf00      	nop

08002c70 <HAL_TIMEx_BreakCallback>:
 8002c70:	4770      	bx	lr
 8002c72:	bf00      	nop

08002c74 <UART_SetConfig>:
  * @param  huart  Pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 8002c74:	b538      	push	{r3, r4, r5, lr}
 8002c76:	4604      	mov	r4, r0
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits
     according to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002c78:	6803      	ldr	r3, [r0, #0]
 8002c7a:	68c0      	ldr	r0, [r0, #12]
 8002c7c:	6919      	ldr	r1, [r3, #16]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
  MODIFY_REG(huart->Instance->CR1,
             (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
             tmpreg);
#else
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002c7e:	68a2      	ldr	r2, [r4, #8]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002c80:	f421 5140 	bic.w	r1, r1, #12288	; 0x3000
 8002c84:	4301      	orrs	r1, r0
 8002c86:	6119      	str	r1, [r3, #16]
  MODIFY_REG(huart->Instance->CR1,
 8002c88:	68d9      	ldr	r1, [r3, #12]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002c8a:	e9d4 5004 	ldrd	r5, r0, [r4, #16]
  MODIFY_REG(huart->Instance->CR1,
 8002c8e:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002c92:	432a      	orrs	r2, r5
  MODIFY_REG(huart->Instance->CR1,
 8002c94:	f021 010c 	bic.w	r1, r1, #12
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
 8002c98:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1,
 8002c9a:	430a      	orrs	r2, r1
 8002c9c:	60da      	str	r2, [r3, #12]
             tmpreg);
#endif /* USART_CR1_OVER8 */

  /*-------------------------- USART CR3 Configuration -----------------------*/
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002c9e:	695a      	ldr	r2, [r3, #20]
 8002ca0:	69a0      	ldr	r0, [r4, #24]


  if(huart->Instance == USART1)
 8002ca2:	4912      	ldr	r1, [pc, #72]	; (8002cec <UART_SetConfig+0x78>)
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002ca4:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002ca8:	4302      	orrs	r2, r0
  if(huart->Instance == USART1)
 8002caa:	428b      	cmp	r3, r1
  MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
 8002cac:	615a      	str	r2, [r3, #20]
  if(huart->Instance == USART1)
 8002cae:	d01a      	beq.n	8002ce6 <UART_SetConfig+0x72>
  {
    pclk = HAL_RCC_GetPCLK2Freq();
  }
  else
  {
    pclk = HAL_RCC_GetPCLK1Freq();
 8002cb0:	f7ff fd60 	bl	8002774 <HAL_RCC_GetPCLK1Freq>
  else
  {
    huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
  }
#else
  huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
 8002cb4:	6863      	ldr	r3, [r4, #4]
 8002cb6:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002cba:	009b      	lsls	r3, r3, #2
 8002cbc:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8002cc0:	fbb0 f0f3 	udiv	r0, r0, r3
 8002cc4:	2364      	movs	r3, #100	; 0x64
 8002cc6:	490a      	ldr	r1, [pc, #40]	; (8002cf0 <UART_SetConfig+0x7c>)
 8002cc8:	6824      	ldr	r4, [r4, #0]
 8002cca:	fba1 5200 	umull	r5, r2, r1, r0
 8002cce:	0952      	lsrs	r2, r2, #5
 8002cd0:	fb03 0012 	mls	r0, r3, r2, r0
 8002cd4:	0100      	lsls	r0, r0, #4
 8002cd6:	3032      	adds	r0, #50	; 0x32
 8002cd8:	fba1 3000 	umull	r3, r0, r1, r0
 8002cdc:	0112      	lsls	r2, r2, #4
 8002cde:	eb02 1050 	add.w	r0, r2, r0, lsr #5
 8002ce2:	60a0      	str	r0, [r4, #8]
#endif /* USART_CR1_OVER8 */
}
 8002ce4:	bd38      	pop	{r3, r4, r5, pc}
    pclk = HAL_RCC_GetPCLK2Freq();
 8002ce6:	f7ff fd55 	bl	8002794 <HAL_RCC_GetPCLK2Freq>
 8002cea:	e7e3      	b.n	8002cb4 <UART_SetConfig+0x40>
 8002cec:	40013800 	.word	0x40013800
 8002cf0:	51eb851f 	.word	0x51eb851f

08002cf4 <UART_WaitOnFlagUntilTimeout.constprop.3>:
static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
 8002cf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002cf8:	4607      	mov	r7, r0
 8002cfa:	460e      	mov	r6, r1
 8002cfc:	4690      	mov	r8, r2
 8002cfe:	461d      	mov	r5, r3
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8002d00:	683c      	ldr	r4, [r7, #0]
 8002d02:	e001      	b.n	8002d08 <UART_WaitOnFlagUntilTimeout.constprop.3+0x14>
    if (Timeout != HAL_MAX_DELAY)
 8002d04:	1c6b      	adds	r3, r5, #1
 8002d06:	d106      	bne.n	8002d16 <UART_WaitOnFlagUntilTimeout.constprop.3+0x22>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8002d08:	6820      	ldr	r0, [r4, #0]
 8002d0a:	ea36 0300 	bics.w	r3, r6, r0
 8002d0e:	d1f9      	bne.n	8002d04 <UART_WaitOnFlagUntilTimeout.constprop.3+0x10>
  return HAL_OK;
 8002d10:	2000      	movs	r0, #0
}
 8002d12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8002d16:	b135      	cbz	r5, 8002d26 <UART_WaitOnFlagUntilTimeout.constprop.3+0x32>
 8002d18:	f7fe fbf2 	bl	8001500 <HAL_GetTick>
 8002d1c:	eba0 0008 	sub.w	r0, r0, r8
 8002d20:	4285      	cmp	r5, r0
 8002d22:	d2ed      	bcs.n	8002d00 <UART_WaitOnFlagUntilTimeout.constprop.3+0xc>
 8002d24:	683c      	ldr	r4, [r7, #0]
        huart->gState  = HAL_UART_STATE_READY;
 8002d26:	2220      	movs	r2, #32
        __HAL_UNLOCK(huart);
 8002d28:	2100      	movs	r1, #0
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8002d2a:	68e3      	ldr	r3, [r4, #12]
        __HAL_UNLOCK(huart);
 8002d2c:	2003      	movs	r0, #3
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8002d2e:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8002d32:	60e3      	str	r3, [r4, #12]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8002d34:	6963      	ldr	r3, [r4, #20]
 8002d36:	f023 0301 	bic.w	r3, r3, #1
 8002d3a:	6163      	str	r3, [r4, #20]
        huart->gState  = HAL_UART_STATE_READY;
 8002d3c:	f887 2039 	strb.w	r2, [r7, #57]	; 0x39
        __HAL_UNLOCK(huart);
 8002d40:	f887 1038 	strb.w	r1, [r7, #56]	; 0x38
        huart->RxState = HAL_UART_STATE_READY;
 8002d44:	f887 203a 	strb.w	r2, [r7, #58]	; 0x3a
 8002d48:	e7e3      	b.n	8002d12 <UART_WaitOnFlagUntilTimeout.constprop.3+0x1e>
 8002d4a:	bf00      	nop

08002d4c <HAL_UART_Init>:
  if (huart == NULL)
 8002d4c:	b360      	cbz	r0, 8002da8 <HAL_UART_Init+0x5c>
{
 8002d4e:	b538      	push	{r3, r4, r5, lr}
  if (huart->gState == HAL_UART_STATE_RESET)
 8002d50:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8002d54:	4604      	mov	r4, r0
 8002d56:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8002d5a:	b303      	cbz	r3, 8002d9e <HAL_UART_Init+0x52>
  huart->gState = HAL_UART_STATE_BUSY;
 8002d5c:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 8002d5e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8002d60:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  __HAL_UART_DISABLE(huart);
 8002d64:	68d3      	ldr	r3, [r2, #12]
  UART_SetConfig(huart);
 8002d66:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 8002d68:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002d6c:	60d3      	str	r3, [r2, #12]
  UART_SetConfig(huart);
 8002d6e:	f7ff ff81 	bl	8002c74 <UART_SetConfig>
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002d72:	2500      	movs	r5, #0
  huart->gState = HAL_UART_STATE_READY;
 8002d74:	2120      	movs	r1, #32
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002d76:	6823      	ldr	r3, [r4, #0]
  return HAL_OK;
 8002d78:	4628      	mov	r0, r5
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8002d7a:	691a      	ldr	r2, [r3, #16]
 8002d7c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8002d80:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8002d82:	695a      	ldr	r2, [r3, #20]
 8002d84:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8002d88:	615a      	str	r2, [r3, #20]
  __HAL_UART_ENABLE(huart);
 8002d8a:	68da      	ldr	r2, [r3, #12]
 8002d8c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8002d90:	60da      	str	r2, [r3, #12]
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002d92:	63e5      	str	r5, [r4, #60]	; 0x3c
  huart->gState = HAL_UART_STATE_READY;
 8002d94:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  huart->RxState = HAL_UART_STATE_READY;
 8002d98:	f884 103a 	strb.w	r1, [r4, #58]	; 0x3a
}
 8002d9c:	bd38      	pop	{r3, r4, r5, pc}
    huart->Lock = HAL_UNLOCKED;
 8002d9e:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    HAL_UART_MspInit(huart);
 8002da2:	f7fe fa63 	bl	800126c <HAL_UART_MspInit>
 8002da6:	e7d9      	b.n	8002d5c <HAL_UART_Init+0x10>
    return HAL_ERROR;
 8002da8:	2001      	movs	r0, #1
}
 8002daa:	4770      	bx	lr

08002dac <HAL_UART_Transmit>:
{
 8002dac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002db0:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 8002db2:	f890 0039 	ldrb.w	r0, [r0, #57]	; 0x39
{
 8002db6:	b082      	sub	sp, #8
  if (huart->gState == HAL_UART_STATE_READY)
 8002db8:	2820      	cmp	r0, #32
 8002dba:	d13f      	bne.n	8002e3c <HAL_UART_Transmit+0x90>
 8002dbc:	460d      	mov	r5, r1
    if ((pData == NULL) || (Size == 0U))
 8002dbe:	2900      	cmp	r1, #0
 8002dc0:	d040      	beq.n	8002e44 <HAL_UART_Transmit+0x98>
 8002dc2:	9201      	str	r2, [sp, #4]
 8002dc4:	2a00      	cmp	r2, #0
 8002dc6:	d03d      	beq.n	8002e44 <HAL_UART_Transmit+0x98>
 8002dc8:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
 8002dca:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8002dce:	2b01      	cmp	r3, #1
 8002dd0:	d034      	beq.n	8002e3c <HAL_UART_Transmit+0x90>
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002dd2:	2321      	movs	r3, #33	; 0x21
    __HAL_LOCK(huart);
 8002dd4:	2101      	movs	r1, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002dd6:	f04f 0800 	mov.w	r8, #0
    __HAL_LOCK(huart);
 8002dda:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002dde:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8002de2:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    tickstart = HAL_GetTick();
 8002de6:	f7fe fb8b 	bl	8001500 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002dea:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize = Size;
 8002dec:	9a01      	ldr	r2, [sp, #4]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002dee:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 8002df2:	4607      	mov	r7, r0
    huart->TxXferSize = Size;
 8002df4:	84a2      	strh	r2, [r4, #36]	; 0x24
    huart->TxXferCount = Size;
 8002df6:	84e2      	strh	r2, [r4, #38]	; 0x26
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002df8:	d036      	beq.n	8002e68 <HAL_UART_Transmit+0xbc>
    __HAL_UNLOCK(huart);
 8002dfa:	2200      	movs	r2, #0
    while (huart->TxXferCount > 0U)
 8002dfc:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    __HAL_UNLOCK(huart);
 8002dfe:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    while (huart->TxXferCount > 0U)
 8002e02:	b29b      	uxth	r3, r3
 8002e04:	b953      	cbnz	r3, 8002e1c <HAL_UART_Transmit+0x70>
 8002e06:	e023      	b.n	8002e50 <HAL_UART_Transmit+0xa4>
        huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
 8002e08:	f815 2b01 	ldrb.w	r2, [r5], #1
 8002e0c:	605a      	str	r2, [r3, #4]
      huart->TxXferCount--;
 8002e0e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8002e10:	3b01      	subs	r3, #1
 8002e12:	b29b      	uxth	r3, r3
 8002e14:	84e3      	strh	r3, [r4, #38]	; 0x26
    while (huart->TxXferCount > 0U)
 8002e16:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 8002e18:	b29b      	uxth	r3, r3
 8002e1a:	b1cb      	cbz	r3, 8002e50 <HAL_UART_Transmit+0xa4>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8002e1c:	4633      	mov	r3, r6
 8002e1e:	463a      	mov	r2, r7
 8002e20:	2180      	movs	r1, #128	; 0x80
 8002e22:	4620      	mov	r0, r4
 8002e24:	f7ff ff66 	bl	8002cf4 <UART_WaitOnFlagUntilTimeout.constprop.3>
 8002e28:	b980      	cbnz	r0, 8002e4c <HAL_UART_Transmit+0xa0>
 8002e2a:	6823      	ldr	r3, [r4, #0]
      if (pdata8bits == NULL)
 8002e2c:	2d00      	cmp	r5, #0
 8002e2e:	d1eb      	bne.n	8002e08 <HAL_UART_Transmit+0x5c>
        huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
 8002e30:	f838 2b02 	ldrh.w	r2, [r8], #2
 8002e34:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002e38:	605a      	str	r2, [r3, #4]
 8002e3a:	e7e8      	b.n	8002e0e <HAL_UART_Transmit+0x62>
    return HAL_BUSY;
 8002e3c:	2002      	movs	r0, #2
}
 8002e3e:	b002      	add	sp, #8
 8002e40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 8002e44:	2001      	movs	r0, #1
}
 8002e46:	b002      	add	sp, #8
 8002e48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return HAL_TIMEOUT;
 8002e4c:	2003      	movs	r0, #3
 8002e4e:	e7f6      	b.n	8002e3e <HAL_UART_Transmit+0x92>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8002e50:	4633      	mov	r3, r6
 8002e52:	463a      	mov	r2, r7
 8002e54:	2140      	movs	r1, #64	; 0x40
 8002e56:	4620      	mov	r0, r4
 8002e58:	f7ff ff4c 	bl	8002cf4 <UART_WaitOnFlagUntilTimeout.constprop.3>
 8002e5c:	2800      	cmp	r0, #0
 8002e5e:	d1f5      	bne.n	8002e4c <HAL_UART_Transmit+0xa0>
    huart->gState = HAL_UART_STATE_READY;
 8002e60:	2320      	movs	r3, #32
 8002e62:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    return HAL_OK;
 8002e66:	e7ea      	b.n	8002e3e <HAL_UART_Transmit+0x92>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002e68:	6923      	ldr	r3, [r4, #16]
 8002e6a:	2b00      	cmp	r3, #0
 8002e6c:	d1c5      	bne.n	8002dfa <HAL_UART_Transmit+0x4e>
 8002e6e:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 8002e70:	461d      	mov	r5, r3
 8002e72:	e7c2      	b.n	8002dfa <HAL_UART_Transmit+0x4e>

08002e74 <HAL_UART_Receive>:
{
 8002e74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002e78:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 8002e7a:	f890 003a 	ldrb.w	r0, [r0, #58]	; 0x3a
{
 8002e7e:	b082      	sub	sp, #8
  if (huart->RxState == HAL_UART_STATE_READY)
 8002e80:	2820      	cmp	r0, #32
 8002e82:	d146      	bne.n	8002f12 <HAL_UART_Receive+0x9e>
 8002e84:	460d      	mov	r5, r1
    if ((pData == NULL) || (Size == 0U))
 8002e86:	2900      	cmp	r1, #0
 8002e88:	d047      	beq.n	8002f1a <HAL_UART_Receive+0xa6>
 8002e8a:	9201      	str	r2, [sp, #4]
 8002e8c:	2a00      	cmp	r2, #0
 8002e8e:	d044      	beq.n	8002f1a <HAL_UART_Receive+0xa6>
 8002e90:	461e      	mov	r6, r3
    __HAL_LOCK(huart);
 8002e92:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8002e96:	2b01      	cmp	r3, #1
 8002e98:	d03b      	beq.n	8002f12 <HAL_UART_Receive+0x9e>
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002e9a:	2322      	movs	r3, #34	; 0x22
    __HAL_LOCK(huart);
 8002e9c:	2101      	movs	r1, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002e9e:	f04f 0800 	mov.w	r8, #0
    __HAL_LOCK(huart);
 8002ea2:	f884 1038 	strb.w	r1, [r4, #56]	; 0x38
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8002ea6:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8002eaa:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
    tickstart = HAL_GetTick();
 8002eae:	f7fe fb27 	bl	8001500 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002eb2:	68a3      	ldr	r3, [r4, #8]
    huart->RxXferSize = Size;
 8002eb4:	9a01      	ldr	r2, [sp, #4]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002eb6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 8002eba:	4607      	mov	r7, r0
    huart->RxXferSize = Size;
 8002ebc:	85a2      	strh	r2, [r4, #44]	; 0x2c
    huart->RxXferCount = Size;
 8002ebe:	85e2      	strh	r2, [r4, #46]	; 0x2e
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002ec0:	d03b      	beq.n	8002f3a <HAL_UART_Receive+0xc6>
    __HAL_UNLOCK(huart);
 8002ec2:	2200      	movs	r2, #0
    while (huart->RxXferCount > 0U)
 8002ec4:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
    __HAL_UNLOCK(huart);
 8002ec6:	f884 2038 	strb.w	r2, [r4, #56]	; 0x38
    while (huart->RxXferCount > 0U)
 8002eca:	b29b      	uxth	r3, r3
 8002ecc:	b98b      	cbnz	r3, 8002ef2 <HAL_UART_Receive+0x7e>
 8002ece:	e02d      	b.n	8002f2c <HAL_UART_Receive+0xb8>
        if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8002ed0:	68a2      	ldr	r2, [r4, #8]
 8002ed2:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8002ed6:	d002      	beq.n	8002ede <HAL_UART_Receive+0x6a>
 8002ed8:	bb1a      	cbnz	r2, 8002f22 <HAL_UART_Receive+0xae>
 8002eda:	6922      	ldr	r2, [r4, #16]
 8002edc:	bb0a      	cbnz	r2, 8002f22 <HAL_UART_Receive+0xae>
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8002ede:	685b      	ldr	r3, [r3, #4]
 8002ee0:	702b      	strb	r3, [r5, #0]
        pdata8bits++;
 8002ee2:	3501      	adds	r5, #1
      huart->RxXferCount--;
 8002ee4:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8002ee6:	3b01      	subs	r3, #1
 8002ee8:	b29b      	uxth	r3, r3
 8002eea:	85e3      	strh	r3, [r4, #46]	; 0x2e
    while (huart->RxXferCount > 0U)
 8002eec:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 8002eee:	b29b      	uxth	r3, r3
 8002ef0:	b1e3      	cbz	r3, 8002f2c <HAL_UART_Receive+0xb8>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8002ef2:	4633      	mov	r3, r6
 8002ef4:	463a      	mov	r2, r7
 8002ef6:	2120      	movs	r1, #32
 8002ef8:	4620      	mov	r0, r4
 8002efa:	f7ff fefb 	bl	8002cf4 <UART_WaitOnFlagUntilTimeout.constprop.3>
 8002efe:	b9d0      	cbnz	r0, 8002f36 <HAL_UART_Receive+0xc2>
 8002f00:	6823      	ldr	r3, [r4, #0]
      if (pdata8bits == NULL)
 8002f02:	2d00      	cmp	r5, #0
 8002f04:	d1e4      	bne.n	8002ed0 <HAL_UART_Receive+0x5c>
        *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
 8002f06:	685b      	ldr	r3, [r3, #4]
 8002f08:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8002f0c:	f828 3b02 	strh.w	r3, [r8], #2
 8002f10:	e7e8      	b.n	8002ee4 <HAL_UART_Receive+0x70>
    return HAL_BUSY;
 8002f12:	2002      	movs	r0, #2
}
 8002f14:	b002      	add	sp, #8
 8002f16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      return  HAL_ERROR;
 8002f1a:	2001      	movs	r0, #1
}
 8002f1c:	b002      	add	sp, #8
 8002f1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8002f22:	685b      	ldr	r3, [r3, #4]
 8002f24:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8002f28:	702b      	strb	r3, [r5, #0]
 8002f2a:	e7da      	b.n	8002ee2 <HAL_UART_Receive+0x6e>
    huart->RxState = HAL_UART_STATE_READY;
 8002f2c:	2320      	movs	r3, #32
    return HAL_OK;
 8002f2e:	2000      	movs	r0, #0
    huart->RxState = HAL_UART_STATE_READY;
 8002f30:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
    return HAL_OK;
 8002f34:	e7ee      	b.n	8002f14 <HAL_UART_Receive+0xa0>
        return HAL_TIMEOUT;
 8002f36:	2003      	movs	r0, #3
 8002f38:	e7ec      	b.n	8002f14 <HAL_UART_Receive+0xa0>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002f3a:	6923      	ldr	r3, [r4, #16]
 8002f3c:	2b00      	cmp	r3, #0
 8002f3e:	d1c0      	bne.n	8002ec2 <HAL_UART_Receive+0x4e>
 8002f40:	46a8      	mov	r8, r5
      pdata8bits  = NULL;
 8002f42:	461d      	mov	r5, r3
 8002f44:	e7bd      	b.n	8002ec2 <HAL_UART_Receive+0x4e>
 8002f46:	bf00      	nop

08002f48 <HAL_UART_TxCpltCallback>:
 8002f48:	4770      	bx	lr
 8002f4a:	bf00      	nop

08002f4c <HAL_UART_RxCpltCallback>:
 8002f4c:	4770      	bx	lr
 8002f4e:	bf00      	nop

08002f50 <UART_Receive_IT.part.1>:
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002f50:	6882      	ldr	r2, [r0, #8]
 8002f52:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f54:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8002f58:	6801      	ldr	r1, [r0, #0]
 8002f5a:	d029      	beq.n	8002fb0 <UART_Receive_IT.part.1+0x60>
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8002f5c:	b16a      	cbz	r2, 8002f7a <UART_Receive_IT.part.1+0x2a>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
 8002f5e:	684a      	ldr	r2, [r1, #4]
 8002f60:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8002f64:	701a      	strb	r2, [r3, #0]
      huart->pRxBuffPtr += 1U;
 8002f66:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f68:	3301      	adds	r3, #1
 8002f6a:	6283      	str	r3, [r0, #40]	; 0x28
    if (--huart->RxXferCount == 0U)
 8002f6c:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 8002f6e:	3b01      	subs	r3, #1
 8002f70:	b29b      	uxth	r3, r3
 8002f72:	85c3      	strh	r3, [r0, #46]	; 0x2e
 8002f74:	b13b      	cbz	r3, 8002f86 <UART_Receive_IT.part.1+0x36>
}
 8002f76:	2000      	movs	r0, #0
 8002f78:	4770      	bx	lr
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
 8002f7a:	6902      	ldr	r2, [r0, #16]
 8002f7c:	2a00      	cmp	r2, #0
 8002f7e:	d1ee      	bne.n	8002f5e <UART_Receive_IT.part.1+0xe>
        *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
 8002f80:	684a      	ldr	r2, [r1, #4]
 8002f82:	701a      	strb	r2, [r3, #0]
 8002f84:	e7ef      	b.n	8002f66 <UART_Receive_IT.part.1+0x16>
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
 8002f86:	b510      	push	{r4, lr}
      huart->RxState = HAL_UART_STATE_READY;
 8002f88:	2420      	movs	r4, #32
      __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
 8002f8a:	6803      	ldr	r3, [r0, #0]
 8002f8c:	68d9      	ldr	r1, [r3, #12]
 8002f8e:	f021 0120 	bic.w	r1, r1, #32
 8002f92:	60d9      	str	r1, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
 8002f94:	68d9      	ldr	r1, [r3, #12]
 8002f96:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 8002f9a:	60d9      	str	r1, [r3, #12]
      __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
 8002f9c:	6959      	ldr	r1, [r3, #20]
 8002f9e:	f021 0101 	bic.w	r1, r1, #1
 8002fa2:	6159      	str	r1, [r3, #20]
      huart->RxState = HAL_UART_STATE_READY;
 8002fa4:	f880 403a 	strb.w	r4, [r0, #58]	; 0x3a
      HAL_UART_RxCpltCallback(huart);
 8002fa8:	f7ff ffd0 	bl	8002f4c <HAL_UART_RxCpltCallback>
}
 8002fac:	2000      	movs	r0, #0
 8002fae:	bd10      	pop	{r4, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8002fb0:	6902      	ldr	r2, [r0, #16]
 8002fb2:	2a00      	cmp	r2, #0
 8002fb4:	d1e4      	bne.n	8002f80 <UART_Receive_IT.part.1+0x30>
      *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
 8002fb6:	684a      	ldr	r2, [r1, #4]
 8002fb8:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8002fbc:	f823 2b02 	strh.w	r2, [r3], #2
      huart->pRxBuffPtr += 2U;
 8002fc0:	6283      	str	r3, [r0, #40]	; 0x28
 8002fc2:	e7d3      	b.n	8002f6c <UART_Receive_IT.part.1+0x1c>

08002fc4 <HAL_UART_ErrorCallback>:
 8002fc4:	4770      	bx	lr
 8002fc6:	bf00      	nop

08002fc8 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8002fc8:	6803      	ldr	r3, [r0, #0]
{
 8002fca:	b570      	push	{r4, r5, r6, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8002fcc:	681a      	ldr	r2, [r3, #0]
{
 8002fce:	4604      	mov	r4, r0
  if (errorflags == RESET)
 8002fd0:	0716      	lsls	r6, r2, #28
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8002fd2:	68dd      	ldr	r5, [r3, #12]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8002fd4:	6959      	ldr	r1, [r3, #20]
  if (errorflags == RESET)
 8002fd6:	d048      	beq.n	800306a <HAL_UART_IRQHandler+0xa2>
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8002fd8:	f011 0101 	ands.w	r1, r1, #1
 8002fdc:	461e      	mov	r6, r3
 8002fde:	d04d      	beq.n	800307c <HAL_UART_IRQHandler+0xb4>
    if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8002fe0:	07d3      	lsls	r3, r2, #31
 8002fe2:	d505      	bpl.n	8002ff0 <HAL_UART_IRQHandler+0x28>
 8002fe4:	05e8      	lsls	r0, r5, #23
 8002fe6:	d503      	bpl.n	8002ff0 <HAL_UART_IRQHandler+0x28>
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8002fe8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002fea:	f043 0301 	orr.w	r3, r3, #1
 8002fee:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002ff0:	0753      	lsls	r3, r2, #29
 8002ff2:	d575      	bpl.n	80030e0 <HAL_UART_IRQHandler+0x118>
 8002ff4:	b129      	cbz	r1, 8003002 <HAL_UART_IRQHandler+0x3a>
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8002ff6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8002ff8:	0790      	lsls	r0, r2, #30
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8002ffa:	f043 0302 	orr.w	r3, r3, #2
 8002ffe:	63e3      	str	r3, [r4, #60]	; 0x3c
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003000:	d472      	bmi.n	80030e8 <HAL_UART_IRQHandler+0x120>
    if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
 8003002:	0710      	lsls	r0, r2, #28
 8003004:	d503      	bpl.n	800300e <HAL_UART_IRQHandler+0x46>
 8003006:	06ab      	lsls	r3, r5, #26
 8003008:	d473      	bmi.n	80030f2 <HAL_UART_IRQHandler+0x12a>
 800300a:	2900      	cmp	r1, #0
 800300c:	d171      	bne.n	80030f2 <HAL_UART_IRQHandler+0x12a>
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 800300e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003010:	2b00      	cmp	r3, #0
 8003012:	d032      	beq.n	800307a <HAL_UART_IRQHandler+0xb2>
      if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8003014:	0690      	lsls	r0, r2, #26
 8003016:	d501      	bpl.n	800301c <HAL_UART_IRQHandler+0x54>
 8003018:	06a9      	lsls	r1, r5, #26
 800301a:	d473      	bmi.n	8003104 <HAL_UART_IRQHandler+0x13c>
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 800301c:	6975      	ldr	r5, [r6, #20]
      if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 800301e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003020:	0712      	lsls	r2, r2, #28
 8003022:	d402      	bmi.n	800302a <HAL_UART_IRQHandler+0x62>
 8003024:	f015 0540 	ands.w	r5, r5, #64	; 0x40
 8003028:	d079      	beq.n	800311e <HAL_UART_IRQHandler+0x156>
  huart->RxState = HAL_UART_STATE_READY;
 800302a:	2220      	movs	r2, #32
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 800302c:	68f3      	ldr	r3, [r6, #12]
 800302e:	f423 7390 	bic.w	r3, r3, #288	; 0x120
 8003032:	60f3      	str	r3, [r6, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003034:	6973      	ldr	r3, [r6, #20]
 8003036:	f023 0301 	bic.w	r3, r3, #1
 800303a:	6173      	str	r3, [r6, #20]
  huart->RxState = HAL_UART_STATE_READY;
 800303c:	f884 203a 	strb.w	r2, [r4, #58]	; 0x3a
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003040:	6973      	ldr	r3, [r6, #20]
 8003042:	065b      	lsls	r3, r3, #25
 8003044:	d55a      	bpl.n	80030fc <HAL_UART_IRQHandler+0x134>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003046:	6973      	ldr	r3, [r6, #20]
          if (huart->hdmarx != NULL)
 8003048:	6b62      	ldr	r2, [r4, #52]	; 0x34
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800304a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 800304e:	6173      	str	r3, [r6, #20]
          if (huart->hdmarx != NULL)
 8003050:	2a00      	cmp	r2, #0
 8003052:	d053      	beq.n	80030fc <HAL_UART_IRQHandler+0x134>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003054:	4b39      	ldr	r3, [pc, #228]	; (800313c <HAL_UART_IRQHandler+0x174>)
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8003056:	4610      	mov	r0, r2
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003058:	6353      	str	r3, [r2, #52]	; 0x34
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800305a:	f7fe fe1b 	bl	8001c94 <HAL_DMA_Abort_IT>
 800305e:	b160      	cbz	r0, 800307a <HAL_UART_IRQHandler+0xb2>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003060:	6b60      	ldr	r0, [r4, #52]	; 0x34
}
 8003062:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003066:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003068:	4718      	bx	r3
    if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 800306a:	0696      	lsls	r6, r2, #26
 800306c:	d509      	bpl.n	8003082 <HAL_UART_IRQHandler+0xba>
 800306e:	06a9      	lsls	r1, r5, #26
 8003070:	d507      	bpl.n	8003082 <HAL_UART_IRQHandler+0xba>
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8003072:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8003076:	2b22      	cmp	r3, #34	; 0x22
 8003078:	d04d      	beq.n	8003116 <HAL_UART_IRQHandler+0x14e>
}
 800307a:	bd70      	pop	{r4, r5, r6, pc}
  if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 800307c:	f415 7f90 	tst.w	r5, #288	; 0x120
 8003080:	d1ae      	bne.n	8002fe0 <HAL_UART_IRQHandler+0x18>
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8003082:	0616      	lsls	r6, r2, #24
 8003084:	d40e      	bmi.n	80030a4 <HAL_UART_IRQHandler+0xdc>
  if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8003086:	0651      	lsls	r1, r2, #25
 8003088:	d5f7      	bpl.n	800307a <HAL_UART_IRQHandler+0xb2>
 800308a:	066a      	lsls	r2, r5, #25
 800308c:	d5f5      	bpl.n	800307a <HAL_UART_IRQHandler+0xb2>
  huart->gState = HAL_UART_STATE_READY;
 800308e:	2120      	movs	r1, #32
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8003090:	68da      	ldr	r2, [r3, #12]
  HAL_UART_TxCpltCallback(huart);
 8003092:	4620      	mov	r0, r4
  __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
 8003094:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003098:	60da      	str	r2, [r3, #12]
  huart->gState = HAL_UART_STATE_READY;
 800309a:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  HAL_UART_TxCpltCallback(huart);
 800309e:	f7ff ff53 	bl	8002f48 <HAL_UART_TxCpltCallback>
}
 80030a2:	bd70      	pop	{r4, r5, r6, pc}
  if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 80030a4:	0628      	lsls	r0, r5, #24
 80030a6:	d5ee      	bpl.n	8003086 <HAL_UART_IRQHandler+0xbe>
  if (huart->gState == HAL_UART_STATE_BUSY_TX)
 80030a8:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 80030ac:	2a21      	cmp	r2, #33	; 0x21
 80030ae:	d1e4      	bne.n	800307a <HAL_UART_IRQHandler+0xb2>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80030b0:	68a1      	ldr	r1, [r4, #8]
 80030b2:	6a22      	ldr	r2, [r4, #32]
 80030b4:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 80030b8:	d036      	beq.n	8003128 <HAL_UART_IRQHandler+0x160>
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
 80030ba:	1c51      	adds	r1, r2, #1
 80030bc:	6221      	str	r1, [r4, #32]
 80030be:	7812      	ldrb	r2, [r2, #0]
 80030c0:	605a      	str	r2, [r3, #4]
    if (--huart->TxXferCount == 0U)
 80030c2:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 80030c4:	3a01      	subs	r2, #1
 80030c6:	b292      	uxth	r2, r2
 80030c8:	84e2      	strh	r2, [r4, #38]	; 0x26
 80030ca:	2a00      	cmp	r2, #0
 80030cc:	d1d5      	bne.n	800307a <HAL_UART_IRQHandler+0xb2>
      __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
 80030ce:	68da      	ldr	r2, [r3, #12]
 80030d0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80030d4:	60da      	str	r2, [r3, #12]
      __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
 80030d6:	68da      	ldr	r2, [r3, #12]
 80030d8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80030dc:	60da      	str	r2, [r3, #12]
}
 80030de:	bd70      	pop	{r4, r5, r6, pc}
    if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 80030e0:	0793      	lsls	r3, r2, #30
 80030e2:	d58e      	bpl.n	8003002 <HAL_UART_IRQHandler+0x3a>
 80030e4:	2900      	cmp	r1, #0
 80030e6:	d08c      	beq.n	8003002 <HAL_UART_IRQHandler+0x3a>
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80030e8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80030ea:	f043 0304 	orr.w	r3, r3, #4
 80030ee:	63e3      	str	r3, [r4, #60]	; 0x3c
 80030f0:	e787      	b.n	8003002 <HAL_UART_IRQHandler+0x3a>
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80030f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80030f4:	f043 0308 	orr.w	r3, r3, #8
 80030f8:	63e3      	str	r3, [r4, #60]	; 0x3c
 80030fa:	e788      	b.n	800300e <HAL_UART_IRQHandler+0x46>
            HAL_UART_ErrorCallback(huart);
 80030fc:	4620      	mov	r0, r4
 80030fe:	f7ff ff61 	bl	8002fc4 <HAL_UART_ErrorCallback>
}
 8003102:	bd70      	pop	{r4, r5, r6, pc}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8003104:	f894 303a 	ldrb.w	r3, [r4, #58]	; 0x3a
 8003108:	2b22      	cmp	r3, #34	; 0x22
 800310a:	d187      	bne.n	800301c <HAL_UART_IRQHandler+0x54>
 800310c:	4620      	mov	r0, r4
 800310e:	f7ff ff1f 	bl	8002f50 <UART_Receive_IT.part.1>
 8003112:	6826      	ldr	r6, [r4, #0]
 8003114:	e782      	b.n	800301c <HAL_UART_IRQHandler+0x54>
}
 8003116:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800311a:	f7ff bf19 	b.w	8002f50 <UART_Receive_IT.part.1>
        HAL_UART_ErrorCallback(huart);
 800311e:	4620      	mov	r0, r4
 8003120:	f7ff ff50 	bl	8002fc4 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003124:	63e5      	str	r5, [r4, #60]	; 0x3c
}
 8003126:	bd70      	pop	{r4, r5, r6, pc}
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003128:	6921      	ldr	r1, [r4, #16]
 800312a:	2900      	cmp	r1, #0
 800312c:	d1c5      	bne.n	80030ba <HAL_UART_IRQHandler+0xf2>
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
 800312e:	f832 1b02 	ldrh.w	r1, [r2], #2
 8003132:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8003136:	6059      	str	r1, [r3, #4]
      huart->pTxBuffPtr += 2U;
 8003138:	6222      	str	r2, [r4, #32]
 800313a:	e7c2      	b.n	80030c2 <HAL_UART_IRQHandler+0xfa>
 800313c:	08003141 	.word	0x08003141

08003140 <UART_DMAAbortOnError>:
  huart->RxXferCount = 0x00U;
 8003140:	2200      	movs	r2, #0
{
 8003142:	b508      	push	{r3, lr}
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8003144:	6a43      	ldr	r3, [r0, #36]	; 0x24
  huart->RxXferCount = 0x00U;
 8003146:	85da      	strh	r2, [r3, #46]	; 0x2e
  HAL_UART_ErrorCallback(huart);
 8003148:	4618      	mov	r0, r3
  huart->TxXferCount = 0x00U;
 800314a:	84da      	strh	r2, [r3, #38]	; 0x26
  HAL_UART_ErrorCallback(huart);
 800314c:	f7ff ff3a 	bl	8002fc4 <HAL_UART_ErrorCallback>
}
 8003150:	bd08      	pop	{r3, pc}
 8003152:	bf00      	nop

08003154 <osKernelInitialize>:
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003154:	f3ef 8305 	mrs	r3, IPSR
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 8003158:	b983      	cbnz	r3, 800317c <osKernelInitialize+0x28>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800315a:	f3ef 8310 	mrs	r3, PRIMASK
 800315e:	b96b      	cbnz	r3, 800317c <osKernelInitialize+0x28>
 8003160:	4b08      	ldr	r3, [pc, #32]	; (8003184 <osKernelInitialize+0x30>)
 8003162:	6818      	ldr	r0, [r3, #0]
 8003164:	2802      	cmp	r0, #2
 8003166:	d003      	beq.n	8003170 <osKernelInitialize+0x1c>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelInactive) {
 8003168:	b928      	cbnz	r0, 8003176 <osKernelInitialize+0x22>
      #if defined(USE_FreeRTOS_HEAP_5)
        vPortDefineHeapRegions (xHeapRegions);
      #endif
      KernelState = osKernelReady;
 800316a:	2201      	movs	r2, #1
 800316c:	601a      	str	r2, [r3, #0]
 800316e:	4770      	bx	lr
 */
__STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003170:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 8003174:	b913      	cbnz	r3, 800317c <osKernelInitialize+0x28>
      stat = osOK;
    } else {
      stat = osError;
 8003176:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }

  return (stat);
}
 800317a:	4770      	bx	lr
    stat = osErrorISR;
 800317c:	f06f 0005 	mvn.w	r0, #5
 8003180:	4770      	bx	lr
 8003182:	bf00      	nop
 8003184:	2000046c 	.word	0x2000046c

08003188 <osKernelStart>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003188:	f3ef 8305 	mrs	r3, IPSR
}

osStatus_t osKernelStart (void) {
  osStatus_t stat;

  if (IS_IRQ()) {
 800318c:	b9c3      	cbnz	r3, 80031c0 <osKernelStart+0x38>
osStatus_t osKernelStart (void) {
 800318e:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003190:	f3ef 8410 	mrs	r4, PRIMASK
  if (IS_IRQ()) {
 8003194:	b98c      	cbnz	r4, 80031ba <osKernelStart+0x32>
 8003196:	4b0c      	ldr	r3, [pc, #48]	; (80031c8 <osKernelStart+0x40>)
 8003198:	681a      	ldr	r2, [r3, #0]
 800319a:	2a02      	cmp	r2, #2
 800319c:	d007      	beq.n	80031ae <osKernelStart+0x26>
    stat = osErrorISR;
  }
  else {
    if (KernelState == osKernelReady) {
 800319e:	2a01      	cmp	r2, #1
 80031a0:	d108      	bne.n	80031b4 <osKernelStart+0x2c>
      KernelState = osKernelRunning;
 80031a2:	2202      	movs	r2, #2
 80031a4:	601a      	str	r2, [r3, #0]
      vTaskStartScheduler();
 80031a6:	f000 fe0d 	bl	8003dc4 <vTaskStartScheduler>
      stat = osOK;
 80031aa:	4620      	mov	r0, r4
      stat = osError;
    }
  }

  return (stat);
}
 80031ac:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80031ae:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80031b2:	b913      	cbnz	r3, 80031ba <osKernelStart+0x32>
      stat = osError;
 80031b4:	f04f 30ff 	mov.w	r0, #4294967295
}
 80031b8:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 80031ba:	f06f 0005 	mvn.w	r0, #5
}
 80031be:	bd10      	pop	{r4, pc}
    stat = osErrorISR;
 80031c0:	f06f 0005 	mvn.w	r0, #5
}
 80031c4:	4770      	bx	lr
 80031c6:	bf00      	nop
 80031c8:	2000046c 	.word	0x2000046c

080031cc <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 80031cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 80031ce:	2400      	movs	r4, #0
osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 80031d0:	b087      	sub	sp, #28
  hTask = NULL;
 80031d2:	9405      	str	r4, [sp, #20]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80031d4:	f3ef 8505 	mrs	r5, IPSR

  if (!IS_IRQ() && (func != NULL)) {
 80031d8:	2d00      	cmp	r5, #0
 80031da:	d135      	bne.n	8003248 <osThreadNew+0x7c>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80031dc:	f3ef 8310 	mrs	r3, PRIMASK
 80031e0:	2b00      	cmp	r3, #0
 80031e2:	d138      	bne.n	8003256 <osThreadNew+0x8a>
 80031e4:	4b25      	ldr	r3, [pc, #148]	; (800327c <osThreadNew+0xb0>)
 80031e6:	681b      	ldr	r3, [r3, #0]
 80031e8:	2b02      	cmp	r3, #2
 80031ea:	d030      	beq.n	800324e <osThreadNew+0x82>
 80031ec:	b398      	cbz	r0, 8003256 <osThreadNew+0x8a>
 80031ee:	460b      	mov	r3, r1
    stack = configMINIMAL_STACK_SIZE;
    prio  = (UBaseType_t)osPriorityNormal;

    empty = '\0';
 80031f0:	2100      	movs	r1, #0
 80031f2:	f88d 1013 	strb.w	r1, [sp, #19]
    name  = &empty;
    mem   = -1;

    if (attr != NULL) {
 80031f6:	b1e2      	cbz	r2, 8003232 <osThreadNew+0x66>
      if (attr->name != NULL) {
 80031f8:	6811      	ldr	r1, [r2, #0]
 80031fa:	b399      	cbz	r1, 8003264 <osThreadNew+0x98>
        name = attr->name;
      }
      if (attr->priority != osPriorityNone) {
 80031fc:	6994      	ldr	r4, [r2, #24]
 80031fe:	b36c      	cbz	r4, 800325c <osThreadNew+0x90>
        prio = (UBaseType_t)attr->priority;
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 8003200:	1e65      	subs	r5, r4, #1
 8003202:	2d37      	cmp	r5, #55	; 0x37
 8003204:	d820      	bhi.n	8003248 <osThreadNew+0x7c>
 8003206:	6855      	ldr	r5, [r2, #4]
 8003208:	07ed      	lsls	r5, r5, #31
 800320a:	d41d      	bmi.n	8003248 <osThreadNew+0x7c>
        return (NULL);
      }

      if (attr->stack_size > 0U) {
 800320c:	6955      	ldr	r5, [r2, #20]
 800320e:	bb3d      	cbnz	r5, 8003260 <osThreadNew+0x94>
    stack = configMINIMAL_STACK_SIZE;
 8003210:	2780      	movs	r7, #128	; 0x80
 8003212:	e9d2 6c02 	ldrd	r6, ip, [r2, #8]
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8003216:	b346      	cbz	r6, 800326a <osThreadNew+0x9e>
 8003218:	f1bc 0f5b 	cmp.w	ip, #91	; 0x5b
 800321c:	d91b      	bls.n	8003256 <osThreadNew+0x8a>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 800321e:	6912      	ldr	r2, [r2, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 8003220:	b1ca      	cbz	r2, 8003256 <osThreadNew+0x8a>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 8003222:	b1c5      	cbz	r5, 8003256 <osThreadNew+0x8a>
    else {
      mem = 0;
    }

    if (mem == 1) {
      hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 8003224:	e9cd 2601 	strd	r2, r6, [sp, #4]
 8003228:	9400      	str	r4, [sp, #0]
 800322a:	463a      	mov	r2, r7
 800322c:	f000 fd5e 	bl	8003cec <xTaskCreateStatic>
 8003230:	e00b      	b.n	800324a <osThreadNew+0x7e>
 8003232:	2280      	movs	r2, #128	; 0x80
    prio  = (UBaseType_t)osPriorityNormal;
 8003234:	2418      	movs	r4, #24
    name  = &empty;
 8003236:	f10d 0113 	add.w	r1, sp, #19
                                                                                    (StaticTask_t *)attr->cb_mem);
    }
    else {
      if (mem == 0) {
        if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 800323a:	ad05      	add	r5, sp, #20
 800323c:	e9cd 4500 	strd	r4, r5, [sp]
 8003240:	f000 fd8c 	bl	8003d5c <xTaskCreate>
 8003244:	2801      	cmp	r0, #1
 8003246:	d006      	beq.n	8003256 <osThreadNew+0x8a>
        return (NULL);
 8003248:	2000      	movs	r0, #0
      }
    }
  }

  return ((osThreadId_t)hTask);
}
 800324a:	b007      	add	sp, #28
 800324c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800324e:	f3ef 8311 	mrs	r3, BASEPRI
  if (!IS_IRQ() && (func != NULL)) {
 8003252:	2b00      	cmp	r3, #0
 8003254:	d0ca      	beq.n	80031ec <osThreadNew+0x20>
 8003256:	9805      	ldr	r0, [sp, #20]
}
 8003258:	b007      	add	sp, #28
 800325a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    prio  = (UBaseType_t)osPriorityNormal;
 800325c:	2418      	movs	r4, #24
 800325e:	e7d2      	b.n	8003206 <osThreadNew+0x3a>
        stack = attr->stack_size / sizeof(StackType_t);
 8003260:	08af      	lsrs	r7, r5, #2
 8003262:	e7d6      	b.n	8003212 <osThreadNew+0x46>
    name  = &empty;
 8003264:	f10d 0113 	add.w	r1, sp, #19
 8003268:	e7c8      	b.n	80031fc <osThreadNew+0x30>
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 800326a:	f1bc 0f00 	cmp.w	ip, #0
 800326e:	d1f2      	bne.n	8003256 <osThreadNew+0x8a>
 8003270:	6912      	ldr	r2, [r2, #16]
 8003272:	2a00      	cmp	r2, #0
 8003274:	d1ef      	bne.n	8003256 <osThreadNew+0x8a>
 8003276:	b2ba      	uxth	r2, r7
 8003278:	e7df      	b.n	800323a <osThreadNew+0x6e>
 800327a:	bf00      	nop
 800327c:	2000046c 	.word	0x2000046c

08003280 <osDelay>:

  /* Return flags before clearing */
  return (rflags);
}

osStatus_t osDelay (uint32_t ticks) {
 8003280:	b508      	push	{r3, lr}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8003282:	f3ef 8305 	mrs	r3, IPSR
  osStatus_t stat;

  if (IS_IRQ()) {
 8003286:	b983      	cbnz	r3, 80032aa <osDelay+0x2a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003288:	f3ef 8310 	mrs	r3, PRIMASK
 800328c:	b96b      	cbnz	r3, 80032aa <osDelay+0x2a>
 800328e:	4b08      	ldr	r3, [pc, #32]	; (80032b0 <osDelay+0x30>)
 8003290:	681b      	ldr	r3, [r3, #0]
 8003292:	2b02      	cmp	r3, #2
 8003294:	d005      	beq.n	80032a2 <osDelay+0x22>
    stat = osErrorISR;
  }
  else {
    stat = osOK;

    if (ticks != 0U) {
 8003296:	b900      	cbnz	r0, 800329a <osDelay+0x1a>
      vTaskDelay(ticks);
    }
  }

  return (stat);
}
 8003298:	bd08      	pop	{r3, pc}
      vTaskDelay(ticks);
 800329a:	f000 ff05 	bl	80040a8 <vTaskDelay>
    stat = osOK;
 800329e:	2000      	movs	r0, #0
}
 80032a0:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80032a2:	f3ef 8311 	mrs	r3, BASEPRI
  if (IS_IRQ()) {
 80032a6:	2b00      	cmp	r3, #0
 80032a8:	d0f5      	beq.n	8003296 <osDelay+0x16>
    stat = osErrorISR;
 80032aa:	f06f 0005 	mvn.w	r0, #5
}
 80032ae:	bd08      	pop	{r3, pc}
 80032b0:	2000046c 	.word	0x2000046c

080032b4 <vApplicationGetIdleTaskMemory>:
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 80032b4:	2380      	movs	r3, #128	; 0x80
void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 80032b6:	b430      	push	{r4, r5}
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 80032b8:	4d03      	ldr	r5, [pc, #12]	; (80032c8 <vApplicationGetIdleTaskMemory+0x14>)
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 80032ba:	4c04      	ldr	r4, [pc, #16]	; (80032cc <vApplicationGetIdleTaskMemory+0x18>)
  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 80032bc:	6005      	str	r5, [r0, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 80032be:	600c      	str	r4, [r1, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 80032c0:	6013      	str	r3, [r2, #0]
}
 80032c2:	bc30      	pop	{r4, r5}
 80032c4:	4770      	bx	lr
 80032c6:	bf00      	nop
 80032c8:	20000410 	.word	0x20000410
 80032cc:	20000210 	.word	0x20000210

080032d0 <vApplicationGetTimerTaskMemory>:
  equals to 1 and is required for static memory allocation support.
*/
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 80032d0:	f44f 7380 	mov.w	r3, #256	; 0x100
void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 80032d4:	b430      	push	{r4, r5}
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 80032d6:	4d03      	ldr	r5, [pc, #12]	; (80032e4 <vApplicationGetTimerTaskMemory+0x14>)
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 80032d8:	4c03      	ldr	r4, [pc, #12]	; (80032e8 <vApplicationGetTimerTaskMemory+0x18>)
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 80032da:	6005      	str	r5, [r0, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 80032dc:	600c      	str	r4, [r1, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 80032de:	6013      	str	r3, [r2, #0]
}
 80032e0:	bc30      	pop	{r4, r5}
 80032e2:	4770      	bx	lr
 80032e4:	20000870 	.word	0x20000870
 80032e8:	20000470 	.word	0x20000470

080032ec <vListInitialise>:
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80032ec:	f04f 31ff 	mov.w	r1, #4294967295
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80032f0:	2200      	movs	r2, #0
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80032f2:	f100 0308 	add.w	r3, r0, #8
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80032f6:	6081      	str	r1, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80032f8:	6002      	str	r2, [r0, #0]
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80032fa:	6043      	str	r3, [r0, #4]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80032fc:	e9c0 3303 	strd	r3, r3, [r0, #12]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003300:	4770      	bx	lr
 8003302:	bf00      	nop

08003304 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003304:	2300      	movs	r3, #0
 8003306:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003308:	4770      	bx	lr
 800330a:	bf00      	nop

0800330c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800330c:	6843      	ldr	r3, [r0, #4]
{
 800330e:	b410      	push	{r4}

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003310:	689c      	ldr	r4, [r3, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003312:	6802      	ldr	r2, [r0, #0]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003314:	608c      	str	r4, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003316:	689c      	ldr	r4, [r3, #8]
	( pxList->uxNumberOfItems )++;
 8003318:	3201      	adds	r2, #1
	pxNewListItem->pxNext = pxIndex;
 800331a:	604b      	str	r3, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800331c:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800331e:	6099      	str	r1, [r3, #8]
}
 8003320:	bc10      	pop	{r4}
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003322:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003324:	6002      	str	r2, [r0, #0]
}
 8003326:	4770      	bx	lr

08003328 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003328:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800332a:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800332c:	1c6b      	adds	r3, r5, #1
 800332e:	d011      	beq.n	8003354 <vListInsert+0x2c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003330:	f100 0208 	add.w	r2, r0, #8
 8003334:	e000      	b.n	8003338 <vListInsert+0x10>
 8003336:	461a      	mov	r2, r3
 8003338:	6853      	ldr	r3, [r2, #4]
 800333a:	681c      	ldr	r4, [r3, #0]
 800333c:	42ac      	cmp	r4, r5
 800333e:	d9fa      	bls.n	8003336 <vListInsert+0xe>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8003340:	6804      	ldr	r4, [r0, #0]
	pxNewListItem->pxNext = pxIterator->pxNext;
 8003342:	604b      	str	r3, [r1, #4]
	( pxList->uxNumberOfItems )++;
 8003344:	3401      	adds	r4, #1
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003346:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003348:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 800334a:	6051      	str	r1, [r2, #4]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800334c:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800334e:	6004      	str	r4, [r0, #0]
}
 8003350:	bc30      	pop	{r4, r5}
 8003352:	4770      	bx	lr
		pxIterator = pxList->xListEnd.pxPrevious;
 8003354:	6902      	ldr	r2, [r0, #16]
 8003356:	6853      	ldr	r3, [r2, #4]
 8003358:	e7f2      	b.n	8003340 <vListInsert+0x18>
 800335a:	bf00      	nop

0800335c <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 800335c:	6903      	ldr	r3, [r0, #16]
{
 800335e:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003360:	e9d0 2101 	ldrd	r2, r1, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003364:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003366:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003368:	6881      	ldr	r1, [r0, #8]
	if( pxList->pxIndex == pxItemToRemove )
 800336a:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800336c:	604a      	str	r2, [r1, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800336e:	bf08      	it	eq
 8003370:	6059      	streq	r1, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003372:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 8003374:	681a      	ldr	r2, [r3, #0]
	pxItemToRemove->pvContainer = NULL;
 8003376:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003378:	3a01      	subs	r2, #1
 800337a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800337c:	6818      	ldr	r0, [r3, #0]
}
 800337e:	bc10      	pop	{r4}
 8003380:	4770      	bx	lr
 8003382:	bf00      	nop

08003384 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8003384:	b570      	push	{r4, r5, r6, lr}
 8003386:	4604      	mov	r4, r0

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8003388:	6c00      	ldr	r0, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800338a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800338c:	b928      	cbnz	r0, 800339a <prvCopyDataToQueue+0x16>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800338e:	6826      	ldr	r6, [r4, #0]
 8003390:	3501      	adds	r5, #1
 8003392:	2e00      	cmp	r6, #0
 8003394:	d02e      	beq.n	80033f4 <prvCopyDataToQueue+0x70>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 8003396:	63a5      	str	r5, [r4, #56]	; 0x38

	return xReturn;
}
 8003398:	bd70      	pop	{r4, r5, r6, pc}
 800339a:	4616      	mov	r6, r2
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 800339c:	4602      	mov	r2, r0
	else if( xPosition == queueSEND_TO_BACK )
 800339e:	b986      	cbnz	r6, 80033c2 <prvCopyDataToQueue+0x3e>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 80033a0:	68a0      	ldr	r0, [r4, #8]
 80033a2:	f001 fcb9 	bl	8004d18 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80033a6:	68a3      	ldr	r3, [r4, #8]
 80033a8:	6c21      	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033aa:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80033ac:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033ae:	4293      	cmp	r3, r2
 80033b0:	f105 0501 	add.w	r5, r5, #1
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80033b4:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033b6:	d315      	bcc.n	80033e4 <prvCopyDataToQueue+0x60>
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80033b8:	6823      	ldr	r3, [r4, #0]
BaseType_t xReturn = pdFALSE;
 80033ba:	4630      	mov	r0, r6
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80033bc:	60a3      	str	r3, [r4, #8]
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80033be:	63a5      	str	r5, [r4, #56]	; 0x38
}
 80033c0:	bd70      	pop	{r4, r5, r6, pc}
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80033c2:	68e0      	ldr	r0, [r4, #12]
 80033c4:	f001 fca8 	bl	8004d18 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80033c8:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80033ca:	68e3      	ldr	r3, [r4, #12]
 80033cc:	4252      	negs	r2, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033ce:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80033d0:	4413      	add	r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033d2:	428b      	cmp	r3, r1
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 80033d4:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80033d6:	d202      	bcs.n	80033de <prvCopyDataToQueue+0x5a>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 80033d8:	6863      	ldr	r3, [r4, #4]
 80033da:	441a      	add	r2, r3
 80033dc:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
 80033de:	2e02      	cmp	r6, #2
 80033e0:	d003      	beq.n	80033ea <prvCopyDataToQueue+0x66>
 80033e2:	3501      	adds	r5, #1
BaseType_t xReturn = pdFALSE;
 80033e4:	2000      	movs	r0, #0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80033e6:	63a5      	str	r5, [r4, #56]	; 0x38
}
 80033e8:	bd70      	pop	{r4, r5, r6, pc}
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80033ea:	2d00      	cmp	r5, #0
 80033ec:	d1fa      	bne.n	80033e4 <prvCopyDataToQueue+0x60>
 80033ee:	2501      	movs	r5, #1
BaseType_t xReturn = pdFALSE;
 80033f0:	2000      	movs	r0, #0
 80033f2:	e7d0      	b.n	8003396 <prvCopyDataToQueue+0x12>
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80033f4:	6860      	ldr	r0, [r4, #4]
 80033f6:	f000 ffa7 	bl	8004348 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 80033fa:	6066      	str	r6, [r4, #4]
 80033fc:	e7cb      	b.n	8003396 <prvCopyDataToQueue+0x12>
 80033fe:	bf00      	nop

08003400 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8003400:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8003402:	b172      	cbz	r2, 8003422 <prvCopyDataFromQueue+0x22>
 8003404:	460b      	mov	r3, r1
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8003406:	68c1      	ldr	r1, [r0, #12]
{
 8003408:	b410      	push	{r4}
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800340a:	6844      	ldr	r4, [r0, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800340c:	4411      	add	r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800340e:	42a1      	cmp	r1, r4
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8003410:	60c1      	str	r1, [r0, #12]
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8003412:	bf28      	it	cs
 8003414:	6801      	ldrcs	r1, [r0, #0]
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
	}
}
 8003416:	bc10      	pop	{r4}
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8003418:	bf28      	it	cs
 800341a:	60c1      	strcs	r1, [r0, #12]
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 800341c:	4618      	mov	r0, r3
 800341e:	f001 bc7b 	b.w	8004d18 <memcpy>
 8003422:	4770      	bx	lr

08003424 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8003424:	b570      	push	{r4, r5, r6, lr}
 8003426:	4605      	mov	r5, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8003428:	f001 fa14 	bl	8004854 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800342c:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8003430:	b264      	sxtb	r4, r4

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8003432:	2c00      	cmp	r4, #0
 8003434:	dd16      	ble.n	8003464 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003436:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003438:	b1a3      	cbz	r3, 8003464 <prvUnlockQueue+0x40>
 800343a:	f105 0624 	add.w	r6, r5, #36	; 0x24
 800343e:	e005      	b.n	800344c <prvUnlockQueue+0x28>
 8003440:	3c01      	subs	r4, #1
 8003442:	b2e3      	uxtb	r3, r4
 8003444:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8003446:	b16b      	cbz	r3, 8003464 <prvUnlockQueue+0x40>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003448:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800344a:	b15b      	cbz	r3, 8003464 <prvUnlockQueue+0x40>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800344c:	4630      	mov	r0, r6
 800344e:	f000 fecd 	bl	80041ec <xTaskRemoveFromEventList>
 8003452:	2800      	cmp	r0, #0
 8003454:	d0f4      	beq.n	8003440 <prvUnlockQueue+0x1c>
 8003456:	3c01      	subs	r4, #1
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 8003458:	f000 ff60 	bl	800431c <vTaskMissedYield>
 800345c:	b2e3      	uxtb	r3, r4
 800345e:	b25c      	sxtb	r4, r3
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8003460:	2b00      	cmp	r3, #0
 8003462:	d1f1      	bne.n	8003448 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8003464:	23ff      	movs	r3, #255	; 0xff
 8003466:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 800346a:	f001 fa15 	bl	8004898 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800346e:	f001 f9f1 	bl	8004854 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8003472:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 8003476:	b264      	sxtb	r4, r4

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8003478:	2c00      	cmp	r4, #0
 800347a:	dd16      	ble.n	80034aa <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800347c:	692b      	ldr	r3, [r5, #16]
 800347e:	b1a3      	cbz	r3, 80034aa <prvUnlockQueue+0x86>
 8003480:	f105 0610 	add.w	r6, r5, #16
 8003484:	e005      	b.n	8003492 <prvUnlockQueue+0x6e>
 8003486:	3c01      	subs	r4, #1
 8003488:	b2e3      	uxtb	r3, r4
 800348a:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800348c:	b16b      	cbz	r3, 80034aa <prvUnlockQueue+0x86>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800348e:	692b      	ldr	r3, [r5, #16]
 8003490:	b15b      	cbz	r3, 80034aa <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003492:	4630      	mov	r0, r6
 8003494:	f000 feaa 	bl	80041ec <xTaskRemoveFromEventList>
 8003498:	2800      	cmp	r0, #0
 800349a:	d0f4      	beq.n	8003486 <prvUnlockQueue+0x62>
 800349c:	3c01      	subs	r4, #1
				{
					vTaskMissedYield();
 800349e:	f000 ff3d 	bl	800431c <vTaskMissedYield>
 80034a2:	b2e3      	uxtb	r3, r4
 80034a4:	b25c      	sxtb	r4, r3
		while( cRxLock > queueLOCKED_UNMODIFIED )
 80034a6:	2b00      	cmp	r3, #0
 80034a8:	d1f1      	bne.n	800348e <prvUnlockQueue+0x6a>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 80034aa:	23ff      	movs	r3, #255	; 0xff
 80034ac:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 80034b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	taskEXIT_CRITICAL();
 80034b4:	f001 b9f0 	b.w	8004898 <vPortExitCritical>

080034b8 <xQueueGenericReset>:
	configASSERT( pxQueue );
 80034b8:	b1e8      	cbz	r0, 80034f6 <xQueueGenericReset+0x3e>
{
 80034ba:	b570      	push	{r4, r5, r6, lr}
 80034bc:	4604      	mov	r4, r0
 80034be:	460d      	mov	r5, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80034c0:	2600      	movs	r6, #0
	taskENTER_CRITICAL();
 80034c2:	f001 f9c7 	bl	8004854 <vPortEnterCritical>
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80034c6:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
		pxQueue->cRxLock = queueUNLOCKED;
 80034ca:	20ff      	movs	r0, #255	; 0xff
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80034cc:	fb03 f302 	mul.w	r3, r3, r2
 80034d0:	6821      	ldr	r1, [r4, #0]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80034d2:	1a9a      	subs	r2, r3, r2
 80034d4:	440a      	add	r2, r1
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 80034d6:	440b      	add	r3, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80034d8:	63a6      	str	r6, [r4, #56]	; 0x38
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 80034da:	60e2      	str	r2, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 80034dc:	f884 0044 	strb.w	r0, [r4, #68]	; 0x44
		pxQueue->pcWriteTo = pxQueue->pcHead;
 80034e0:	e9c4 3101 	strd	r3, r1, [r4, #4]
		pxQueue->cTxLock = queueUNLOCKED;
 80034e4:	f884 0045 	strb.w	r0, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
 80034e8:	b975      	cbnz	r5, 8003508 <xQueueGenericReset+0x50>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80034ea:	6923      	ldr	r3, [r4, #16]
 80034ec:	b9ab      	cbnz	r3, 800351a <xQueueGenericReset+0x62>
	taskEXIT_CRITICAL();
 80034ee:	f001 f9d3 	bl	8004898 <vPortExitCritical>
}
 80034f2:	2001      	movs	r0, #1
 80034f4:	bd70      	pop	{r4, r5, r6, pc}

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 80034f6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80034fa:	f383 8811 	msr	BASEPRI, r3
 80034fe:	f3bf 8f6f 	isb	sy
 8003502:	f3bf 8f4f 	dsb	sy
 8003506:	e7fe      	b.n	8003506 <xQueueGenericReset+0x4e>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8003508:	f104 0010 	add.w	r0, r4, #16
 800350c:	f7ff feee 	bl	80032ec <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8003510:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8003514:	f7ff feea 	bl	80032ec <vListInitialise>
 8003518:	e7e9      	b.n	80034ee <xQueueGenericReset+0x36>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800351a:	f104 0010 	add.w	r0, r4, #16
 800351e:	f000 fe65 	bl	80041ec <xTaskRemoveFromEventList>
 8003522:	2800      	cmp	r0, #0
 8003524:	d0e3      	beq.n	80034ee <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
 8003526:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800352a:	4b03      	ldr	r3, [pc, #12]	; (8003538 <xQueueGenericReset+0x80>)
 800352c:	601a      	str	r2, [r3, #0]
 800352e:	f3bf 8f4f 	dsb	sy
 8003532:	f3bf 8f6f 	isb	sy
 8003536:	e7da      	b.n	80034ee <xQueueGenericReset+0x36>
 8003538:	e000ed04 	.word	0xe000ed04

0800353c <xQueueGenericCreateStatic>:
	{
 800353c:	b530      	push	{r4, r5, lr}
 800353e:	b083      	sub	sp, #12
 8003540:	f89d 5018 	ldrb.w	r5, [sp, #24]
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 8003544:	b940      	cbnz	r0, 8003558 <xQueueGenericCreateStatic+0x1c>
 8003546:	f04f 0350 	mov.w	r3, #80	; 0x50
 800354a:	f383 8811 	msr	BASEPRI, r3
 800354e:	f3bf 8f6f 	isb	sy
 8003552:	f3bf 8f4f 	dsb	sy
 8003556:	e7fe      	b.n	8003556 <xQueueGenericCreateStatic+0x1a>
		configASSERT( pxStaticQueue != NULL );
 8003558:	b17b      	cbz	r3, 800357a <xQueueGenericCreateStatic+0x3e>
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 800355a:	b382      	cbz	r2, 80035be <xQueueGenericCreateStatic+0x82>
 800355c:	b1b1      	cbz	r1, 800358c <xQueueGenericCreateStatic+0x50>
			volatile size_t xSize = sizeof( StaticQueue_t );
 800355e:	2450      	movs	r4, #80	; 0x50
 8003560:	9401      	str	r4, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 8003562:	9c01      	ldr	r4, [sp, #4]
 8003564:	2c50      	cmp	r4, #80	; 0x50
 8003566:	d01a      	beq.n	800359e <xQueueGenericCreateStatic+0x62>
 8003568:	f04f 0350 	mov.w	r3, #80	; 0x50
 800356c:	f383 8811 	msr	BASEPRI, r3
 8003570:	f3bf 8f6f 	isb	sy
 8003574:	f3bf 8f4f 	dsb	sy
 8003578:	e7fe      	b.n	8003578 <xQueueGenericCreateStatic+0x3c>
 800357a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800357e:	f383 8811 	msr	BASEPRI, r3
 8003582:	f3bf 8f6f 	isb	sy
 8003586:	f3bf 8f4f 	dsb	sy
 800358a:	e7fe      	b.n	800358a <xQueueGenericCreateStatic+0x4e>
 800358c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003590:	f383 8811 	msr	BASEPRI, r3
 8003594:	f3bf 8f6f 	isb	sy
 8003598:	f3bf 8f4f 	dsb	sy
 800359c:	e7fe      	b.n	800359c <xQueueGenericCreateStatic+0x60>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800359e:	2401      	movs	r4, #1
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 80035a0:	601a      	str	r2, [r3, #0]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80035a2:	f883 4046 	strb.w	r4, [r3, #70]	; 0x46
 80035a6:	461c      	mov	r4, r3
	pxNewQueue->uxItemSize = uxItemSize;
 80035a8:	e9c3 010f 	strd	r0, r1, [r3, #60]	; 0x3c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 80035ac:	2101      	movs	r1, #1
 80035ae:	4618      	mov	r0, r3
 80035b0:	f7ff ff82 	bl	80034b8 <xQueueGenericReset>
	}
 80035b4:	4620      	mov	r0, r4
		pxNewQueue->ucQueueType = ucQueueType;
 80035b6:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
	}
 80035ba:	b003      	add	sp, #12
 80035bc:	bd30      	pop	{r4, r5, pc}
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 80035be:	b141      	cbz	r1, 80035d2 <xQueueGenericCreateStatic+0x96>
 80035c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80035c4:	f383 8811 	msr	BASEPRI, r3
 80035c8:	f3bf 8f6f 	isb	sy
 80035cc:	f3bf 8f4f 	dsb	sy
 80035d0:	e7fe      	b.n	80035d0 <xQueueGenericCreateStatic+0x94>
			volatile size_t xSize = sizeof( StaticQueue_t );
 80035d2:	2250      	movs	r2, #80	; 0x50
 80035d4:	9201      	str	r2, [sp, #4]
			configASSERT( xSize == sizeof( Queue_t ) );
 80035d6:	9a01      	ldr	r2, [sp, #4]
 80035d8:	2a50      	cmp	r2, #80	; 0x50
 80035da:	d1c5      	bne.n	8003568 <xQueueGenericCreateStatic+0x2c>
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80035dc:	2201      	movs	r2, #1
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 80035de:	601b      	str	r3, [r3, #0]
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 80035e0:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
 80035e4:	e7df      	b.n	80035a6 <xQueueGenericCreateStatic+0x6a>
 80035e6:	bf00      	nop

080035e8 <xQueueGenericSend>:
{
 80035e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80035ec:	b084      	sub	sp, #16
 80035ee:	9201      	str	r2, [sp, #4]
	configASSERT( pxQueue );
 80035f0:	2800      	cmp	r0, #0
 80035f2:	f000 8099 	beq.w	8003728 <xQueueGenericSend+0x140>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80035f6:	2900      	cmp	r1, #0
 80035f8:	f000 8089 	beq.w	800370e <xQueueGenericSend+0x126>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 80035fc:	2b02      	cmp	r3, #2
 80035fe:	d10b      	bne.n	8003618 <xQueueGenericSend+0x30>
 8003600:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
 8003602:	2a01      	cmp	r2, #1
 8003604:	d008      	beq.n	8003618 <xQueueGenericSend+0x30>
 8003606:	f04f 0350 	mov.w	r3, #80	; 0x50
 800360a:	f383 8811 	msr	BASEPRI, r3
 800360e:	f3bf 8f6f 	isb	sy
 8003612:	f3bf 8f4f 	dsb	sy
 8003616:	e7fe      	b.n	8003616 <xQueueGenericSend+0x2e>
 8003618:	4604      	mov	r4, r0
 800361a:	461f      	mov	r7, r3
 800361c:	4689      	mov	r9, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800361e:	f000 fe83 	bl	8004328 <xTaskGetSchedulerState>
 8003622:	b950      	cbnz	r0, 800363a <xQueueGenericSend+0x52>
 8003624:	9e01      	ldr	r6, [sp, #4]
 8003626:	b14e      	cbz	r6, 800363c <xQueueGenericSend+0x54>
 8003628:	f04f 0350 	mov.w	r3, #80	; 0x50
 800362c:	f383 8811 	msr	BASEPRI, r3
 8003630:	f3bf 8f6f 	isb	sy
 8003634:	f3bf 8f4f 	dsb	sy
 8003638:	e7fe      	b.n	8003638 <xQueueGenericSend+0x50>
 800363a:	2600      	movs	r6, #0
		prvLockQueue( pxQueue );
 800363c:	f04f 0800 	mov.w	r8, #0
					portYIELD_WITHIN_API();
 8003640:	f8df a11c 	ldr.w	sl, [pc, #284]	; 8003760 <xQueueGenericSend+0x178>
 8003644:	e007      	b.n	8003656 <xQueueGenericSend+0x6e>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8003646:	f001 f927 	bl	8004898 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 800364a:	4620      	mov	r0, r4
 800364c:	f7ff feea 	bl	8003424 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8003650:	f000 fca8 	bl	8003fa4 <xTaskResumeAll>
 8003654:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
 8003656:	f001 f8fd 	bl	8004854 <vPortEnterCritical>
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800365a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800365c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800365e:	429a      	cmp	r2, r3
 8003660:	d33f      	bcc.n	80036e2 <xQueueGenericSend+0xfa>
 8003662:	2f02      	cmp	r7, #2
 8003664:	d03d      	beq.n	80036e2 <xQueueGenericSend+0xfa>
				if( xTicksToWait == ( TickType_t ) 0 )
 8003666:	9d01      	ldr	r5, [sp, #4]
 8003668:	2d00      	cmp	r5, #0
 800366a:	d066      	beq.n	800373a <xQueueGenericSend+0x152>
				else if( xEntryTimeSet == pdFALSE )
 800366c:	b916      	cbnz	r6, 8003674 <xQueueGenericSend+0x8c>
					vTaskInternalSetTimeOutState( &xTimeOut );
 800366e:	a802      	add	r0, sp, #8
 8003670:	f000 fe02 	bl	8004278 <vTaskInternalSetTimeOutState>
		taskEXIT_CRITICAL();
 8003674:	f001 f910 	bl	8004898 <vPortExitCritical>
		vTaskSuspendAll();
 8003678:	f000 fbe6 	bl	8003e48 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800367c:	f001 f8ea 	bl	8004854 <vPortEnterCritical>
 8003680:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8003684:	2bff      	cmp	r3, #255	; 0xff
 8003686:	bf08      	it	eq
 8003688:	f884 8044 	strbeq.w	r8, [r4, #68]	; 0x44
 800368c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 8003690:	2bff      	cmp	r3, #255	; 0xff
 8003692:	bf08      	it	eq
 8003694:	f884 8045 	strbeq.w	r8, [r4, #69]	; 0x45
 8003698:	f001 f8fe 	bl	8004898 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800369c:	a901      	add	r1, sp, #4
 800369e:	a802      	add	r0, sp, #8
 80036a0:	f000 fdf6 	bl	8004290 <xTaskCheckForTimeOut>
 80036a4:	2800      	cmp	r0, #0
 80036a6:	d153      	bne.n	8003750 <xQueueGenericSend+0x168>
	taskENTER_CRITICAL();
 80036a8:	f001 f8d4 	bl	8004854 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 80036ac:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80036ae:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80036b0:	429a      	cmp	r2, r3
 80036b2:	d1c8      	bne.n	8003646 <xQueueGenericSend+0x5e>
	taskEXIT_CRITICAL();
 80036b4:	f001 f8f0 	bl	8004898 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80036b8:	9901      	ldr	r1, [sp, #4]
 80036ba:	f104 0010 	add.w	r0, r4, #16
 80036be:	f000 fd5b 	bl	8004178 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80036c2:	4620      	mov	r0, r4
 80036c4:	f7ff feae 	bl	8003424 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80036c8:	f000 fc6c 	bl	8003fa4 <xTaskResumeAll>
 80036cc:	2800      	cmp	r0, #0
 80036ce:	d1c1      	bne.n	8003654 <xQueueGenericSend+0x6c>
					portYIELD_WITHIN_API();
 80036d0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80036d4:	f8ca 3000 	str.w	r3, [sl]
 80036d8:	f3bf 8f4f 	dsb	sy
 80036dc:	f3bf 8f6f 	isb	sy
 80036e0:	e7b8      	b.n	8003654 <xQueueGenericSend+0x6c>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80036e2:	463a      	mov	r2, r7
 80036e4:	4649      	mov	r1, r9
 80036e6:	4620      	mov	r0, r4
 80036e8:	f7ff fe4c 	bl	8003384 <prvCopyDataToQueue>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80036ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80036ee:	bb43      	cbnz	r3, 8003742 <xQueueGenericSend+0x15a>
					else if( xYieldRequired != pdFALSE )
 80036f0:	b138      	cbz	r0, 8003702 <xQueueGenericSend+0x11a>
						queueYIELD_IF_USING_PREEMPTION();
 80036f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80036f6:	4b1a      	ldr	r3, [pc, #104]	; (8003760 <xQueueGenericSend+0x178>)
 80036f8:	601a      	str	r2, [r3, #0]
 80036fa:	f3bf 8f4f 	dsb	sy
 80036fe:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
 8003702:	f001 f8c9 	bl	8004898 <vPortExitCritical>
				return pdPASS;
 8003706:	2001      	movs	r0, #1
}
 8003708:	b004      	add	sp, #16
 800370a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800370e:	6c02      	ldr	r2, [r0, #64]	; 0x40
 8003710:	2a00      	cmp	r2, #0
 8003712:	f43f af73 	beq.w	80035fc <xQueueGenericSend+0x14>
 8003716:	f04f 0350 	mov.w	r3, #80	; 0x50
 800371a:	f383 8811 	msr	BASEPRI, r3
 800371e:	f3bf 8f6f 	isb	sy
 8003722:	f3bf 8f4f 	dsb	sy
 8003726:	e7fe      	b.n	8003726 <xQueueGenericSend+0x13e>
 8003728:	f04f 0350 	mov.w	r3, #80	; 0x50
 800372c:	f383 8811 	msr	BASEPRI, r3
 8003730:	f3bf 8f6f 	isb	sy
 8003734:	f3bf 8f4f 	dsb	sy
 8003738:	e7fe      	b.n	8003738 <xQueueGenericSend+0x150>
					taskEXIT_CRITICAL();
 800373a:	f001 f8ad 	bl	8004898 <vPortExitCritical>
					return errQUEUE_FULL;
 800373e:	4628      	mov	r0, r5
 8003740:	e7e2      	b.n	8003708 <xQueueGenericSend+0x120>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8003742:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8003746:	f000 fd51 	bl	80041ec <xTaskRemoveFromEventList>
 800374a:	2800      	cmp	r0, #0
 800374c:	d1d1      	bne.n	80036f2 <xQueueGenericSend+0x10a>
 800374e:	e7d8      	b.n	8003702 <xQueueGenericSend+0x11a>
			prvUnlockQueue( pxQueue );
 8003750:	4620      	mov	r0, r4
 8003752:	f7ff fe67 	bl	8003424 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8003756:	f000 fc25 	bl	8003fa4 <xTaskResumeAll>
			return errQUEUE_FULL;
 800375a:	2000      	movs	r0, #0
 800375c:	e7d4      	b.n	8003708 <xQueueGenericSend+0x120>
 800375e:	bf00      	nop
 8003760:	e000ed04 	.word	0xe000ed04

08003764 <xQueueGenericSendFromISR>:
{
 8003764:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( pxQueue );
 8003768:	2800      	cmp	r0, #0
 800376a:	d035      	beq.n	80037d8 <xQueueGenericSendFromISR+0x74>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800376c:	b341      	cbz	r1, 80037c0 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800376e:	2b02      	cmp	r3, #2
 8003770:	d10b      	bne.n	800378a <xQueueGenericSendFromISR+0x26>
 8003772:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8003774:	2c01      	cmp	r4, #1
 8003776:	d008      	beq.n	800378a <xQueueGenericSendFromISR+0x26>
 8003778:	f04f 0350 	mov.w	r3, #80	; 0x50
 800377c:	f383 8811 	msr	BASEPRI, r3
 8003780:	f3bf 8f6f 	isb	sy
 8003784:	f3bf 8f4f 	dsb	sy
 8003788:	e7fe      	b.n	8003788 <xQueueGenericSendFromISR+0x24>
 800378a:	4604      	mov	r4, r0
 800378c:	461f      	mov	r7, r3
 800378e:	4690      	mov	r8, r2
 8003790:	4689      	mov	r9, r1
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8003792:	f001 f947 	bl	8004a24 <vPortValidateInterruptPriority>

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 8003796:	f3ef 8611 	mrs	r6, BASEPRI
 800379a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800379e:	f383 8811 	msr	BASEPRI, r3
 80037a2:	f3bf 8f6f 	isb	sy
 80037a6:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 80037aa:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80037ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80037ae:	429a      	cmp	r2, r3
 80037b0:	d31b      	bcc.n	80037ea <xQueueGenericSendFromISR+0x86>
 80037b2:	2f02      	cmp	r7, #2
 80037b4:	d019      	beq.n	80037ea <xQueueGenericSendFromISR+0x86>
			xReturn = errQUEUE_FULL;
 80037b6:	2000      	movs	r0, #0
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80037b8:	f386 8811 	msr	BASEPRI, r6
}
 80037bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80037c0:	6c04      	ldr	r4, [r0, #64]	; 0x40
 80037c2:	2c00      	cmp	r4, #0
 80037c4:	d0d3      	beq.n	800376e <xQueueGenericSendFromISR+0xa>
	__asm volatile
 80037c6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80037ca:	f383 8811 	msr	BASEPRI, r3
 80037ce:	f3bf 8f6f 	isb	sy
 80037d2:	f3bf 8f4f 	dsb	sy
 80037d6:	e7fe      	b.n	80037d6 <xQueueGenericSendFromISR+0x72>
 80037d8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80037dc:	f383 8811 	msr	BASEPRI, r3
 80037e0:	f3bf 8f6f 	isb	sy
 80037e4:	f3bf 8f4f 	dsb	sy
 80037e8:	e7fe      	b.n	80037e8 <xQueueGenericSendFromISR+0x84>
			const int8_t cTxLock = pxQueue->cTxLock;
 80037ea:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80037ee:	463a      	mov	r2, r7
 80037f0:	4649      	mov	r1, r9
			const int8_t cTxLock = pxQueue->cTxLock;
 80037f2:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80037f4:	4620      	mov	r0, r4
 80037f6:	f7ff fdc5 	bl	8003384 <prvCopyDataToQueue>
			if( cTxLock == queueUNLOCKED )
 80037fa:	1c6b      	adds	r3, r5, #1
 80037fc:	d008      	beq.n	8003810 <xQueueGenericSendFromISR+0xac>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 80037fe:	1c6b      	adds	r3, r5, #1
 8003800:	b25b      	sxtb	r3, r3
 8003802:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
 8003806:	2001      	movs	r0, #1
	__asm volatile
 8003808:	f386 8811 	msr	BASEPRI, r6
}
 800380c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8003810:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003812:	2b00      	cmp	r3, #0
 8003814:	d0f7      	beq.n	8003806 <xQueueGenericSendFromISR+0xa2>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8003816:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800381a:	f000 fce7 	bl	80041ec <xTaskRemoveFromEventList>
 800381e:	2800      	cmp	r0, #0
 8003820:	d0f1      	beq.n	8003806 <xQueueGenericSendFromISR+0xa2>
							if( pxHigherPriorityTaskWoken != NULL )
 8003822:	f1b8 0f00 	cmp.w	r8, #0
 8003826:	d0ee      	beq.n	8003806 <xQueueGenericSendFromISR+0xa2>
								*pxHigherPriorityTaskWoken = pdTRUE;
 8003828:	2001      	movs	r0, #1
 800382a:	f8c8 0000 	str.w	r0, [r8]
 800382e:	e7c3      	b.n	80037b8 <xQueueGenericSendFromISR+0x54>

08003830 <xQueueReceive>:
{
 8003830:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003834:	b085      	sub	sp, #20
 8003836:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
 8003838:	2800      	cmp	r0, #0
 800383a:	f000 8099 	beq.w	8003970 <xQueueReceive+0x140>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800383e:	2900      	cmp	r1, #0
 8003840:	f000 8089 	beq.w	8003956 <xQueueReceive+0x126>
 8003844:	4604      	mov	r4, r0
 8003846:	460f      	mov	r7, r1
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8003848:	f000 fd6e 	bl	8004328 <xTaskGetSchedulerState>
 800384c:	b950      	cbnz	r0, 8003864 <xQueueReceive+0x34>
 800384e:	9b01      	ldr	r3, [sp, #4]
 8003850:	b143      	cbz	r3, 8003864 <xQueueReceive+0x34>
	__asm volatile
 8003852:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003856:	f383 8811 	msr	BASEPRI, r3
 800385a:	f3bf 8f6f 	isb	sy
 800385e:	f3bf 8f4f 	dsb	sy
 8003862:	e7fe      	b.n	8003862 <xQueueReceive+0x32>
		taskENTER_CRITICAL();
 8003864:	f000 fff6 	bl	8004854 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8003868:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800386a:	2d00      	cmp	r5, #0
 800386c:	d148      	bne.n	8003900 <xQueueReceive+0xd0>
				if( xTicksToWait == ( TickType_t ) 0 )
 800386e:	9b01      	ldr	r3, [sp, #4]
 8003870:	2b00      	cmp	r3, #0
 8003872:	d06a      	beq.n	800394a <xQueueReceive+0x11a>
					vTaskInternalSetTimeOutState( &xTimeOut );
 8003874:	a802      	add	r0, sp, #8
		prvLockQueue( pxQueue );
 8003876:	462e      	mov	r6, r5
					vTaskInternalSetTimeOutState( &xTimeOut );
 8003878:	f000 fcfe 	bl	8004278 <vTaskInternalSetTimeOutState>
					portYIELD_WITHIN_API();
 800387c:	f8df 9120 	ldr.w	r9, [pc, #288]	; 80039a0 <xQueueReceive+0x170>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8003880:	f104 0824 	add.w	r8, r4, #36	; 0x24
 8003884:	e012      	b.n	80038ac <xQueueReceive+0x7c>
	taskENTER_CRITICAL();
 8003886:	f000 ffe5 	bl	8004854 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800388a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800388c:	2b00      	cmp	r3, #0
 800388e:	d046      	beq.n	800391e <xQueueReceive+0xee>
	taskEXIT_CRITICAL();
 8003890:	f001 f802 	bl	8004898 <vPortExitCritical>
				prvUnlockQueue( pxQueue );
 8003894:	4620      	mov	r0, r4
 8003896:	f7ff fdc5 	bl	8003424 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800389a:	f000 fb83 	bl	8003fa4 <xTaskResumeAll>
		taskENTER_CRITICAL();
 800389e:	f000 ffd9 	bl	8004854 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80038a2:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80038a4:	bb65      	cbnz	r5, 8003900 <xQueueReceive+0xd0>
				if( xTicksToWait == ( TickType_t ) 0 )
 80038a6:	9b01      	ldr	r3, [sp, #4]
 80038a8:	2b00      	cmp	r3, #0
 80038aa:	d04e      	beq.n	800394a <xQueueReceive+0x11a>
		taskEXIT_CRITICAL();
 80038ac:	f000 fff4 	bl	8004898 <vPortExitCritical>
		vTaskSuspendAll();
 80038b0:	f000 faca 	bl	8003e48 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 80038b4:	f000 ffce 	bl	8004854 <vPortEnterCritical>
 80038b8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80038bc:	2bff      	cmp	r3, #255	; 0xff
 80038be:	bf08      	it	eq
 80038c0:	f884 6044 	strbeq.w	r6, [r4, #68]	; 0x44
 80038c4:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80038c8:	2bff      	cmp	r3, #255	; 0xff
 80038ca:	bf08      	it	eq
 80038cc:	f884 6045 	strbeq.w	r6, [r4, #69]	; 0x45
 80038d0:	f000 ffe2 	bl	8004898 <vPortExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80038d4:	a901      	add	r1, sp, #4
 80038d6:	a802      	add	r0, sp, #8
 80038d8:	f000 fcda 	bl	8004290 <xTaskCheckForTimeOut>
 80038dc:	2800      	cmp	r0, #0
 80038de:	d0d2      	beq.n	8003886 <xQueueReceive+0x56>
			prvUnlockQueue( pxQueue );
 80038e0:	4620      	mov	r0, r4
 80038e2:	f7ff fd9f 	bl	8003424 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80038e6:	f000 fb5d 	bl	8003fa4 <xTaskResumeAll>
	taskENTER_CRITICAL();
 80038ea:	f000 ffb3 	bl	8004854 <vPortEnterCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 80038ee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80038f0:	b35b      	cbz	r3, 800394a <xQueueReceive+0x11a>
	taskEXIT_CRITICAL();
 80038f2:	f000 ffd1 	bl	8004898 <vPortExitCritical>
		taskENTER_CRITICAL();
 80038f6:	f000 ffad 	bl	8004854 <vPortEnterCritical>
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80038fa:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80038fc:	2d00      	cmp	r5, #0
 80038fe:	d0d2      	beq.n	80038a6 <xQueueReceive+0x76>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8003900:	4639      	mov	r1, r7
 8003902:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 8003904:	3d01      	subs	r5, #1
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8003906:	f7ff fd7b 	bl	8003400 <prvCopyDataFromQueue>
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800390a:	63a5      	str	r5, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800390c:	6923      	ldr	r3, [r4, #16]
 800390e:	2b00      	cmp	r3, #0
 8003910:	d137      	bne.n	8003982 <xQueueReceive+0x152>
				taskEXIT_CRITICAL();
 8003912:	f000 ffc1 	bl	8004898 <vPortExitCritical>
				return pdPASS;
 8003916:	2001      	movs	r0, #1
}
 8003918:	b005      	add	sp, #20
 800391a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	taskEXIT_CRITICAL();
 800391e:	f000 ffbb 	bl	8004898 <vPortExitCritical>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8003922:	9901      	ldr	r1, [sp, #4]
 8003924:	4640      	mov	r0, r8
 8003926:	f000 fc27 	bl	8004178 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800392a:	4620      	mov	r0, r4
 800392c:	f7ff fd7a 	bl	8003424 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8003930:	f000 fb38 	bl	8003fa4 <xTaskResumeAll>
 8003934:	2800      	cmp	r0, #0
 8003936:	d1de      	bne.n	80038f6 <xQueueReceive+0xc6>
					portYIELD_WITHIN_API();
 8003938:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800393c:	f8c9 3000 	str.w	r3, [r9]
 8003940:	f3bf 8f4f 	dsb	sy
 8003944:	f3bf 8f6f 	isb	sy
 8003948:	e7d5      	b.n	80038f6 <xQueueReceive+0xc6>
					taskEXIT_CRITICAL();
 800394a:	f000 ffa5 	bl	8004898 <vPortExitCritical>
					return errQUEUE_EMPTY;
 800394e:	2000      	movs	r0, #0
}
 8003950:	b005      	add	sp, #20
 8003952:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8003956:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8003958:	2b00      	cmp	r3, #0
 800395a:	f43f af73 	beq.w	8003844 <xQueueReceive+0x14>
 800395e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003962:	f383 8811 	msr	BASEPRI, r3
 8003966:	f3bf 8f6f 	isb	sy
 800396a:	f3bf 8f4f 	dsb	sy
 800396e:	e7fe      	b.n	800396e <xQueueReceive+0x13e>
 8003970:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003974:	f383 8811 	msr	BASEPRI, r3
 8003978:	f3bf 8f6f 	isb	sy
 800397c:	f3bf 8f4f 	dsb	sy
 8003980:	e7fe      	b.n	8003980 <xQueueReceive+0x150>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8003982:	f104 0010 	add.w	r0, r4, #16
 8003986:	f000 fc31 	bl	80041ec <xTaskRemoveFromEventList>
 800398a:	2800      	cmp	r0, #0
 800398c:	d0c1      	beq.n	8003912 <xQueueReceive+0xe2>
						queueYIELD_IF_USING_PREEMPTION();
 800398e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003992:	4b03      	ldr	r3, [pc, #12]	; (80039a0 <xQueueReceive+0x170>)
 8003994:	601a      	str	r2, [r3, #0]
 8003996:	f3bf 8f4f 	dsb	sy
 800399a:	f3bf 8f6f 	isb	sy
 800399e:	e7b8      	b.n	8003912 <xQueueReceive+0xe2>
 80039a0:	e000ed04 	.word	0xe000ed04

080039a4 <vQueueAddToRegistry>:
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80039a4:	2300      	movs	r3, #0
	{
 80039a6:	b430      	push	{r4, r5}
 80039a8:	4a07      	ldr	r2, [pc, #28]	; (80039c8 <vQueueAddToRegistry+0x24>)
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 80039aa:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
 80039ae:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 80039b2:	b124      	cbz	r4, 80039be <vQueueAddToRegistry+0x1a>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 80039b4:	3301      	adds	r3, #1
 80039b6:	2b08      	cmp	r3, #8
 80039b8:	d1f7      	bne.n	80039aa <vQueueAddToRegistry+0x6>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 80039ba:	bc30      	pop	{r4, r5}
 80039bc:	4770      	bx	lr
				xQueueRegistry[ ux ].xHandle = xQueue;
 80039be:	6068      	str	r0, [r5, #4]
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 80039c0:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	}
 80039c4:	bc30      	pop	{r4, r5}
 80039c6:	4770      	bx	lr
 80039c8:	20001cf8 	.word	0x20001cf8

080039cc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 80039cc:	b570      	push	{r4, r5, r6, lr}
 80039ce:	4604      	mov	r4, r0
 80039d0:	460d      	mov	r5, r1
 80039d2:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80039d4:	f000 ff3e 	bl	8004854 <vPortEnterCritical>
 80039d8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80039dc:	2bff      	cmp	r3, #255	; 0xff
 80039de:	bf04      	itt	eq
 80039e0:	2300      	moveq	r3, #0
 80039e2:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 80039e6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80039ea:	2bff      	cmp	r3, #255	; 0xff
 80039ec:	bf04      	itt	eq
 80039ee:	2300      	moveq	r3, #0
 80039f0:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 80039f4:	f000 ff50 	bl	8004898 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 80039f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80039fa:	b92b      	cbnz	r3, 8003a08 <vQueueWaitForMessageRestricted+0x3c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 80039fc:	4632      	mov	r2, r6
 80039fe:	4629      	mov	r1, r5
 8003a00:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8003a04:	f000 fbd2 	bl	80041ac <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 8003a08:	4620      	mov	r0, r4
	}
 8003a0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		prvUnlockQueue( pxQueue );
 8003a0e:	f7ff bd09 	b.w	8003424 <prvUnlockQueue>
 8003a12:	bf00      	nop

08003a14 <prvAddNewTaskToReadyList>:
	}
}
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 8003a14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003a18:	4605      	mov	r5, r0
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 8003a1a:	f000 ff1b 	bl	8004854 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 8003a1e:	4a33      	ldr	r2, [pc, #204]	; (8003aec <prvAddNewTaskToReadyList+0xd8>)
		if( pxCurrentTCB == NULL )
 8003a20:	4e33      	ldr	r6, [pc, #204]	; (8003af0 <prvAddNewTaskToReadyList+0xdc>)
		uxCurrentNumberOfTasks++;
 8003a22:	6813      	ldr	r3, [r2, #0]
 8003a24:	3301      	adds	r3, #1
 8003a26:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8003a28:	6833      	ldr	r3, [r6, #0]
 8003a2a:	2b00      	cmp	r3, #0
 8003a2c:	d031      	beq.n	8003a92 <prvAddNewTaskToReadyList+0x7e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 8003a2e:	4c31      	ldr	r4, [pc, #196]	; (8003af4 <prvAddNewTaskToReadyList+0xe0>)
 8003a30:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8003a32:	6823      	ldr	r3, [r4, #0]
 8003a34:	b333      	cbz	r3, 8003a84 <prvAddNewTaskToReadyList+0x70>
 8003a36:	4f30      	ldr	r7, [pc, #192]	; (8003af8 <prvAddNewTaskToReadyList+0xe4>)
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 8003a38:	4930      	ldr	r1, [pc, #192]	; (8003afc <prvAddNewTaskToReadyList+0xe8>)
		uxTaskNumber++;
 8003a3a:	4a31      	ldr	r2, [pc, #196]	; (8003b00 <prvAddNewTaskToReadyList+0xec>)
		prvAddTaskToReadyList( pxNewTCB );
 8003a3c:	f8d1 c000 	ldr.w	ip, [r1]
		uxTaskNumber++;
 8003a40:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8003a42:	4584      	cmp	ip, r0
		uxTaskNumber++;
 8003a44:	f103 0301 	add.w	r3, r3, #1
		prvAddTaskToReadyList( pxNewTCB );
 8003a48:	bf38      	it	cc
 8003a4a:	6008      	strcc	r0, [r1, #0]
 8003a4c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8003a50:	646b      	str	r3, [r5, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8003a52:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8003a56:	1d29      	adds	r1, r5, #4
		uxTaskNumber++;
 8003a58:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8003a5a:	f7ff fc57 	bl	800330c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 8003a5e:	f000 ff1b 	bl	8004898 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 8003a62:	6823      	ldr	r3, [r4, #0]
 8003a64:	b163      	cbz	r3, 8003a80 <prvAddNewTaskToReadyList+0x6c>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8003a66:	6832      	ldr	r2, [r6, #0]
 8003a68:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8003a6a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8003a6c:	429a      	cmp	r2, r3
 8003a6e:	d207      	bcs.n	8003a80 <prvAddNewTaskToReadyList+0x6c>
		{
			taskYIELD_IF_USING_PREEMPTION();
 8003a70:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003a74:	4b23      	ldr	r3, [pc, #140]	; (8003b04 <prvAddNewTaskToReadyList+0xf0>)
 8003a76:	601a      	str	r2, [r3, #0]
 8003a78:	f3bf 8f4f 	dsb	sy
 8003a7c:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8003a80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8003a84:	6833      	ldr	r3, [r6, #0]
 8003a86:	4f1c      	ldr	r7, [pc, #112]	; (8003af8 <prvAddNewTaskToReadyList+0xe4>)
 8003a88:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003a8a:	4283      	cmp	r3, r0
					pxCurrentTCB = pxNewTCB;
 8003a8c:	bf98      	it	ls
 8003a8e:	6035      	strls	r5, [r6, #0]
 8003a90:	e7d2      	b.n	8003a38 <prvAddNewTaskToReadyList+0x24>
			pxCurrentTCB = pxNewTCB;
 8003a92:	6035      	str	r5, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8003a94:	6813      	ldr	r3, [r2, #0]
 8003a96:	2b01      	cmp	r3, #1
 8003a98:	d003      	beq.n	8003aa2 <prvAddNewTaskToReadyList+0x8e>
 8003a9a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8003a9c:	4f16      	ldr	r7, [pc, #88]	; (8003af8 <prvAddNewTaskToReadyList+0xe4>)
 8003a9e:	4c15      	ldr	r4, [pc, #84]	; (8003af4 <prvAddNewTaskToReadyList+0xe0>)
 8003aa0:	e7ca      	b.n	8003a38 <prvAddNewTaskToReadyList+0x24>
 8003aa2:	4f15      	ldr	r7, [pc, #84]	; (8003af8 <prvAddNewTaskToReadyList+0xe4>)
 8003aa4:	463c      	mov	r4, r7
 8003aa6:	f507 688c 	add.w	r8, r7, #1120	; 0x460
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8003aaa:	4620      	mov	r0, r4
 8003aac:	3414      	adds	r4, #20
 8003aae:	f7ff fc1d 	bl	80032ec <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8003ab2:	4544      	cmp	r4, r8
 8003ab4:	d1f9      	bne.n	8003aaa <prvAddNewTaskToReadyList+0x96>
	}

	vListInitialise( &xDelayedTaskList1 );
 8003ab6:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8003b20 <prvAddNewTaskToReadyList+0x10c>
	vListInitialise( &xDelayedTaskList2 );
 8003aba:	4c13      	ldr	r4, [pc, #76]	; (8003b08 <prvAddNewTaskToReadyList+0xf4>)
	vListInitialise( &xDelayedTaskList1 );
 8003abc:	4640      	mov	r0, r8
 8003abe:	f7ff fc15 	bl	80032ec <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8003ac2:	4620      	mov	r0, r4
 8003ac4:	f7ff fc12 	bl	80032ec <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8003ac8:	4810      	ldr	r0, [pc, #64]	; (8003b0c <prvAddNewTaskToReadyList+0xf8>)
 8003aca:	f7ff fc0f 	bl	80032ec <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8003ace:	4810      	ldr	r0, [pc, #64]	; (8003b10 <prvAddNewTaskToReadyList+0xfc>)
 8003ad0:	f7ff fc0c 	bl	80032ec <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8003ad4:	480f      	ldr	r0, [pc, #60]	; (8003b14 <prvAddNewTaskToReadyList+0x100>)
 8003ad6:	f7ff fc09 	bl	80032ec <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8003ada:	4a0f      	ldr	r2, [pc, #60]	; (8003b18 <prvAddNewTaskToReadyList+0x104>)
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8003adc:	4b0f      	ldr	r3, [pc, #60]	; (8003b1c <prvAddNewTaskToReadyList+0x108>)
	pxDelayedTaskList = &xDelayedTaskList1;
 8003ade:	f8c2 8000 	str.w	r8, [r2]
 8003ae2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8003ae4:	601c      	str	r4, [r3, #0]
 8003ae6:	4c03      	ldr	r4, [pc, #12]	; (8003af4 <prvAddNewTaskToReadyList+0xe0>)
 8003ae8:	e7a6      	b.n	8003a38 <prvAddNewTaskToReadyList+0x24>
 8003aea:	bf00      	nop
 8003aec:	20000d38 	.word	0x20000d38
 8003af0:	200008cc 	.word	0x200008cc
 8003af4:	20000d94 	.word	0x20000d94
 8003af8:	200008d8 	.word	0x200008d8
 8003afc:	20000d4c 	.word	0x20000d4c
 8003b00:	20000d48 	.word	0x20000d48
 8003b04:	e000ed04 	.word	0xe000ed04
 8003b08:	20000d64 	.word	0x20000d64
 8003b0c:	20000d80 	.word	0x20000d80
 8003b10:	20000dac 	.word	0x20000dac
 8003b14:	20000d98 	.word	0x20000d98
 8003b18:	200008d0 	.word	0x200008d0
 8003b1c:	200008d4 	.word	0x200008d4
 8003b20:	20000d50 	.word	0x20000d50

08003b24 <prvDeleteTCB>:
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 8003b24:	f890 3059 	ldrb.w	r3, [r0, #89]	; 0x59
 8003b28:	b163      	cbz	r3, 8003b44 <prvDeleteTCB+0x20>
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
				vPortFree( pxTCB );
			}
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 8003b2a:	2b01      	cmp	r3, #1
 8003b2c:	d014      	beq.n	8003b58 <prvDeleteTCB+0x34>
			}
			else
			{
				/* Neither the stack nor the TCB were allocated dynamically, so
				nothing needs to be freed. */
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 8003b2e:	2b02      	cmp	r3, #2
 8003b30:	d014      	beq.n	8003b5c <prvDeleteTCB+0x38>
 8003b32:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003b36:	f383 8811 	msr	BASEPRI, r3
 8003b3a:	f3bf 8f6f 	isb	sy
 8003b3e:	f3bf 8f4f 	dsb	sy
 8003b42:	e7fe      	b.n	8003b42 <prvDeleteTCB+0x1e>
	{
 8003b44:	b510      	push	{r4, lr}
 8003b46:	4604      	mov	r4, r0
				vPortFree( pxTCB->pxStack );
 8003b48:	6b00      	ldr	r0, [r0, #48]	; 0x30
 8003b4a:	f001 f85b 	bl	8004c04 <vPortFree>
				vPortFree( pxTCB );
 8003b4e:	4620      	mov	r0, r4
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 8003b50:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				vPortFree( pxTCB );
 8003b54:	f001 b856 	b.w	8004c04 <vPortFree>
				vPortFree( pxTCB );
 8003b58:	f001 b854 	b.w	8004c04 <vPortFree>
 8003b5c:	4770      	bx	lr
 8003b5e:	bf00      	nop

08003b60 <prvIdleTask>:
{
 8003b60:	b580      	push	{r7, lr}
				taskYIELD();
 8003b62:	f04f 5980 	mov.w	r9, #268435456	; 0x10000000
 8003b66:	4c14      	ldr	r4, [pc, #80]	; (8003bb8 <prvIdleTask+0x58>)
 8003b68:	4e14      	ldr	r6, [pc, #80]	; (8003bbc <prvIdleTask+0x5c>)
 8003b6a:	4d15      	ldr	r5, [pc, #84]	; (8003bc0 <prvIdleTask+0x60>)
 8003b6c:	f8df a054 	ldr.w	sl, [pc, #84]	; 8003bc4 <prvIdleTask+0x64>
 8003b70:	f8df 8054 	ldr.w	r8, [pc, #84]	; 8003bc8 <prvIdleTask+0x68>
 8003b74:	e011      	b.n	8003b9a <prvIdleTask+0x3a>
			taskENTER_CRITICAL();
 8003b76:	f000 fe6d 	bl	8004854 <vPortEnterCritical>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8003b7a:	68f3      	ldr	r3, [r6, #12]
 8003b7c:	68df      	ldr	r7, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003b7e:	1d38      	adds	r0, r7, #4
 8003b80:	f7ff fbec 	bl	800335c <uxListRemove>
				--uxCurrentNumberOfTasks;
 8003b84:	682b      	ldr	r3, [r5, #0]
 8003b86:	3b01      	subs	r3, #1
 8003b88:	602b      	str	r3, [r5, #0]
				--uxDeletedTasksWaitingCleanUp;
 8003b8a:	6823      	ldr	r3, [r4, #0]
 8003b8c:	3b01      	subs	r3, #1
 8003b8e:	6023      	str	r3, [r4, #0]
			taskEXIT_CRITICAL();
 8003b90:	f000 fe82 	bl	8004898 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8003b94:	4638      	mov	r0, r7
 8003b96:	f7ff ffc5 	bl	8003b24 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8003b9a:	6823      	ldr	r3, [r4, #0]
 8003b9c:	2b00      	cmp	r3, #0
 8003b9e:	d1ea      	bne.n	8003b76 <prvIdleTask+0x16>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8003ba0:	f8da 3000 	ldr.w	r3, [sl]
 8003ba4:	2b01      	cmp	r3, #1
 8003ba6:	d9f8      	bls.n	8003b9a <prvIdleTask+0x3a>
				taskYIELD();
 8003ba8:	f8c8 9000 	str.w	r9, [r8]
 8003bac:	f3bf 8f4f 	dsb	sy
 8003bb0:	f3bf 8f6f 	isb	sy
 8003bb4:	e7f1      	b.n	8003b9a <prvIdleTask+0x3a>
 8003bb6:	bf00      	nop
 8003bb8:	20000d3c 	.word	0x20000d3c
 8003bbc:	20000dac 	.word	0x20000dac
 8003bc0:	20000d38 	.word	0x20000d38
 8003bc4:	200008d8 	.word	0x200008d8
 8003bc8:	e000ed04 	.word	0xe000ed04

08003bcc <prvResetNextTaskUnblockTime.part.1>:
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003bcc:	4a03      	ldr	r2, [pc, #12]	; (8003bdc <prvResetNextTaskUnblockTime.part.1+0x10>)
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8003bce:	4b04      	ldr	r3, [pc, #16]	; (8003be0 <prvResetNextTaskUnblockTime.part.1+0x14>)
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003bd0:	6812      	ldr	r2, [r2, #0]
 8003bd2:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8003bd4:	68d2      	ldr	r2, [r2, #12]
 8003bd6:	6852      	ldr	r2, [r2, #4]
 8003bd8:	601a      	str	r2, [r3, #0]
	}
}
 8003bda:	4770      	bx	lr
 8003bdc:	200008d0 	.word	0x200008d0
 8003be0:	20000d78 	.word	0x20000d78

08003be4 <prvInitialiseNewTask.isra.2>:
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8003be4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003be8:	468a      	mov	sl, r1
 8003bea:	e9dd 5608 	ldrd	r5, r6, [sp, #32]
 8003bee:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003bf0:	ea4f 0982 	mov.w	r9, r2, lsl #2
 8003bf4:	464a      	mov	r2, r9
 8003bf6:	21a5      	movs	r1, #165	; 0xa5
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8003bf8:	4607      	mov	r7, r0
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003bfa:	6b20      	ldr	r0, [r4, #48]	; 0x30
static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
 8003bfc:	4698      	mov	r8, r3
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8003bfe:	f001 f896 	bl	8004d2e <memset>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8003c02:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003c04:	f1a9 0904 	sub.w	r9, r9, #4
 8003c08:	4499      	add	r9, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8003c0a:	f029 0907 	bic.w	r9, r9, #7
 8003c0e:	f10a 33ff 	add.w	r3, sl, #4294967295
 8003c12:	f10a 010f 	add.w	r1, sl, #15
 8003c16:	f104 0233 	add.w	r2, r4, #51	; 0x33
 8003c1a:	e001      	b.n	8003c20 <prvInitialiseNewTask.isra.2+0x3c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8003c1c:	428b      	cmp	r3, r1
 8003c1e:	d006      	beq.n	8003c2e <prvInitialiseNewTask.isra.2+0x4a>
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8003c20:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 8003c24:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
 8003c28:	7818      	ldrb	r0, [r3, #0]
 8003c2a:	2800      	cmp	r0, #0
 8003c2c:	d1f6      	bne.n	8003c1c <prvInitialiseNewTask.isra.2+0x38>
 8003c2e:	2d37      	cmp	r5, #55	; 0x37
 8003c30:	bf28      	it	cs
 8003c32:	2537      	movcs	r5, #55	; 0x37
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8003c34:	f04f 0a00 	mov.w	sl, #0
	pxNewTCB->uxPriority = uxPriority;
 8003c38:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8003c3a:	64e5      	str	r5, [r4, #76]	; 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8003c3c:	1d20      	adds	r0, r4, #4
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8003c3e:	f884 a043 	strb.w	sl, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8003c42:	f8c4 a050 	str.w	sl, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8003c46:	f7ff fb5d 	bl	8003304 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003c4a:	f1c5 0538 	rsb	r5, r5, #56	; 0x38
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8003c4e:	f104 0018 	add.w	r0, r4, #24
 8003c52:	f7ff fb57 	bl	8003304 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8003c56:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003c5a:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8003c5c:	6124      	str	r4, [r4, #16]
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8003c5e:	f884 a058 	strb.w	sl, [r4, #88]	; 0x58
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8003c62:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8003c64:	4642      	mov	r2, r8
 8003c66:	4639      	mov	r1, r7
 8003c68:	4648      	mov	r0, r9
 8003c6a:	f000 fdcf 	bl	800480c <pxPortInitialiseStack>
 8003c6e:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8003c70:	b106      	cbz	r6, 8003c74 <prvInitialiseNewTask.isra.2+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8003c72:	6034      	str	r4, [r6, #0]
}
 8003c74:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08003c78 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8003c78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c7a:	4605      	mov	r5, r0
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8003c7c:	4b15      	ldr	r3, [pc, #84]	; (8003cd4 <prvAddCurrentTaskToDelayedList+0x5c>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003c7e:	4e16      	ldr	r6, [pc, #88]	; (8003cd8 <prvAddCurrentTaskToDelayedList+0x60>)
const TickType_t xConstTickCount = xTickCount;
 8003c80:	681c      	ldr	r4, [r3, #0]
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003c82:	6830      	ldr	r0, [r6, #0]
{
 8003c84:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8003c86:	3004      	adds	r0, #4
 8003c88:	f7ff fb68 	bl	800335c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8003c8c:	1c6b      	adds	r3, r5, #1
 8003c8e:	d017      	beq.n	8003cc0 <prvAddCurrentTaskToDelayedList+0x48>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8003c90:	6833      	ldr	r3, [r6, #0]
 8003c92:	1964      	adds	r4, r4, r5
 8003c94:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8003c96:	d20b      	bcs.n	8003cb0 <prvAddCurrentTaskToDelayedList+0x38>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003c98:	4b10      	ldr	r3, [pc, #64]	; (8003cdc <prvAddCurrentTaskToDelayedList+0x64>)
 8003c9a:	6818      	ldr	r0, [r3, #0]
 8003c9c:	6831      	ldr	r1, [r6, #0]
 8003c9e:	3104      	adds	r1, #4
 8003ca0:	f7ff fb42 	bl	8003328 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 8003ca4:	4b0e      	ldr	r3, [pc, #56]	; (8003ce0 <prvAddCurrentTaskToDelayedList+0x68>)
 8003ca6:	681a      	ldr	r2, [r3, #0]
 8003ca8:	42a2      	cmp	r2, r4
				{
					xNextTaskUnblockTime = xTimeToWake;
 8003caa:	bf88      	it	hi
 8003cac:	601c      	strhi	r4, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8003cae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003cb0:	4b0c      	ldr	r3, [pc, #48]	; (8003ce4 <prvAddCurrentTaskToDelayedList+0x6c>)
 8003cb2:	6818      	ldr	r0, [r3, #0]
 8003cb4:	6831      	ldr	r1, [r6, #0]
}
 8003cb6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003cba:	3104      	adds	r1, #4
 8003cbc:	f7ff bb34 	b.w	8003328 <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8003cc0:	2f00      	cmp	r7, #0
 8003cc2:	d0e5      	beq.n	8003c90 <prvAddCurrentTaskToDelayedList+0x18>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003cc4:	6831      	ldr	r1, [r6, #0]
 8003cc6:	4808      	ldr	r0, [pc, #32]	; (8003ce8 <prvAddCurrentTaskToDelayedList+0x70>)
 8003cc8:	3104      	adds	r1, #4
}
 8003cca:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8003cce:	f7ff bb1d 	b.w	800330c <vListInsertEnd>
 8003cd2:	bf00      	nop
 8003cd4:	20000dc0 	.word	0x20000dc0
 8003cd8:	200008cc 	.word	0x200008cc
 8003cdc:	200008d0 	.word	0x200008d0
 8003ce0:	20000d78 	.word	0x20000d78
 8003ce4:	200008d4 	.word	0x200008d4
 8003ce8:	20000d98 	.word	0x20000d98

08003cec <xTaskCreateStatic>:
	{
 8003cec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003cee:	b087      	sub	sp, #28
 8003cf0:	e9dd 650c 	ldrd	r6, r5, [sp, #48]	; 0x30
 8003cf4:	9c0e      	ldr	r4, [sp, #56]	; 0x38
		configASSERT( puxStackBuffer != NULL );
 8003cf6:	b1bd      	cbz	r5, 8003d28 <xTaskCreateStatic+0x3c>
		configASSERT( pxTaskBuffer != NULL );
 8003cf8:	b16c      	cbz	r4, 8003d16 <xTaskCreateStatic+0x2a>
			volatile size_t xSize = sizeof( StaticTask_t );
 8003cfa:	275c      	movs	r7, #92	; 0x5c
 8003cfc:	9704      	str	r7, [sp, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 8003cfe:	9f04      	ldr	r7, [sp, #16]
 8003d00:	2f5c      	cmp	r7, #92	; 0x5c
 8003d02:	d01a      	beq.n	8003d3a <xTaskCreateStatic+0x4e>
 8003d04:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d08:	f383 8811 	msr	BASEPRI, r3
 8003d0c:	f3bf 8f6f 	isb	sy
 8003d10:	f3bf 8f4f 	dsb	sy
 8003d14:	e7fe      	b.n	8003d14 <xTaskCreateStatic+0x28>
 8003d16:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d1a:	f383 8811 	msr	BASEPRI, r3
 8003d1e:	f3bf 8f6f 	isb	sy
 8003d22:	f3bf 8f4f 	dsb	sy
 8003d26:	e7fe      	b.n	8003d26 <xTaskCreateStatic+0x3a>
 8003d28:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d2c:	f383 8811 	msr	BASEPRI, r3
 8003d30:	f3bf 8f6f 	isb	sy
 8003d34:	f3bf 8f4f 	dsb	sy
 8003d38:	e7fe      	b.n	8003d38 <xTaskCreateStatic+0x4c>
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8003d3a:	2702      	movs	r7, #2
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8003d3c:	6325      	str	r5, [r4, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8003d3e:	ad05      	add	r5, sp, #20
 8003d40:	9402      	str	r4, [sp, #8]
 8003d42:	9600      	str	r6, [sp, #0]
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8003d44:	f884 7059 	strb.w	r7, [r4, #89]	; 0x59
			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 8003d48:	9501      	str	r5, [sp, #4]
 8003d4a:	f7ff ff4b 	bl	8003be4 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8003d4e:	4620      	mov	r0, r4
 8003d50:	f7ff fe60 	bl	8003a14 <prvAddNewTaskToReadyList>
	}
 8003d54:	9805      	ldr	r0, [sp, #20]
 8003d56:	b007      	add	sp, #28
 8003d58:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003d5a:	bf00      	nop

08003d5c <xTaskCreate>:
	{
 8003d5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003d60:	4607      	mov	r7, r0
 8003d62:	b085      	sub	sp, #20
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003d64:	0090      	lsls	r0, r2, #2
	{
 8003d66:	4616      	mov	r6, r2
 8003d68:	4688      	mov	r8, r1
 8003d6a:	4699      	mov	r9, r3
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003d6c:	f000 feb0 	bl	8004ad0 <pvPortMalloc>
			if( pxStack != NULL )
 8003d70:	b320      	cbz	r0, 8003dbc <xTaskCreate+0x60>
 8003d72:	4605      	mov	r5, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8003d74:	205c      	movs	r0, #92	; 0x5c
 8003d76:	f000 feab 	bl	8004ad0 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8003d7a:	4604      	mov	r4, r0
 8003d7c:	b1b0      	cbz	r0, 8003dac <xTaskCreate+0x50>
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8003d7e:	f04f 0c00 	mov.w	ip, #0
					pxNewTCB->pxStack = pxStack;
 8003d82:	6305      	str	r5, [r0, #48]	; 0x30
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003d84:	9d0d      	ldr	r5, [sp, #52]	; 0x34
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 8003d86:	f884 c059 	strb.w	ip, [r4, #89]	; 0x59
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8003d8a:	9501      	str	r5, [sp, #4]
 8003d8c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8003d8e:	464b      	mov	r3, r9
 8003d90:	4632      	mov	r2, r6
 8003d92:	4641      	mov	r1, r8
 8003d94:	4638      	mov	r0, r7
 8003d96:	9402      	str	r4, [sp, #8]
 8003d98:	9500      	str	r5, [sp, #0]
 8003d9a:	f7ff ff23 	bl	8003be4 <prvInitialiseNewTask.isra.2>
			prvAddNewTaskToReadyList( pxNewTCB );
 8003d9e:	4620      	mov	r0, r4
 8003da0:	f7ff fe38 	bl	8003a14 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8003da4:	2001      	movs	r0, #1
	}
 8003da6:	b005      	add	sp, #20
 8003da8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 8003dac:	4628      	mov	r0, r5
 8003dae:	f000 ff29 	bl	8004c04 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003db2:	f04f 30ff 	mov.w	r0, #4294967295
	}
 8003db6:	b005      	add	sp, #20
 8003db8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8003dbc:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 8003dc0:	e7f1      	b.n	8003da6 <xTaskCreate+0x4a>
 8003dc2:	bf00      	nop

08003dc4 <vTaskStartScheduler>:
{
 8003dc4:	b530      	push	{r4, r5, lr}
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 8003dc6:	2400      	movs	r4, #0
{
 8003dc8:	b089      	sub	sp, #36	; 0x24
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8003dca:	aa07      	add	r2, sp, #28
 8003dcc:	a906      	add	r1, sp, #24
 8003dce:	a805      	add	r0, sp, #20
		StackType_t *pxIdleTaskStackBuffer = NULL;
 8003dd0:	e9cd 4405 	strd	r4, r4, [sp, #20]
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 8003dd4:	f7ff fa6e 	bl	80032b4 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 8003dd8:	a805      	add	r0, sp, #20
 8003dda:	c807      	ldmia	r0, {r0, r1, r2}
 8003ddc:	4623      	mov	r3, r4
 8003dde:	e9cd 1001 	strd	r1, r0, [sp, #4]
 8003de2:	9400      	str	r4, [sp, #0]
 8003de4:	4913      	ldr	r1, [pc, #76]	; (8003e34 <vTaskStartScheduler+0x70>)
 8003de6:	4814      	ldr	r0, [pc, #80]	; (8003e38 <vTaskStartScheduler+0x74>)
 8003de8:	f7ff ff80 	bl	8003cec <xTaskCreateStatic>
		if( xIdleTaskHandle != NULL )
 8003dec:	b300      	cbz	r0, 8003e30 <vTaskStartScheduler+0x6c>
			xReturn = xTimerCreateTimerTask();
 8003dee:	f000 fb49 	bl	8004484 <xTimerCreateTimerTask>
	if( xReturn == pdPASS )
 8003df2:	2801      	cmp	r0, #1
 8003df4:	d00a      	beq.n	8003e0c <vTaskStartScheduler+0x48>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8003df6:	3001      	adds	r0, #1
 8003df8:	d11a      	bne.n	8003e30 <vTaskStartScheduler+0x6c>
 8003dfa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003dfe:	f383 8811 	msr	BASEPRI, r3
 8003e02:	f3bf 8f6f 	isb	sy
 8003e06:	f3bf 8f4f 	dsb	sy
 8003e0a:	e7fe      	b.n	8003e0a <vTaskStartScheduler+0x46>
 8003e0c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003e10:	f383 8811 	msr	BASEPRI, r3
 8003e14:	f3bf 8f6f 	isb	sy
 8003e18:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8003e1c:	f04f 35ff 	mov.w	r5, #4294967295
 8003e20:	4906      	ldr	r1, [pc, #24]	; (8003e3c <vTaskStartScheduler+0x78>)
		xSchedulerRunning = pdTRUE;
 8003e22:	4a07      	ldr	r2, [pc, #28]	; (8003e40 <vTaskStartScheduler+0x7c>)
		xTickCount = ( TickType_t ) 0U;
 8003e24:	4b07      	ldr	r3, [pc, #28]	; (8003e44 <vTaskStartScheduler+0x80>)
		xNextTaskUnblockTime = portMAX_DELAY;
 8003e26:	600d      	str	r5, [r1, #0]
		xSchedulerRunning = pdTRUE;
 8003e28:	6010      	str	r0, [r2, #0]
		xTickCount = ( TickType_t ) 0U;
 8003e2a:	601c      	str	r4, [r3, #0]
		if( xPortStartScheduler() != pdFALSE )
 8003e2c:	f000 fd9e 	bl	800496c <xPortStartScheduler>
}
 8003e30:	b009      	add	sp, #36	; 0x24
 8003e32:	bd30      	pop	{r4, r5, pc}
 8003e34:	080066e8 	.word	0x080066e8
 8003e38:	08003b61 	.word	0x08003b61
 8003e3c:	20000d78 	.word	0x20000d78
 8003e40:	20000d94 	.word	0x20000d94
 8003e44:	20000dc0 	.word	0x20000dc0

08003e48 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8003e48:	4a02      	ldr	r2, [pc, #8]	; (8003e54 <vTaskSuspendAll+0xc>)
 8003e4a:	6813      	ldr	r3, [r2, #0]
 8003e4c:	3301      	adds	r3, #1
 8003e4e:	6013      	str	r3, [r2, #0]
}
 8003e50:	4770      	bx	lr
 8003e52:	bf00      	nop
 8003e54:	20000d44 	.word	0x20000d44

08003e58 <xTaskGetTickCount>:
		xTicks = xTickCount;
 8003e58:	4b01      	ldr	r3, [pc, #4]	; (8003e60 <xTaskGetTickCount+0x8>)
 8003e5a:	6818      	ldr	r0, [r3, #0]
}
 8003e5c:	4770      	bx	lr
 8003e5e:	bf00      	nop
 8003e60:	20000dc0 	.word	0x20000dc0

08003e64 <xTaskIncrementTick>:
{
 8003e64:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003e68:	4b43      	ldr	r3, [pc, #268]	; (8003f78 <xTaskIncrementTick+0x114>)
 8003e6a:	681b      	ldr	r3, [r3, #0]
 8003e6c:	b9cb      	cbnz	r3, 8003ea2 <xTaskIncrementTick+0x3e>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8003e6e:	4b43      	ldr	r3, [pc, #268]	; (8003f7c <xTaskIncrementTick+0x118>)
 8003e70:	681f      	ldr	r7, [r3, #0]
 8003e72:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
 8003e74:	601f      	str	r7, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8003e76:	b30f      	cbz	r7, 8003ebc <xTaskIncrementTick+0x58>
 8003e78:	4e41      	ldr	r6, [pc, #260]	; (8003f80 <xTaskIncrementTick+0x11c>)
		if( xConstTickCount >= xNextTaskUnblockTime )
 8003e7a:	6833      	ldr	r3, [r6, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8003e7c:	2400      	movs	r4, #0
		if( xConstTickCount >= xNextTaskUnblockTime )
 8003e7e:	42bb      	cmp	r3, r7
 8003e80:	d92a      	bls.n	8003ed8 <xTaskIncrementTick+0x74>
 8003e82:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8003f9c <xTaskIncrementTick+0x138>
 8003e86:	f8df 9118 	ldr.w	r9, [pc, #280]	; 8003fa0 <xTaskIncrementTick+0x13c>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8003e8a:	f8d9 3000 	ldr.w	r3, [r9]
 8003e8e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003e90:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8003e94:	009b      	lsls	r3, r3, #2
 8003e96:	f858 3003 	ldr.w	r3, [r8, r3]
				xSwitchRequired = pdTRUE;
 8003e9a:	2b02      	cmp	r3, #2
 8003e9c:	bf28      	it	cs
 8003e9e:	2401      	movcs	r4, #1
 8003ea0:	e004      	b.n	8003eac <xTaskIncrementTick+0x48>
BaseType_t xSwitchRequired = pdFALSE;
 8003ea2:	2400      	movs	r4, #0
		++uxPendedTicks;
 8003ea4:	4a37      	ldr	r2, [pc, #220]	; (8003f84 <xTaskIncrementTick+0x120>)
 8003ea6:	6813      	ldr	r3, [r2, #0]
 8003ea8:	3301      	adds	r3, #1
 8003eaa:	6013      	str	r3, [r2, #0]
		if( xYieldPending != pdFALSE )
 8003eac:	4b36      	ldr	r3, [pc, #216]	; (8003f88 <xTaskIncrementTick+0x124>)
 8003eae:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
 8003eb0:	2b00      	cmp	r3, #0
}
 8003eb2:	bf0c      	ite	eq
 8003eb4:	4620      	moveq	r0, r4
 8003eb6:	2001      	movne	r0, #1
 8003eb8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 8003ebc:	4d33      	ldr	r5, [pc, #204]	; (8003f8c <xTaskIncrementTick+0x128>)
 8003ebe:	682b      	ldr	r3, [r5, #0]
 8003ec0:	681b      	ldr	r3, [r3, #0]
 8003ec2:	2b00      	cmp	r3, #0
 8003ec4:	d044      	beq.n	8003f50 <xTaskIncrementTick+0xec>
 8003ec6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003eca:	f383 8811 	msr	BASEPRI, r3
 8003ece:	f3bf 8f6f 	isb	sy
 8003ed2:	f3bf 8f4f 	dsb	sy
 8003ed6:	e7fe      	b.n	8003ed6 <xTaskIncrementTick+0x72>
 8003ed8:	4d2c      	ldr	r5, [pc, #176]	; (8003f8c <xTaskIncrementTick+0x128>)
 8003eda:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8003f9c <xTaskIncrementTick+0x138>
 8003ede:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 8003fa0 <xTaskIncrementTick+0x13c>
 8003ee2:	e02b      	b.n	8003f3c <xTaskIncrementTick+0xd8>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003ee4:	682b      	ldr	r3, [r5, #0]
 8003ee6:	68db      	ldr	r3, [r3, #12]
 8003ee8:	f8d3 a00c 	ldr.w	sl, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8003eec:	f8da 2004 	ldr.w	r2, [sl, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003ef0:	f10a 0b04 	add.w	fp, sl, #4
					if( xConstTickCount < xItemValue )
 8003ef4:	4297      	cmp	r7, r2
 8003ef6:	d329      	bcc.n	8003f4c <xTaskIncrementTick+0xe8>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003ef8:	4658      	mov	r0, fp
 8003efa:	f7ff fa2f 	bl	800335c <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003efe:	f8da 2028 	ldr.w	r2, [sl, #40]	; 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003f02:	f10a 0018 	add.w	r0, sl, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003f06:	b10a      	cbz	r2, 8003f0c <xTaskIncrementTick+0xa8>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003f08:	f7ff fa28 	bl	800335c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003f0c:	4b20      	ldr	r3, [pc, #128]	; (8003f90 <xTaskIncrementTick+0x12c>)
 8003f0e:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
 8003f12:	681b      	ldr	r3, [r3, #0]
 8003f14:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 8003f18:	429a      	cmp	r2, r3
 8003f1a:	bf88      	it	hi
 8003f1c:	4b1c      	ldrhi	r3, [pc, #112]	; (8003f90 <xTaskIncrementTick+0x12c>)
 8003f1e:	4659      	mov	r1, fp
 8003f20:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 8003f24:	bf88      	it	hi
 8003f26:	601a      	strhi	r2, [r3, #0]
 8003f28:	f7ff f9f0 	bl	800330c <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003f2c:	f8d9 1000 	ldr.w	r1, [r9]
 8003f30:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
 8003f34:	6acb      	ldr	r3, [r1, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 8003f36:	429a      	cmp	r2, r3
 8003f38:	bf28      	it	cs
 8003f3a:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003f3c:	682b      	ldr	r3, [r5, #0]
 8003f3e:	681b      	ldr	r3, [r3, #0]
 8003f40:	2b00      	cmp	r3, #0
 8003f42:	d1cf      	bne.n	8003ee4 <xTaskIncrementTick+0x80>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003f44:	f04f 33ff 	mov.w	r3, #4294967295
 8003f48:	6033      	str	r3, [r6, #0]
					break;
 8003f4a:	e79e      	b.n	8003e8a <xTaskIncrementTick+0x26>
						xNextTaskUnblockTime = xItemValue;
 8003f4c:	6032      	str	r2, [r6, #0]
						break;
 8003f4e:	e79c      	b.n	8003e8a <xTaskIncrementTick+0x26>
			taskSWITCH_DELAYED_LISTS();
 8003f50:	4b10      	ldr	r3, [pc, #64]	; (8003f94 <xTaskIncrementTick+0x130>)
 8003f52:	6829      	ldr	r1, [r5, #0]
 8003f54:	6818      	ldr	r0, [r3, #0]
 8003f56:	4a10      	ldr	r2, [pc, #64]	; (8003f98 <xTaskIncrementTick+0x134>)
 8003f58:	6028      	str	r0, [r5, #0]
 8003f5a:	6019      	str	r1, [r3, #0]
 8003f5c:	6813      	ldr	r3, [r2, #0]
 8003f5e:	3301      	adds	r3, #1
 8003f60:	6013      	str	r3, [r2, #0]
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003f62:	682b      	ldr	r3, [r5, #0]
 8003f64:	681b      	ldr	r3, [r3, #0]
 8003f66:	b923      	cbnz	r3, 8003f72 <xTaskIncrementTick+0x10e>
		xNextTaskUnblockTime = portMAX_DELAY;
 8003f68:	f04f 33ff 	mov.w	r3, #4294967295
 8003f6c:	4e04      	ldr	r6, [pc, #16]	; (8003f80 <xTaskIncrementTick+0x11c>)
 8003f6e:	6033      	str	r3, [r6, #0]
 8003f70:	e783      	b.n	8003e7a <xTaskIncrementTick+0x16>
 8003f72:	f7ff fe2b 	bl	8003bcc <prvResetNextTaskUnblockTime.part.1>
 8003f76:	e77f      	b.n	8003e78 <xTaskIncrementTick+0x14>
 8003f78:	20000d44 	.word	0x20000d44
 8003f7c:	20000dc0 	.word	0x20000dc0
 8003f80:	20000d78 	.word	0x20000d78
 8003f84:	20000d40 	.word	0x20000d40
 8003f88:	20000dc4 	.word	0x20000dc4
 8003f8c:	200008d0 	.word	0x200008d0
 8003f90:	20000d4c 	.word	0x20000d4c
 8003f94:	200008d4 	.word	0x200008d4
 8003f98:	20000d7c 	.word	0x20000d7c
 8003f9c:	200008d8 	.word	0x200008d8
 8003fa0:	200008cc 	.word	0x200008cc

08003fa4 <xTaskResumeAll>:
{
 8003fa4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	configASSERT( uxSchedulerSuspended );
 8003fa8:	4c34      	ldr	r4, [pc, #208]	; (800407c <xTaskResumeAll+0xd8>)
 8003faa:	6823      	ldr	r3, [r4, #0]
 8003fac:	b943      	cbnz	r3, 8003fc0 <xTaskResumeAll+0x1c>
 8003fae:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003fb2:	f383 8811 	msr	BASEPRI, r3
 8003fb6:	f3bf 8f6f 	isb	sy
 8003fba:	f3bf 8f4f 	dsb	sy
 8003fbe:	e7fe      	b.n	8003fbe <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8003fc0:	f000 fc48 	bl	8004854 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8003fc4:	6823      	ldr	r3, [r4, #0]
 8003fc6:	3b01      	subs	r3, #1
 8003fc8:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003fca:	6824      	ldr	r4, [r4, #0]
 8003fcc:	bb5c      	cbnz	r4, 8004026 <xTaskResumeAll+0x82>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8003fce:	4b2c      	ldr	r3, [pc, #176]	; (8004080 <xTaskResumeAll+0xdc>)
 8003fd0:	681b      	ldr	r3, [r3, #0]
 8003fd2:	b343      	cbz	r3, 8004026 <xTaskResumeAll+0x82>
 8003fd4:	4e2b      	ldr	r6, [pc, #172]	; (8004084 <xTaskResumeAll+0xe0>)
 8003fd6:	4f2c      	ldr	r7, [pc, #176]	; (8004088 <xTaskResumeAll+0xe4>)
					prvAddTaskToReadyList( pxTCB );
 8003fd8:	4d2c      	ldr	r5, [pc, #176]	; (800408c <xTaskResumeAll+0xe8>)
 8003fda:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 80040a0 <xTaskResumeAll+0xfc>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003fde:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 80040a4 <xTaskResumeAll+0x100>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003fe2:	683b      	ldr	r3, [r7, #0]
 8003fe4:	b32b      	cbz	r3, 8004032 <xTaskResumeAll+0x8e>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8003fe6:	68fb      	ldr	r3, [r7, #12]
 8003fe8:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003fea:	f104 0804 	add.w	r8, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003fee:	f104 0018 	add.w	r0, r4, #24
 8003ff2:	f7ff f9b3 	bl	800335c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003ff6:	4640      	mov	r0, r8
 8003ff8:	f7ff f9b0 	bl	800335c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003ffc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003ffe:	682a      	ldr	r2, [r5, #0]
 8004000:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 8004004:	4293      	cmp	r3, r2
 8004006:	4641      	mov	r1, r8
 8004008:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 800400c:	bf88      	it	hi
 800400e:	602b      	strhi	r3, [r5, #0]
 8004010:	f7ff f97c 	bl	800330c <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8004014:	f8d9 3000 	ldr.w	r3, [r9]
 8004018:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800401a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800401c:	429a      	cmp	r2, r3
 800401e:	d3e0      	bcc.n	8003fe2 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
 8004020:	2301      	movs	r3, #1
 8004022:	6033      	str	r3, [r6, #0]
 8004024:	e7dd      	b.n	8003fe2 <xTaskResumeAll+0x3e>
BaseType_t xAlreadyYielded = pdFALSE;
 8004026:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8004028:	f000 fc36 	bl	8004898 <vPortExitCritical>
}
 800402c:	4620      	mov	r0, r4
 800402e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if( pxTCB != NULL )
 8004032:	b13c      	cbz	r4, 8004044 <xTaskResumeAll+0xa0>
	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8004034:	4b16      	ldr	r3, [pc, #88]	; (8004090 <xTaskResumeAll+0xec>)
 8004036:	681b      	ldr	r3, [r3, #0]
 8004038:	681b      	ldr	r3, [r3, #0]
 800403a:	b9db      	cbnz	r3, 8004074 <xTaskResumeAll+0xd0>
		xNextTaskUnblockTime = portMAX_DELAY;
 800403c:	f04f 32ff 	mov.w	r2, #4294967295
 8004040:	4b14      	ldr	r3, [pc, #80]	; (8004094 <xTaskResumeAll+0xf0>)
 8004042:	601a      	str	r2, [r3, #0]
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8004044:	4d14      	ldr	r5, [pc, #80]	; (8004098 <xTaskResumeAll+0xf4>)
 8004046:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8004048:	b13c      	cbz	r4, 800405a <xTaskResumeAll+0xb6>
								xYieldPending = pdTRUE;
 800404a:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 800404c:	f7ff ff0a 	bl	8003e64 <xTaskIncrementTick>
 8004050:	b100      	cbz	r0, 8004054 <xTaskResumeAll+0xb0>
								xYieldPending = pdTRUE;
 8004052:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8004054:	3c01      	subs	r4, #1
 8004056:	d1f9      	bne.n	800404c <xTaskResumeAll+0xa8>
						uxPendedTicks = 0;
 8004058:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 800405a:	6833      	ldr	r3, [r6, #0]
 800405c:	2b00      	cmp	r3, #0
 800405e:	d0e2      	beq.n	8004026 <xTaskResumeAll+0x82>
					taskYIELD_IF_USING_PREEMPTION();
 8004060:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004064:	4b0d      	ldr	r3, [pc, #52]	; (800409c <xTaskResumeAll+0xf8>)
 8004066:	601a      	str	r2, [r3, #0]
 8004068:	f3bf 8f4f 	dsb	sy
 800406c:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8004070:	2401      	movs	r4, #1
 8004072:	e7d9      	b.n	8004028 <xTaskResumeAll+0x84>
 8004074:	f7ff fdaa 	bl	8003bcc <prvResetNextTaskUnblockTime.part.1>
 8004078:	e7e4      	b.n	8004044 <xTaskResumeAll+0xa0>
 800407a:	bf00      	nop
 800407c:	20000d44 	.word	0x20000d44
 8004080:	20000d38 	.word	0x20000d38
 8004084:	20000dc4 	.word	0x20000dc4
 8004088:	20000d80 	.word	0x20000d80
 800408c:	20000d4c 	.word	0x20000d4c
 8004090:	200008d0 	.word	0x200008d0
 8004094:	20000d78 	.word	0x20000d78
 8004098:	20000d40 	.word	0x20000d40
 800409c:	e000ed04 	.word	0xe000ed04
 80040a0:	200008d8 	.word	0x200008d8
 80040a4:	200008cc 	.word	0x200008cc

080040a8 <vTaskDelay>:
	{
 80040a8:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 80040aa:	b198      	cbz	r0, 80040d4 <vTaskDelay+0x2c>
			configASSERT( uxSchedulerSuspended == 0 );
 80040ac:	4b0e      	ldr	r3, [pc, #56]	; (80040e8 <vTaskDelay+0x40>)
 80040ae:	6819      	ldr	r1, [r3, #0]
 80040b0:	b141      	cbz	r1, 80040c4 <vTaskDelay+0x1c>
 80040b2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80040b6:	f383 8811 	msr	BASEPRI, r3
 80040ba:	f3bf 8f6f 	isb	sy
 80040be:	f3bf 8f4f 	dsb	sy
 80040c2:	e7fe      	b.n	80040c2 <vTaskDelay+0x1a>
	++uxSchedulerSuspended;
 80040c4:	681a      	ldr	r2, [r3, #0]
 80040c6:	3201      	adds	r2, #1
 80040c8:	601a      	str	r2, [r3, #0]
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 80040ca:	f7ff fdd5 	bl	8003c78 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 80040ce:	f7ff ff69 	bl	8003fa4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 80040d2:	b938      	cbnz	r0, 80040e4 <vTaskDelay+0x3c>
			portYIELD_WITHIN_API();
 80040d4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80040d8:	4b04      	ldr	r3, [pc, #16]	; (80040ec <vTaskDelay+0x44>)
 80040da:	601a      	str	r2, [r3, #0]
 80040dc:	f3bf 8f4f 	dsb	sy
 80040e0:	f3bf 8f6f 	isb	sy
	}
 80040e4:	bd08      	pop	{r3, pc}
 80040e6:	bf00      	nop
 80040e8:	20000d44 	.word	0x20000d44
 80040ec:	e000ed04 	.word	0xe000ed04

080040f0 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80040f0:	4b1c      	ldr	r3, [pc, #112]	; (8004164 <vTaskSwitchContext+0x74>)
 80040f2:	681b      	ldr	r3, [r3, #0]
 80040f4:	bb13      	cbnz	r3, 800413c <vTaskSwitchContext+0x4c>
		xYieldPending = pdFALSE;
 80040f6:	4a1c      	ldr	r2, [pc, #112]	; (8004168 <vTaskSwitchContext+0x78>)
{
 80040f8:	b430      	push	{r4, r5}
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80040fa:	4c1c      	ldr	r4, [pc, #112]	; (800416c <vTaskSwitchContext+0x7c>)
		xYieldPending = pdFALSE;
 80040fc:	6013      	str	r3, [r2, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80040fe:	6822      	ldr	r2, [r4, #0]
 8004100:	481b      	ldr	r0, [pc, #108]	; (8004170 <vTaskSwitchContext+0x80>)
 8004102:	0093      	lsls	r3, r2, #2
 8004104:	1899      	adds	r1, r3, r2
 8004106:	0089      	lsls	r1, r1, #2
 8004108:	5841      	ldr	r1, [r0, r1]
 800410a:	b939      	cbnz	r1, 800411c <vTaskSwitchContext+0x2c>
 800410c:	b1d2      	cbz	r2, 8004144 <vTaskSwitchContext+0x54>
 800410e:	3a01      	subs	r2, #1
 8004110:	0093      	lsls	r3, r2, #2
 8004112:	1899      	adds	r1, r3, r2
 8004114:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
 8004118:	2900      	cmp	r1, #0
 800411a:	d0f7      	beq.n	800410c <vTaskSwitchContext+0x1c>
 800411c:	4413      	add	r3, r2
 800411e:	009b      	lsls	r3, r3, #2
 8004120:	18c5      	adds	r5, r0, r3
 8004122:	6869      	ldr	r1, [r5, #4]
 8004124:	3308      	adds	r3, #8
 8004126:	6849      	ldr	r1, [r1, #4]
 8004128:	4403      	add	r3, r0
 800412a:	4299      	cmp	r1, r3
 800412c:	6069      	str	r1, [r5, #4]
 800412e:	d012      	beq.n	8004156 <vTaskSwitchContext+0x66>
 8004130:	68c9      	ldr	r1, [r1, #12]
 8004132:	4b10      	ldr	r3, [pc, #64]	; (8004174 <vTaskSwitchContext+0x84>)
 8004134:	6019      	str	r1, [r3, #0]
 8004136:	6022      	str	r2, [r4, #0]
}
 8004138:	bc30      	pop	{r4, r5}
 800413a:	4770      	bx	lr
		xYieldPending = pdTRUE;
 800413c:	2201      	movs	r2, #1
 800413e:	4b0a      	ldr	r3, [pc, #40]	; (8004168 <vTaskSwitchContext+0x78>)
 8004140:	601a      	str	r2, [r3, #0]
 8004142:	4770      	bx	lr
 8004144:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004148:	f383 8811 	msr	BASEPRI, r3
 800414c:	f3bf 8f6f 	isb	sy
 8004150:	f3bf 8f4f 	dsb	sy
 8004154:	e7fe      	b.n	8004154 <vTaskSwitchContext+0x64>
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8004156:	2314      	movs	r3, #20
 8004158:	fb03 0002 	mla	r0, r3, r2, r0
 800415c:	6849      	ldr	r1, [r1, #4]
 800415e:	6041      	str	r1, [r0, #4]
 8004160:	e7e6      	b.n	8004130 <vTaskSwitchContext+0x40>
 8004162:	bf00      	nop
 8004164:	20000d44 	.word	0x20000d44
 8004168:	20000dc4 	.word	0x20000dc4
 800416c:	20000d4c 	.word	0x20000d4c
 8004170:	200008d8 	.word	0x200008d8
 8004174:	200008cc 	.word	0x200008cc

08004178 <vTaskPlaceOnEventList>:
	configASSERT( pxEventList );
 8004178:	b940      	cbnz	r0, 800418c <vTaskPlaceOnEventList+0x14>
 800417a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800417e:	f383 8811 	msr	BASEPRI, r3
 8004182:	f3bf 8f6f 	isb	sy
 8004186:	f3bf 8f4f 	dsb	sy
 800418a:	e7fe      	b.n	800418a <vTaskPlaceOnEventList+0x12>
{
 800418c:	b510      	push	{r4, lr}
 800418e:	460c      	mov	r4, r1
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8004190:	4b05      	ldr	r3, [pc, #20]	; (80041a8 <vTaskPlaceOnEventList+0x30>)
 8004192:	6819      	ldr	r1, [r3, #0]
 8004194:	3118      	adds	r1, #24
 8004196:	f7ff f8c7 	bl	8003328 <vListInsert>
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800419a:	4620      	mov	r0, r4
}
 800419c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80041a0:	2101      	movs	r1, #1
 80041a2:	f7ff bd69 	b.w	8003c78 <prvAddCurrentTaskToDelayedList>
 80041a6:	bf00      	nop
 80041a8:	200008cc 	.word	0x200008cc

080041ac <vTaskPlaceOnEventListRestricted>:
	{
 80041ac:	b538      	push	{r3, r4, r5, lr}
		configASSERT( pxEventList );
 80041ae:	b188      	cbz	r0, 80041d4 <vTaskPlaceOnEventListRestricted+0x28>
 80041b0:	4614      	mov	r4, r2
 80041b2:	460d      	mov	r5, r1
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 80041b4:	4b0c      	ldr	r3, [pc, #48]	; (80041e8 <vTaskPlaceOnEventListRestricted+0x3c>)
 80041b6:	6819      	ldr	r1, [r3, #0]
 80041b8:	3118      	adds	r1, #24
 80041ba:	f7ff f8a7 	bl	800330c <vListInsertEnd>
			xTicksToWait = portMAX_DELAY;
 80041be:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80041c0:	bf08      	it	eq
 80041c2:	4628      	moveq	r0, r5
 80041c4:	4621      	mov	r1, r4
	}
 80041c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 80041ca:	bf18      	it	ne
 80041cc:	f04f 30ff 	movne.w	r0, #4294967295
 80041d0:	f7ff bd52 	b.w	8003c78 <prvAddCurrentTaskToDelayedList>
 80041d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80041d8:	f383 8811 	msr	BASEPRI, r3
 80041dc:	f3bf 8f6f 	isb	sy
 80041e0:	f3bf 8f4f 	dsb	sy
 80041e4:	e7fe      	b.n	80041e4 <vTaskPlaceOnEventListRestricted+0x38>
 80041e6:	bf00      	nop
 80041e8:	200008cc 	.word	0x200008cc

080041ec <xTaskRemoveFromEventList>:
{
 80041ec:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80041ee:	68c3      	ldr	r3, [r0, #12]
 80041f0:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 80041f2:	b34c      	cbz	r4, 8004248 <xTaskRemoveFromEventList+0x5c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80041f4:	f104 0518 	add.w	r5, r4, #24
 80041f8:	4628      	mov	r0, r5
 80041fa:	f7ff f8af 	bl	800335c <uxListRemove>
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80041fe:	4b18      	ldr	r3, [pc, #96]	; (8004260 <xTaskRemoveFromEventList+0x74>)
 8004200:	681b      	ldr	r3, [r3, #0]
 8004202:	b9e3      	cbnz	r3, 800423e <xTaskRemoveFromEventList+0x52>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8004204:	1d25      	adds	r5, r4, #4
 8004206:	4628      	mov	r0, r5
 8004208:	f7ff f8a8 	bl	800335c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800420c:	4a15      	ldr	r2, [pc, #84]	; (8004264 <xTaskRemoveFromEventList+0x78>)
 800420e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004210:	6811      	ldr	r1, [r2, #0]
 8004212:	4815      	ldr	r0, [pc, #84]	; (8004268 <xTaskRemoveFromEventList+0x7c>)
 8004214:	428b      	cmp	r3, r1
 8004216:	bf88      	it	hi
 8004218:	6013      	strhi	r3, [r2, #0]
 800421a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800421e:	4629      	mov	r1, r5
 8004220:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8004224:	f7ff f872 	bl	800330c <vListInsertEnd>
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8004228:	4b10      	ldr	r3, [pc, #64]	; (800426c <xTaskRemoveFromEventList+0x80>)
 800422a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800422c:	681b      	ldr	r3, [r3, #0]
 800422e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004230:	429a      	cmp	r2, r3
 8004232:	d912      	bls.n	800425a <xTaskRemoveFromEventList+0x6e>
		xYieldPending = pdTRUE;
 8004234:	2301      	movs	r3, #1
 8004236:	4a0e      	ldr	r2, [pc, #56]	; (8004270 <xTaskRemoveFromEventList+0x84>)
		xReturn = pdTRUE;
 8004238:	4618      	mov	r0, r3
		xYieldPending = pdTRUE;
 800423a:	6013      	str	r3, [r2, #0]
}
 800423c:	bd38      	pop	{r3, r4, r5, pc}
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800423e:	4629      	mov	r1, r5
 8004240:	480c      	ldr	r0, [pc, #48]	; (8004274 <xTaskRemoveFromEventList+0x88>)
 8004242:	f7ff f863 	bl	800330c <vListInsertEnd>
 8004246:	e7ef      	b.n	8004228 <xTaskRemoveFromEventList+0x3c>
 8004248:	f04f 0350 	mov.w	r3, #80	; 0x50
 800424c:	f383 8811 	msr	BASEPRI, r3
 8004250:	f3bf 8f6f 	isb	sy
 8004254:	f3bf 8f4f 	dsb	sy
 8004258:	e7fe      	b.n	8004258 <xTaskRemoveFromEventList+0x6c>
		xReturn = pdFALSE;
 800425a:	2000      	movs	r0, #0
}
 800425c:	bd38      	pop	{r3, r4, r5, pc}
 800425e:	bf00      	nop
 8004260:	20000d44 	.word	0x20000d44
 8004264:	20000d4c 	.word	0x20000d4c
 8004268:	200008d8 	.word	0x200008d8
 800426c:	200008cc 	.word	0x200008cc
 8004270:	20000dc4 	.word	0x20000dc4
 8004274:	20000d80 	.word	0x20000d80

08004278 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8004278:	4a03      	ldr	r2, [pc, #12]	; (8004288 <vTaskInternalSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
 800427a:	4b04      	ldr	r3, [pc, #16]	; (800428c <vTaskInternalSetTimeOutState+0x14>)
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800427c:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800427e:	681b      	ldr	r3, [r3, #0]
 8004280:	e9c0 2300 	strd	r2, r3, [r0]
}
 8004284:	4770      	bx	lr
 8004286:	bf00      	nop
 8004288:	20000d7c 	.word	0x20000d7c
 800428c:	20000dc0 	.word	0x20000dc0

08004290 <xTaskCheckForTimeOut>:
{
 8004290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	configASSERT( pxTimeOut );
 8004292:	b340      	cbz	r0, 80042e6 <xTaskCheckForTimeOut+0x56>
	configASSERT( pxTicksToWait );
 8004294:	b1f1      	cbz	r1, 80042d4 <xTaskCheckForTimeOut+0x44>
 8004296:	460d      	mov	r5, r1
 8004298:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 800429a:	f000 fadb 	bl	8004854 <vPortEnterCritical>
		const TickType_t xConstTickCount = xTickCount;
 800429e:	f8df c078 	ldr.w	ip, [pc, #120]	; 8004318 <xTaskCheckForTimeOut+0x88>
			if( *pxTicksToWait == portMAX_DELAY )
 80042a2:	682b      	ldr	r3, [r5, #0]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80042a4:	6867      	ldr	r7, [r4, #4]
		const TickType_t xConstTickCount = xTickCount;
 80042a6:	f8dc 6000 	ldr.w	r6, [ip]
			if( *pxTicksToWait == portMAX_DELAY )
 80042aa:	1c59      	adds	r1, r3, #1
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80042ac:	eba6 0207 	sub.w	r2, r6, r7
			if( *pxTicksToWait == portMAX_DELAY )
 80042b0:	d022      	beq.n	80042f8 <xTaskCheckForTimeOut+0x68>
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80042b2:	4818      	ldr	r0, [pc, #96]	; (8004314 <xTaskCheckForTimeOut+0x84>)
 80042b4:	6821      	ldr	r1, [r4, #0]
 80042b6:	f8d0 e000 	ldr.w	lr, [r0]
 80042ba:	4571      	cmp	r1, lr
 80042bc:	d001      	beq.n	80042c2 <xTaskCheckForTimeOut+0x32>
 80042be:	42b7      	cmp	r7, r6
 80042c0:	d925      	bls.n	800430e <xTaskCheckForTimeOut+0x7e>
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 80042c2:	4293      	cmp	r3, r2
 80042c4:	d81a      	bhi.n	80042fc <xTaskCheckForTimeOut+0x6c>
			*pxTicksToWait = 0;
 80042c6:	2300      	movs	r3, #0
			xReturn = pdTRUE;
 80042c8:	2601      	movs	r6, #1
			*pxTicksToWait = 0;
 80042ca:	602b      	str	r3, [r5, #0]
	taskEXIT_CRITICAL();
 80042cc:	f000 fae4 	bl	8004898 <vPortExitCritical>
}
 80042d0:	4630      	mov	r0, r6
 80042d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80042d4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80042d8:	f383 8811 	msr	BASEPRI, r3
 80042dc:	f3bf 8f6f 	isb	sy
 80042e0:	f3bf 8f4f 	dsb	sy
 80042e4:	e7fe      	b.n	80042e4 <xTaskCheckForTimeOut+0x54>
 80042e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80042ea:	f383 8811 	msr	BASEPRI, r3
 80042ee:	f3bf 8f6f 	isb	sy
 80042f2:	f3bf 8f4f 	dsb	sy
 80042f6:	e7fe      	b.n	80042f6 <xTaskCheckForTimeOut+0x66>
				xReturn = pdFALSE;
 80042f8:	2600      	movs	r6, #0
 80042fa:	e7e7      	b.n	80042cc <xTaskCheckForTimeOut+0x3c>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 80042fc:	6800      	ldr	r0, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 80042fe:	f8dc 1000 	ldr.w	r1, [ip]
			*pxTicksToWait -= xElapsedTime;
 8004302:	1a9b      	subs	r3, r3, r2
 8004304:	602b      	str	r3, [r5, #0]
			xReturn = pdFALSE;
 8004306:	2600      	movs	r6, #0
	pxTimeOut->xTimeOnEntering = xTickCount;
 8004308:	e9c4 0100 	strd	r0, r1, [r4]
 800430c:	e7de      	b.n	80042cc <xTaskCheckForTimeOut+0x3c>
			xReturn = pdTRUE;
 800430e:	2601      	movs	r6, #1
 8004310:	e7dc      	b.n	80042cc <xTaskCheckForTimeOut+0x3c>
 8004312:	bf00      	nop
 8004314:	20000d7c 	.word	0x20000d7c
 8004318:	20000dc0 	.word	0x20000dc0

0800431c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
 800431c:	2201      	movs	r2, #1
 800431e:	4b01      	ldr	r3, [pc, #4]	; (8004324 <vTaskMissedYield+0x8>)
 8004320:	601a      	str	r2, [r3, #0]
}
 8004322:	4770      	bx	lr
 8004324:	20000dc4 	.word	0x20000dc4

08004328 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8004328:	4b05      	ldr	r3, [pc, #20]	; (8004340 <xTaskGetSchedulerState+0x18>)
 800432a:	681b      	ldr	r3, [r3, #0]
 800432c:	b133      	cbz	r3, 800433c <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800432e:	4b05      	ldr	r3, [pc, #20]	; (8004344 <xTaskGetSchedulerState+0x1c>)
 8004330:	681b      	ldr	r3, [r3, #0]
 8004332:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8004334:	bf0c      	ite	eq
 8004336:	2002      	moveq	r0, #2
 8004338:	2000      	movne	r0, #0
 800433a:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 800433c:	2001      	movs	r0, #1
	}
 800433e:	4770      	bx	lr
 8004340:	20000d94 	.word	0x20000d94
 8004344:	20000d44 	.word	0x20000d44

08004348 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
 8004348:	b168      	cbz	r0, 8004366 <xTaskPriorityDisinherit+0x1e>
	{
 800434a:	b538      	push	{r3, r4, r5, lr}
			configASSERT( pxTCB == pxCurrentTCB );
 800434c:	4b1c      	ldr	r3, [pc, #112]	; (80043c0 <xTaskPriorityDisinherit+0x78>)
 800434e:	681c      	ldr	r4, [r3, #0]
 8004350:	4284      	cmp	r4, r0
 8004352:	d00a      	beq.n	800436a <xTaskPriorityDisinherit+0x22>
 8004354:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004358:	f383 8811 	msr	BASEPRI, r3
 800435c:	f3bf 8f6f 	isb	sy
 8004360:	f3bf 8f4f 	dsb	sy
 8004364:	e7fe      	b.n	8004364 <xTaskPriorityDisinherit+0x1c>
	BaseType_t xReturn = pdFALSE;
 8004366:	2000      	movs	r0, #0
	}
 8004368:	4770      	bx	lr
			configASSERT( pxTCB->uxMutexesHeld );
 800436a:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800436c:	b943      	cbnz	r3, 8004380 <xTaskPriorityDisinherit+0x38>
 800436e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004372:	f383 8811 	msr	BASEPRI, r3
 8004376:	f3bf 8f6f 	isb	sy
 800437a:	f3bf 8f4f 	dsb	sy
 800437e:	e7fe      	b.n	800437e <xTaskPriorityDisinherit+0x36>
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8004380:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8004382:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
			( pxTCB->uxMutexesHeld )--;
 8004384:	3b01      	subs	r3, #1
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8004386:	4291      	cmp	r1, r2
			( pxTCB->uxMutexesHeld )--;
 8004388:	6523      	str	r3, [r4, #80]	; 0x50
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800438a:	d000      	beq.n	800438e <xTaskPriorityDisinherit+0x46>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800438c:	b10b      	cbz	r3, 8004392 <xTaskPriorityDisinherit+0x4a>
	BaseType_t xReturn = pdFALSE;
 800438e:	2000      	movs	r0, #0
	}
 8004390:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8004392:	1d25      	adds	r5, r4, #4
 8004394:	4628      	mov	r0, r5
 8004396:	f7fe ffe1 	bl	800335c <uxListRemove>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800439a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
					prvAddTaskToReadyList( pxTCB );
 800439c:	4a09      	ldr	r2, [pc, #36]	; (80043c4 <xTaskPriorityDisinherit+0x7c>)
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800439e:	f1c3 0038 	rsb	r0, r3, #56	; 0x38
 80043a2:	61a0      	str	r0, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
 80043a4:	2014      	movs	r0, #20
 80043a6:	6811      	ldr	r1, [r2, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 80043a8:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 80043aa:	428b      	cmp	r3, r1
 80043ac:	bf88      	it	hi
 80043ae:	6013      	strhi	r3, [r2, #0]
 80043b0:	4a05      	ldr	r2, [pc, #20]	; (80043c8 <xTaskPriorityDisinherit+0x80>)
 80043b2:	4629      	mov	r1, r5
 80043b4:	fb00 2003 	mla	r0, r0, r3, r2
 80043b8:	f7fe ffa8 	bl	800330c <vListInsertEnd>
					xReturn = pdTRUE;
 80043bc:	2001      	movs	r0, #1
	}
 80043be:	bd38      	pop	{r3, r4, r5, pc}
 80043c0:	200008cc 	.word	0x200008cc
 80043c4:	20000d4c 	.word	0x20000d4c
 80043c8:	200008d8 	.word	0x200008d8

080043cc <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 80043cc:	b5f0      	push	{r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 80043ce:	4c14      	ldr	r4, [pc, #80]	; (8004420 <prvCheckForValidListAndQueue+0x54>)
{
 80043d0:	b083      	sub	sp, #12
	taskENTER_CRITICAL();
 80043d2:	f000 fa3f 	bl	8004854 <vPortEnterCritical>
		if( xTimerQueue == NULL )
 80043d6:	6825      	ldr	r5, [r4, #0]
 80043d8:	b125      	cbz	r5, 80043e4 <prvCheckForValidListAndQueue+0x18>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
 80043da:	b003      	add	sp, #12
 80043dc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 80043e0:	f000 ba5a 	b.w	8004898 <vPortExitCritical>
			vListInitialise( &xActiveTimerList1 );
 80043e4:	4f0f      	ldr	r7, [pc, #60]	; (8004424 <prvCheckForValidListAndQueue+0x58>)
			vListInitialise( &xActiveTimerList2 );
 80043e6:	4e10      	ldr	r6, [pc, #64]	; (8004428 <prvCheckForValidListAndQueue+0x5c>)
			vListInitialise( &xActiveTimerList1 );
 80043e8:	4638      	mov	r0, r7
 80043ea:	f7fe ff7f 	bl	80032ec <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 80043ee:	4630      	mov	r0, r6
 80043f0:	f7fe ff7c 	bl	80032ec <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 80043f4:	4a0d      	ldr	r2, [pc, #52]	; (800442c <prvCheckForValidListAndQueue+0x60>)
			pxOverflowTimerList = &xActiveTimerList2;
 80043f6:	480e      	ldr	r0, [pc, #56]	; (8004430 <prvCheckForValidListAndQueue+0x64>)
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80043f8:	9500      	str	r5, [sp, #0]
 80043fa:	4b0e      	ldr	r3, [pc, #56]	; (8004434 <prvCheckForValidListAndQueue+0x68>)
			pxCurrentTimerList = &xActiveTimerList1;
 80043fc:	6017      	str	r7, [r2, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 80043fe:	6006      	str	r6, [r0, #0]
				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 8004400:	4a0d      	ldr	r2, [pc, #52]	; (8004438 <prvCheckForValidListAndQueue+0x6c>)
 8004402:	2110      	movs	r1, #16
 8004404:	200a      	movs	r0, #10
 8004406:	f7ff f899 	bl	800353c <xQueueGenericCreateStatic>
 800440a:	6020      	str	r0, [r4, #0]
				if( xTimerQueue != NULL )
 800440c:	2800      	cmp	r0, #0
 800440e:	d0e4      	beq.n	80043da <prvCheckForValidListAndQueue+0xe>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 8004410:	490a      	ldr	r1, [pc, #40]	; (800443c <prvCheckForValidListAndQueue+0x70>)
 8004412:	f7ff fac7 	bl	80039a4 <vQueueAddToRegistry>
}
 8004416:	b003      	add	sp, #12
 8004418:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	taskEXIT_CRITICAL();
 800441c:	f000 ba3c 	b.w	8004898 <vPortExitCritical>
 8004420:	20000eec 	.word	0x20000eec
 8004424:	20000e70 	.word	0x20000e70
 8004428:	20000e84 	.word	0x20000e84
 800442c:	20000dc8 	.word	0x20000dc8
 8004430:	20000dcc 	.word	0x20000dcc
 8004434:	20000e9c 	.word	0x20000e9c
 8004438:	20000dd0 	.word	0x20000dd0
 800443c:	080066f0 	.word	0x080066f0

08004440 <prvInsertTimerInActiveList>:
	if( xNextExpiryTime <= xTimeNow )
 8004440:	4291      	cmp	r1, r2
{
 8004442:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004444:	6100      	str	r0, [r0, #16]
	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8004446:	6041      	str	r1, [r0, #4]
	if( xNextExpiryTime <= xTimeNow )
 8004448:	d805      	bhi.n	8004456 <prvInsertTimerInActiveList+0x16>
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800444a:	6981      	ldr	r1, [r0, #24]
 800444c:	1ad2      	subs	r2, r2, r3
 800444e:	428a      	cmp	r2, r1
 8004450:	d30c      	bcc.n	800446c <prvInsertTimerInActiveList+0x2c>
			xProcessTimerNow = pdTRUE;
 8004452:	2001      	movs	r0, #1
}
 8004454:	bd08      	pop	{r3, pc}
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8004456:	429a      	cmp	r2, r3
 8004458:	d201      	bcs.n	800445e <prvInsertTimerInActiveList+0x1e>
 800445a:	4299      	cmp	r1, r3
 800445c:	d2f9      	bcs.n	8004452 <prvInsertTimerInActiveList+0x12>
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800445e:	4b07      	ldr	r3, [pc, #28]	; (800447c <prvInsertTimerInActiveList+0x3c>)
 8004460:	1d01      	adds	r1, r0, #4
 8004462:	6818      	ldr	r0, [r3, #0]
 8004464:	f7fe ff60 	bl	8003328 <vListInsert>
BaseType_t xProcessTimerNow = pdFALSE;
 8004468:	2000      	movs	r0, #0
}
 800446a:	bd08      	pop	{r3, pc}
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800446c:	4b04      	ldr	r3, [pc, #16]	; (8004480 <prvInsertTimerInActiveList+0x40>)
 800446e:	1d01      	adds	r1, r0, #4
 8004470:	6818      	ldr	r0, [r3, #0]
 8004472:	f7fe ff59 	bl	8003328 <vListInsert>
 8004476:	2000      	movs	r0, #0
}
 8004478:	bd08      	pop	{r3, pc}
 800447a:	bf00      	nop
 800447c:	20000dc8 	.word	0x20000dc8
 8004480:	20000dcc 	.word	0x20000dcc

08004484 <xTimerCreateTimerTask>:
{
 8004484:	b530      	push	{r4, r5, lr}
 8004486:	b089      	sub	sp, #36	; 0x24
	prvCheckForValidListAndQueue();
 8004488:	f7ff ffa0 	bl	80043cc <prvCheckForValidListAndQueue>
	if( xTimerQueue != NULL )
 800448c:	4b12      	ldr	r3, [pc, #72]	; (80044d8 <xTimerCreateTimerTask+0x54>)
 800448e:	681b      	ldr	r3, [r3, #0]
 8004490:	b1c3      	cbz	r3, 80044c4 <xTimerCreateTimerTask+0x40>
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 8004492:	2400      	movs	r4, #0
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 8004494:	2502      	movs	r5, #2
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8004496:	aa07      	add	r2, sp, #28
 8004498:	a906      	add	r1, sp, #24
 800449a:	a805      	add	r0, sp, #20
			StackType_t *pxTimerTaskStackBuffer = NULL;
 800449c:	e9cd 4405 	strd	r4, r4, [sp, #20]
			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 80044a0:	f7fe ff16 	bl	80032d0 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 80044a4:	a805      	add	r0, sp, #20
 80044a6:	c807      	ldmia	r0, {r0, r1, r2}
 80044a8:	4623      	mov	r3, r4
 80044aa:	e9cd 1001 	strd	r1, r0, [sp, #4]
 80044ae:	9500      	str	r5, [sp, #0]
 80044b0:	490a      	ldr	r1, [pc, #40]	; (80044dc <xTimerCreateTimerTask+0x58>)
 80044b2:	480b      	ldr	r0, [pc, #44]	; (80044e0 <xTimerCreateTimerTask+0x5c>)
 80044b4:	f7ff fc1a 	bl	8003cec <xTaskCreateStatic>
 80044b8:	4b0a      	ldr	r3, [pc, #40]	; (80044e4 <xTimerCreateTimerTask+0x60>)
 80044ba:	6018      	str	r0, [r3, #0]
			if( xTimerTaskHandle != NULL )
 80044bc:	b110      	cbz	r0, 80044c4 <xTimerCreateTimerTask+0x40>
}
 80044be:	2001      	movs	r0, #1
 80044c0:	b009      	add	sp, #36	; 0x24
 80044c2:	bd30      	pop	{r4, r5, pc}
 80044c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044c8:	f383 8811 	msr	BASEPRI, r3
 80044cc:	f3bf 8f6f 	isb	sy
 80044d0:	f3bf 8f4f 	dsb	sy
 80044d4:	e7fe      	b.n	80044d4 <xTimerCreateTimerTask+0x50>
 80044d6:	bf00      	nop
 80044d8:	20000eec 	.word	0x20000eec
 80044dc:	080066f8 	.word	0x080066f8
 80044e0:	080045d1 	.word	0x080045d1
 80044e4:	20000ef0 	.word	0x20000ef0

080044e8 <xTimerGenericCommand>:
	configASSERT( xTimer );
 80044e8:	b1c0      	cbz	r0, 800451c <xTimerGenericCommand+0x34>
{
 80044ea:	b570      	push	{r4, r5, r6, lr}
	if( xTimerQueue != NULL )
 80044ec:	4d16      	ldr	r5, [pc, #88]	; (8004548 <xTimerGenericCommand+0x60>)
 80044ee:	4604      	mov	r4, r0
 80044f0:	6828      	ldr	r0, [r5, #0]
{
 80044f2:	b084      	sub	sp, #16
	if( xTimerQueue != NULL )
 80044f4:	b180      	cbz	r0, 8004518 <xTimerGenericCommand+0x30>
 80044f6:	4616      	mov	r6, r2
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 80044f8:	2905      	cmp	r1, #5
 80044fa:	461a      	mov	r2, r3
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 80044fc:	e9cd 1600 	strd	r1, r6, [sp]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
 8004500:	9402      	str	r4, [sp, #8]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 8004502:	dc14      	bgt.n	800452e <xTimerGenericCommand+0x46>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8004504:	f7ff ff10 	bl	8004328 <xTaskGetSchedulerState>
 8004508:	2802      	cmp	r0, #2
 800450a:	d016      	beq.n	800453a <xTimerGenericCommand+0x52>
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800450c:	2300      	movs	r3, #0
 800450e:	6828      	ldr	r0, [r5, #0]
 8004510:	461a      	mov	r2, r3
 8004512:	4669      	mov	r1, sp
 8004514:	f7ff f868 	bl	80035e8 <xQueueGenericSend>
}
 8004518:	b004      	add	sp, #16
 800451a:	bd70      	pop	{r4, r5, r6, pc}
 800451c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004520:	f383 8811 	msr	BASEPRI, r3
 8004524:	f3bf 8f6f 	isb	sy
 8004528:	f3bf 8f4f 	dsb	sy
 800452c:	e7fe      	b.n	800452c <xTimerGenericCommand+0x44>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800452e:	2300      	movs	r3, #0
 8004530:	4669      	mov	r1, sp
 8004532:	f7ff f917 	bl	8003764 <xQueueGenericSendFromISR>
}
 8004536:	b004      	add	sp, #16
 8004538:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800453a:	6828      	ldr	r0, [r5, #0]
 800453c:	2300      	movs	r3, #0
 800453e:	9a08      	ldr	r2, [sp, #32]
 8004540:	4669      	mov	r1, sp
 8004542:	f7ff f851 	bl	80035e8 <xQueueGenericSend>
 8004546:	e7e7      	b.n	8004518 <xTimerGenericCommand+0x30>
 8004548:	20000eec 	.word	0x20000eec

0800454c <prvSwitchTimerLists>:
{
 800454c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004550:	4e1d      	ldr	r6, [pc, #116]	; (80045c8 <prvSwitchTimerLists+0x7c>)
 8004552:	b082      	sub	sp, #8
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8004554:	f04f 0800 	mov.w	r8, #0
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8004558:	e00c      	b.n	8004574 <prvSwitchTimerLists+0x28>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800455a:	68db      	ldr	r3, [r3, #12]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 800455c:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800455e:	681f      	ldr	r7, [r3, #0]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004560:	1d25      	adds	r5, r4, #4
 8004562:	4628      	mov	r0, r5
 8004564:	f7fe fefa 	bl	800335c <uxListRemove>
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004568:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800456a:	4620      	mov	r0, r4
 800456c:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800456e:	69e3      	ldr	r3, [r4, #28]
 8004570:	2b01      	cmp	r3, #1
 8004572:	d00a      	beq.n	800458a <prvSwitchTimerLists+0x3e>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8004574:	6833      	ldr	r3, [r6, #0]
 8004576:	681a      	ldr	r2, [r3, #0]
 8004578:	2a00      	cmp	r2, #0
 800457a:	d1ee      	bne.n	800455a <prvSwitchTimerLists+0xe>
	pxCurrentTimerList = pxOverflowTimerList;
 800457c:	4a13      	ldr	r2, [pc, #76]	; (80045cc <prvSwitchTimerLists+0x80>)
 800457e:	6811      	ldr	r1, [r2, #0]
	pxOverflowTimerList = pxTemp;
 8004580:	6013      	str	r3, [r2, #0]
	pxCurrentTimerList = pxOverflowTimerList;
 8004582:	6031      	str	r1, [r6, #0]
}
 8004584:	b002      	add	sp, #8
 8004586:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800458a:	69a3      	ldr	r3, [r4, #24]
 800458c:	443b      	add	r3, r7
			if( xReloadTime > xNextExpireTime )
 800458e:	429f      	cmp	r7, r3
 8004590:	d206      	bcs.n	80045a0 <prvSwitchTimerLists+0x54>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8004592:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8004594:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8004596:	4629      	mov	r1, r5
 8004598:	6830      	ldr	r0, [r6, #0]
 800459a:	f7fe fec5 	bl	8003328 <vListInsert>
 800459e:	e7e9      	b.n	8004574 <prvSwitchTimerLists+0x28>
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 80045a0:	2300      	movs	r3, #0
 80045a2:	f8cd 8000 	str.w	r8, [sp]
 80045a6:	463a      	mov	r2, r7
 80045a8:	4620      	mov	r0, r4
 80045aa:	4619      	mov	r1, r3
 80045ac:	f7ff ff9c 	bl	80044e8 <xTimerGenericCommand>
				configASSERT( xResult );
 80045b0:	2800      	cmp	r0, #0
 80045b2:	d1df      	bne.n	8004574 <prvSwitchTimerLists+0x28>
 80045b4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045b8:	f383 8811 	msr	BASEPRI, r3
 80045bc:	f3bf 8f6f 	isb	sy
 80045c0:	f3bf 8f4f 	dsb	sy
 80045c4:	e7fe      	b.n	80045c4 <prvSwitchTimerLists+0x78>
 80045c6:	bf00      	nop
 80045c8:	20000dc8 	.word	0x20000dc8
 80045cc:	20000dcc 	.word	0x20000dcc

080045d0 <prvTimerTask>:
{
 80045d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80045d4:	f04f 0801 	mov.w	r8, #1
 80045d8:	4f6f      	ldr	r7, [pc, #444]	; (8004798 <prvTimerTask+0x1c8>)
 80045da:	4e70      	ldr	r6, [pc, #448]	; (800479c <prvTimerTask+0x1cc>)
 80045dc:	4d70      	ldr	r5, [pc, #448]	; (80047a0 <prvTimerTask+0x1d0>)
 80045de:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 80047a8 <prvTimerTask+0x1d8>
 80045e2:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 80045e4:	683b      	ldr	r3, [r7, #0]
 80045e6:	681c      	ldr	r4, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 80045e8:	2c00      	cmp	r4, #0
 80045ea:	d052      	beq.n	8004692 <prvTimerTask+0xc2>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80045ec:	68db      	ldr	r3, [r3, #12]
 80045ee:	681c      	ldr	r4, [r3, #0]
	vTaskSuspendAll();
 80045f0:	f7ff fc2a 	bl	8003e48 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 80045f4:	f7ff fc30 	bl	8003e58 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 80045f8:	6832      	ldr	r2, [r6, #0]
	xTimeNow = xTaskGetTickCount();
 80045fa:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 80045fc:	4282      	cmp	r2, r0
 80045fe:	d859      	bhi.n	80046b4 <prvTimerTask+0xe4>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8004600:	4284      	cmp	r4, r0
	xLastTime = xTimeNow;
 8004602:	6030      	str	r0, [r6, #0]
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8004604:	d96b      	bls.n	80046de <prvTimerTask+0x10e>
 8004606:	2200      	movs	r2, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8004608:	eba4 010a 	sub.w	r1, r4, sl
 800460c:	6828      	ldr	r0, [r5, #0]
 800460e:	f7ff f9dd 	bl	80039cc <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 8004612:	f7ff fcc7 	bl	8003fa4 <xTaskResumeAll>
 8004616:	b938      	cbnz	r0, 8004628 <prvTimerTask+0x58>
					portYIELD_WITHIN_API();
 8004618:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 800461c:	4a61      	ldr	r2, [pc, #388]	; (80047a4 <prvTimerTask+0x1d4>)
 800461e:	6013      	str	r3, [r2, #0]
 8004620:	f3bf 8f4f 	dsb	sy
 8004624:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 8004628:	2200      	movs	r2, #0
 800462a:	a902      	add	r1, sp, #8
 800462c:	6828      	ldr	r0, [r5, #0]
 800462e:	f7ff f8ff 	bl	8003830 <xQueueReceive>
 8004632:	2800      	cmp	r0, #0
 8004634:	d0d6      	beq.n	80045e4 <prvTimerTask+0x14>
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 8004636:	9b02      	ldr	r3, [sp, #8]
 8004638:	9c04      	ldr	r4, [sp, #16]
 800463a:	2b00      	cmp	r3, #0
 800463c:	da07      	bge.n	800464e <prvTimerTask+0x7e>
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 800463e:	9b03      	ldr	r3, [sp, #12]
 8004640:	4620      	mov	r0, r4
 8004642:	9905      	ldr	r1, [sp, #20]
 8004644:	4798      	blx	r3
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 8004646:	9b02      	ldr	r3, [sp, #8]
 8004648:	2b00      	cmp	r3, #0
 800464a:	dbed      	blt.n	8004628 <prvTimerTask+0x58>
 800464c:	9c04      	ldr	r4, [sp, #16]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800464e:	6963      	ldr	r3, [r4, #20]
 8004650:	b113      	cbz	r3, 8004658 <prvTimerTask+0x88>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8004652:	1d20      	adds	r0, r4, #4
 8004654:	f7fe fe82 	bl	800335c <uxListRemove>
	xTimeNow = xTaskGetTickCount();
 8004658:	f7ff fbfe 	bl	8003e58 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 800465c:	6833      	ldr	r3, [r6, #0]
	xTimeNow = xTaskGetTickCount();
 800465e:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 8004660:	4298      	cmp	r0, r3
 8004662:	d32e      	bcc.n	80046c2 <prvTimerTask+0xf2>
 8004664:	9b02      	ldr	r3, [sp, #8]
	xLastTime = xTimeNow;
 8004666:	f8c6 a000 	str.w	sl, [r6]
 800466a:	2b09      	cmp	r3, #9
 800466c:	d8dc      	bhi.n	8004628 <prvTimerTask+0x58>
 800466e:	fa08 f303 	lsl.w	r3, r8, r3
 8004672:	f413 7b04 	ands.w	fp, r3, #528	; 0x210
 8004676:	d127      	bne.n	80046c8 <prvTimerTask+0xf8>
 8004678:	f013 0fc7 	tst.w	r3, #199	; 0xc7
 800467c:	d142      	bne.n	8004704 <prvTimerTask+0x134>
 800467e:	069b      	lsls	r3, r3, #26
 8004680:	d5d2      	bpl.n	8004628 <prvTimerTask+0x58>
						if( pxTimer->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 8004682:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 8004686:	2b00      	cmp	r3, #0
 8004688:	d1ce      	bne.n	8004628 <prvTimerTask+0x58>
							vPortFree( pxTimer );
 800468a:	4620      	mov	r0, r4
 800468c:	f000 faba 	bl	8004c04 <vPortFree>
 8004690:	e7ca      	b.n	8004628 <prvTimerTask+0x58>
	vTaskSuspendAll();
 8004692:	f7ff fbd9 	bl	8003e48 <vTaskSuspendAll>
	xTimeNow = xTaskGetTickCount();
 8004696:	f7ff fbdf 	bl	8003e58 <xTaskGetTickCount>
	if( xTimeNow < xLastTime )
 800469a:	6832      	ldr	r2, [r6, #0]
	xTimeNow = xTaskGetTickCount();
 800469c:	4682      	mov	sl, r0
	if( xTimeNow < xLastTime )
 800469e:	4282      	cmp	r2, r0
 80046a0:	d808      	bhi.n	80046b4 <prvTimerTask+0xe4>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80046a2:	f8d9 2000 	ldr.w	r2, [r9]
	xLastTime = xTimeNow;
 80046a6:	f8c6 a000 	str.w	sl, [r6]
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 80046aa:	6812      	ldr	r2, [r2, #0]
 80046ac:	fab2 f282 	clz	r2, r2
 80046b0:	0952      	lsrs	r2, r2, #5
 80046b2:	e7a9      	b.n	8004608 <prvTimerTask+0x38>
		prvSwitchTimerLists();
 80046b4:	f7ff ff4a 	bl	800454c <prvSwitchTimerLists>
	xLastTime = xTimeNow;
 80046b8:	f8c6 a000 	str.w	sl, [r6]
			( void ) xTaskResumeAll();
 80046bc:	f7ff fc72 	bl	8003fa4 <xTaskResumeAll>
 80046c0:	e7b2      	b.n	8004628 <prvTimerTask+0x58>
		prvSwitchTimerLists();
 80046c2:	f7ff ff43 	bl	800454c <prvSwitchTimerLists>
 80046c6:	e7cd      	b.n	8004664 <prvTimerTask+0x94>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 80046c8:	9903      	ldr	r1, [sp, #12]
 80046ca:	61a1      	str	r1, [r4, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 80046cc:	2900      	cmp	r1, #0
 80046ce:	d03e      	beq.n	800474e <prvTimerTask+0x17e>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 80046d0:	4451      	add	r1, sl
 80046d2:	4620      	mov	r0, r4
 80046d4:	4653      	mov	r3, sl
 80046d6:	4652      	mov	r2, sl
 80046d8:	f7ff feb2 	bl	8004440 <prvInsertTimerInActiveList>
 80046dc:	e7a4      	b.n	8004628 <prvTimerTask+0x58>
				( void ) xTaskResumeAll();
 80046de:	f7ff fc61 	bl	8003fa4 <xTaskResumeAll>
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80046e2:	683a      	ldr	r2, [r7, #0]
 80046e4:	68d2      	ldr	r2, [r2, #12]
 80046e6:	f8d2 b00c 	ldr.w	fp, [r2, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80046ea:	f10b 0004 	add.w	r0, fp, #4
 80046ee:	f7fe fe35 	bl	800335c <uxListRemove>
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 80046f2:	f8db 201c 	ldr.w	r2, [fp, #28]
 80046f6:	2a01      	cmp	r2, #1
 80046f8:	d032      	beq.n	8004760 <prvTimerTask+0x190>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80046fa:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
 80046fe:	4658      	mov	r0, fp
 8004700:	4798      	blx	r3
 8004702:	e791      	b.n	8004628 <prvTimerTask+0x58>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 8004704:	9b03      	ldr	r3, [sp, #12]
 8004706:	69a1      	ldr	r1, [r4, #24]
 8004708:	4652      	mov	r2, sl
 800470a:	4419      	add	r1, r3
 800470c:	4620      	mov	r0, r4
 800470e:	f7ff fe97 	bl	8004440 <prvInsertTimerInActiveList>
 8004712:	2800      	cmp	r0, #0
 8004714:	d088      	beq.n	8004628 <prvTimerTask+0x58>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8004716:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004718:	4620      	mov	r0, r4
 800471a:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
 800471c:	69e3      	ldr	r3, [r4, #28]
 800471e:	2b01      	cmp	r3, #1
 8004720:	d182      	bne.n	8004628 <prvTimerTask+0x58>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 8004722:	69a3      	ldr	r3, [r4, #24]
 8004724:	9a03      	ldr	r2, [sp, #12]
 8004726:	4620      	mov	r0, r4
 8004728:	441a      	add	r2, r3
 800472a:	f8cd b000 	str.w	fp, [sp]
 800472e:	465b      	mov	r3, fp
 8004730:	4659      	mov	r1, fp
 8004732:	f7ff fed9 	bl	80044e8 <xTimerGenericCommand>
							configASSERT( xResult );
 8004736:	2800      	cmp	r0, #0
 8004738:	f47f af76 	bne.w	8004628 <prvTimerTask+0x58>
 800473c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004740:	f383 8811 	msr	BASEPRI, r3
 8004744:	f3bf 8f6f 	isb	sy
 8004748:	f3bf 8f4f 	dsb	sy
 800474c:	e7fe      	b.n	800474c <prvTimerTask+0x17c>
 800474e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004752:	f383 8811 	msr	BASEPRI, r3
 8004756:	f3bf 8f6f 	isb	sy
 800475a:	f3bf 8f4f 	dsb	sy
 800475e:	e7fe      	b.n	800475e <prvTimerTask+0x18e>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 8004760:	f8db 1018 	ldr.w	r1, [fp, #24]
 8004764:	4652      	mov	r2, sl
 8004766:	4421      	add	r1, r4
 8004768:	4623      	mov	r3, r4
 800476a:	4658      	mov	r0, fp
 800476c:	f7ff fe68 	bl	8004440 <prvInsertTimerInActiveList>
 8004770:	2800      	cmp	r0, #0
 8004772:	d0c2      	beq.n	80046fa <prvTimerTask+0x12a>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 8004774:	2300      	movs	r3, #0
 8004776:	4622      	mov	r2, r4
 8004778:	9300      	str	r3, [sp, #0]
 800477a:	4619      	mov	r1, r3
 800477c:	4658      	mov	r0, fp
 800477e:	f7ff feb3 	bl	80044e8 <xTimerGenericCommand>
			configASSERT( xResult );
 8004782:	2800      	cmp	r0, #0
 8004784:	d1b9      	bne.n	80046fa <prvTimerTask+0x12a>
 8004786:	f04f 0350 	mov.w	r3, #80	; 0x50
 800478a:	f383 8811 	msr	BASEPRI, r3
 800478e:	f3bf 8f6f 	isb	sy
 8004792:	f3bf 8f4f 	dsb	sy
 8004796:	e7fe      	b.n	8004796 <prvTimerTask+0x1c6>
 8004798:	20000dc8 	.word	0x20000dc8
 800479c:	20000e98 	.word	0x20000e98
 80047a0:	20000eec 	.word	0x20000eec
 80047a4:	e000ed04 	.word	0xe000ed04
 80047a8:	20000dcc 	.word	0x20000dcc

080047ac <prvTaskExitError>:
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
volatile uint32_t ulDummy = 0UL;
 80047ac:	2200      	movs	r2, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 80047ae:	4b0e      	ldr	r3, [pc, #56]	; (80047e8 <prvTaskExitError+0x3c>)
{
 80047b0:	b082      	sub	sp, #8
	configASSERT( uxCriticalNesting == ~0UL );
 80047b2:	681b      	ldr	r3, [r3, #0]
volatile uint32_t ulDummy = 0UL;
 80047b4:	9201      	str	r2, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
 80047b6:	3301      	adds	r3, #1
 80047b8:	d008      	beq.n	80047cc <prvTaskExitError+0x20>
 80047ba:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047be:	f383 8811 	msr	BASEPRI, r3
 80047c2:	f3bf 8f6f 	isb	sy
 80047c6:	f3bf 8f4f 	dsb	sy
 80047ca:	e7fe      	b.n	80047ca <prvTaskExitError+0x1e>
 80047cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80047d0:	f383 8811 	msr	BASEPRI, r3
 80047d4:	f3bf 8f6f 	isb	sy
 80047d8:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 80047dc:	9b01      	ldr	r3, [sp, #4]
 80047de:	2b00      	cmp	r3, #0
 80047e0:	d0fc      	beq.n	80047dc <prvTaskExitError+0x30>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 80047e2:	b002      	add	sp, #8
 80047e4:	4770      	bx	lr
 80047e6:	bf00      	nop
 80047e8:	2000000c 	.word	0x2000000c

080047ec <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 80047ec:	4806      	ldr	r0, [pc, #24]	; (8004808 <prvPortStartFirstTask+0x1c>)
 80047ee:	6800      	ldr	r0, [r0, #0]
 80047f0:	6800      	ldr	r0, [r0, #0]
 80047f2:	f380 8808 	msr	MSP, r0
 80047f6:	b662      	cpsie	i
 80047f8:	b661      	cpsie	f
 80047fa:	f3bf 8f4f 	dsb	sy
 80047fe:	f3bf 8f6f 	isb	sy
 8004802:	df00      	svc	0
 8004804:	bf00      	nop
 8004806:	0000      	.short	0x0000
 8004808:	e000ed08 	.word	0xe000ed08

0800480c <pxPortInitialiseStack>:
{
 800480c:	b410      	push	{r4}
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800480e:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8004812:	4b06      	ldr	r3, [pc, #24]	; (800482c <pxPortInitialiseStack+0x20>)
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8004814:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8004818:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800481c:	e940 1402 	strd	r1, r4, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8004820:	f840 3c0c 	str.w	r3, [r0, #-12]
}
 8004824:	bc10      	pop	{r4}
 8004826:	3840      	subs	r0, #64	; 0x40
 8004828:	4770      	bx	lr
 800482a:	bf00      	nop
 800482c:	080047ad 	.word	0x080047ad

08004830 <SVC_Handler>:
	__asm volatile (
 8004830:	4b07      	ldr	r3, [pc, #28]	; (8004850 <pxCurrentTCBConst2>)
 8004832:	6819      	ldr	r1, [r3, #0]
 8004834:	6808      	ldr	r0, [r1, #0]
 8004836:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800483a:	f380 8809 	msr	PSP, r0
 800483e:	f3bf 8f6f 	isb	sy
 8004842:	f04f 0000 	mov.w	r0, #0
 8004846:	f380 8811 	msr	BASEPRI, r0
 800484a:	f04e 0e0d 	orr.w	lr, lr, #13
 800484e:	4770      	bx	lr

08004850 <pxCurrentTCBConst2>:
 8004850:	200008cc 	.word	0x200008cc

08004854 <vPortEnterCritical>:
 8004854:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004858:	f383 8811 	msr	BASEPRI, r3
 800485c:	f3bf 8f6f 	isb	sy
 8004860:	f3bf 8f4f 	dsb	sy
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8004864:	4a0a      	ldr	r2, [pc, #40]	; (8004890 <vPortEnterCritical+0x3c>)
 8004866:	6813      	ldr	r3, [r2, #0]
 8004868:	3301      	adds	r3, #1
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800486a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800486c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800486e:	d000      	beq.n	8004872 <vPortEnterCritical+0x1e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
 8004870:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8004872:	4b08      	ldr	r3, [pc, #32]	; (8004894 <vPortEnterCritical+0x40>)
 8004874:	681b      	ldr	r3, [r3, #0]
 8004876:	f013 0fff 	tst.w	r3, #255	; 0xff
 800487a:	d0f9      	beq.n	8004870 <vPortEnterCritical+0x1c>
 800487c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004880:	f383 8811 	msr	BASEPRI, r3
 8004884:	f3bf 8f6f 	isb	sy
 8004888:	f3bf 8f4f 	dsb	sy
 800488c:	e7fe      	b.n	800488c <vPortEnterCritical+0x38>
 800488e:	bf00      	nop
 8004890:	2000000c 	.word	0x2000000c
 8004894:	e000ed04 	.word	0xe000ed04

08004898 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	configASSERT( uxCriticalNesting );
 8004898:	4a08      	ldr	r2, [pc, #32]	; (80048bc <vPortExitCritical+0x24>)
 800489a:	6813      	ldr	r3, [r2, #0]
 800489c:	b943      	cbnz	r3, 80048b0 <vPortExitCritical+0x18>
 800489e:	f04f 0350 	mov.w	r3, #80	; 0x50
 80048a2:	f383 8811 	msr	BASEPRI, r3
 80048a6:	f3bf 8f6f 	isb	sy
 80048aa:	f3bf 8f4f 	dsb	sy
 80048ae:	e7fe      	b.n	80048ae <vPortExitCritical+0x16>
	uxCriticalNesting--;
 80048b0:	3b01      	subs	r3, #1
 80048b2:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 80048b4:	b90b      	cbnz	r3, 80048ba <vPortExitCritical+0x22>
	__asm volatile
 80048b6:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 80048ba:	4770      	bx	lr
 80048bc:	2000000c 	.word	0x2000000c

080048c0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80048c0:	f3ef 8009 	mrs	r0, PSP
 80048c4:	f3bf 8f6f 	isb	sy
 80048c8:	4b0d      	ldr	r3, [pc, #52]	; (8004900 <pxCurrentTCBConst>)
 80048ca:	681a      	ldr	r2, [r3, #0]
 80048cc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80048d0:	6010      	str	r0, [r2, #0]
 80048d2:	e92d 4008 	stmdb	sp!, {r3, lr}
 80048d6:	f04f 0050 	mov.w	r0, #80	; 0x50
 80048da:	f380 8811 	msr	BASEPRI, r0
 80048de:	f7ff fc07 	bl	80040f0 <vTaskSwitchContext>
 80048e2:	f04f 0000 	mov.w	r0, #0
 80048e6:	f380 8811 	msr	BASEPRI, r0
 80048ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80048ee:	6819      	ldr	r1, [r3, #0]
 80048f0:	6808      	ldr	r0, [r1, #0]
 80048f2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80048f6:	f380 8809 	msr	PSP, r0
 80048fa:	f3bf 8f6f 	isb	sy
 80048fe:	4770      	bx	lr

08004900 <pxCurrentTCBConst>:
 8004900:	200008cc 	.word	0x200008cc

08004904 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8004904:	b508      	push	{r3, lr}
	__asm volatile
 8004906:	f04f 0350 	mov.w	r3, #80	; 0x50
 800490a:	f383 8811 	msr	BASEPRI, r3
 800490e:	f3bf 8f6f 	isb	sy
 8004912:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8004916:	f7ff faa5 	bl	8003e64 <xTaskIncrementTick>
 800491a:	b118      	cbz	r0, 8004924 <SysTick_Handler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800491c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004920:	4b02      	ldr	r3, [pc, #8]	; (800492c <SysTick_Handler+0x28>)
 8004922:	601a      	str	r2, [r3, #0]
	__asm volatile
 8004924:	2300      	movs	r3, #0
 8004926:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 800492a:	bd08      	pop	{r3, pc}
 800492c:	e000ed04 	.word	0xe000ed04

08004930 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004930:	2300      	movs	r3, #0
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004932:	2107      	movs	r1, #7
{
 8004934:	b410      	push	{r4}
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8004936:	4a08      	ldr	r2, [pc, #32]	; (8004958 <vPortSetupTimerInterrupt+0x28>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8004938:	4c08      	ldr	r4, [pc, #32]	; (800495c <vPortSetupTimerInterrupt+0x2c>)
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800493a:	4809      	ldr	r0, [pc, #36]	; (8004960 <vPortSetupTimerInterrupt+0x30>)
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800493c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800493e:	6023      	str	r3, [r4, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8004940:	6803      	ldr	r3, [r0, #0]
 8004942:	4c08      	ldr	r4, [pc, #32]	; (8004964 <vPortSetupTimerInterrupt+0x34>)
 8004944:	4808      	ldr	r0, [pc, #32]	; (8004968 <vPortSetupTimerInterrupt+0x38>)
 8004946:	fba4 4303 	umull	r4, r3, r4, r3
 800494a:	099b      	lsrs	r3, r3, #6
 800494c:	3b01      	subs	r3, #1
 800494e:	6003      	str	r3, [r0, #0]
}
 8004950:	bc10      	pop	{r4}
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004952:	6011      	str	r1, [r2, #0]
}
 8004954:	4770      	bx	lr
 8004956:	bf00      	nop
 8004958:	e000e010 	.word	0xe000e010
 800495c:	e000e018 	.word	0xe000e018
 8004960:	20000000 	.word	0x20000000
 8004964:	10624dd3 	.word	0x10624dd3
 8004968:	e000e014 	.word	0xe000e014

0800496c <xPortStartScheduler>:
{
 800496c:	b530      	push	{r4, r5, lr}
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800496e:	25ff      	movs	r5, #255	; 0xff
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004970:	2407      	movs	r4, #7
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004972:	4b27      	ldr	r3, [pc, #156]	; (8004a10 <xPortStartScheduler+0xa4>)
{
 8004974:	b083      	sub	sp, #12
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8004976:	781a      	ldrb	r2, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004978:	4926      	ldr	r1, [pc, #152]	; (8004a14 <xPortStartScheduler+0xa8>)
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800497a:	b2d2      	uxtb	r2, r2
 800497c:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800497e:	701d      	strb	r5, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004980:	781b      	ldrb	r3, [r3, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8004982:	4825      	ldr	r0, [pc, #148]	; (8004a18 <xPortStartScheduler+0xac>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8004984:	b2db      	uxtb	r3, r3
 8004986:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800498a:	f89d 3003 	ldrb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800498e:	f89d 2003 	ldrb.w	r2, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8004992:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8004996:	700b      	strb	r3, [r1, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8004998:	0611      	lsls	r1, r2, #24
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800499a:	6004      	str	r4, [r0, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800499c:	d510      	bpl.n	80049c0 <xPortStartScheduler+0x54>
 800499e:	2306      	movs	r3, #6
 80049a0:	e000      	b.n	80049a4 <xPortStartScheduler+0x38>
 80049a2:	460b      	mov	r3, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80049a4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80049a8:	1e59      	subs	r1, r3, #1
 80049aa:	0052      	lsls	r2, r2, #1
 80049ac:	b2d2      	uxtb	r2, r2
 80049ae:	f88d 2003 	strb.w	r2, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80049b2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80049b6:	0612      	lsls	r2, r2, #24
 80049b8:	d4f3      	bmi.n	80049a2 <xPortStartScheduler+0x36>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 80049ba:	2b03      	cmp	r3, #3
 80049bc:	6003      	str	r3, [r0, #0]
 80049be:	d008      	beq.n	80049d2 <xPortStartScheduler+0x66>
	__asm volatile
 80049c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80049c4:	f383 8811 	msr	BASEPRI, r3
 80049c8:	f3bf 8f6f 	isb	sy
 80049cc:	f3bf 8f4f 	dsb	sy
 80049d0:	e7fe      	b.n	80049d0 <xPortStartScheduler+0x64>
	uxCriticalNesting = 0;
 80049d2:	2400      	movs	r4, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80049d4:	9901      	ldr	r1, [sp, #4]
 80049d6:	4d0e      	ldr	r5, [pc, #56]	; (8004a10 <xPortStartScheduler+0xa4>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 80049d8:	021b      	lsls	r3, r3, #8
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80049da:	4a10      	ldr	r2, [pc, #64]	; (8004a1c <xPortStartScheduler+0xb0>)
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80049dc:	b2c9      	uxtb	r1, r1
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 80049de:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80049e2:	6003      	str	r3, [r0, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 80049e4:	7029      	strb	r1, [r5, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 80049e6:	6813      	ldr	r3, [r2, #0]
 80049e8:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80049ec:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 80049ee:	6813      	ldr	r3, [r2, #0]
 80049f0:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 80049f4:	6013      	str	r3, [r2, #0]
	vPortSetupTimerInterrupt();
 80049f6:	f7ff ff9b 	bl	8004930 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 80049fa:	4b09      	ldr	r3, [pc, #36]	; (8004a20 <xPortStartScheduler+0xb4>)
 80049fc:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
 80049fe:	f7ff fef5 	bl	80047ec <prvPortStartFirstTask>
	vTaskSwitchContext();
 8004a02:	f7ff fb75 	bl	80040f0 <vTaskSwitchContext>
	prvTaskExitError();
 8004a06:	f7ff fed1 	bl	80047ac <prvTaskExitError>
}
 8004a0a:	4620      	mov	r0, r4
 8004a0c:	b003      	add	sp, #12
 8004a0e:	bd30      	pop	{r4, r5, pc}
 8004a10:	e000e400 	.word	0xe000e400
 8004a14:	20000ef4 	.word	0x20000ef4
 8004a18:	20000ef8 	.word	0x20000ef8
 8004a1c:	e000ed20 	.word	0xe000ed20
 8004a20:	2000000c 	.word	0x2000000c

08004a24 <vPortValidateInterruptPriority>:
	{
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 8004a24:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004a28:	2b0f      	cmp	r3, #15
 8004a2a:	d90e      	bls.n	8004a4a <vPortValidateInterruptPriority+0x26>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004a2c:	4910      	ldr	r1, [pc, #64]	; (8004a70 <vPortValidateInterruptPriority+0x4c>)
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004a2e:	4a11      	ldr	r2, [pc, #68]	; (8004a74 <vPortValidateInterruptPriority+0x50>)
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8004a30:	5c5b      	ldrb	r3, [r3, r1]
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004a32:	7812      	ldrb	r2, [r2, #0]
 8004a34:	429a      	cmp	r2, r3
 8004a36:	d908      	bls.n	8004a4a <vPortValidateInterruptPriority+0x26>
 8004a38:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a3c:	f383 8811 	msr	BASEPRI, r3
 8004a40:	f3bf 8f6f 	isb	sy
 8004a44:	f3bf 8f4f 	dsb	sy
 8004a48:	e7fe      	b.n	8004a48 <vPortValidateInterruptPriority+0x24>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8004a4a:	4b0b      	ldr	r3, [pc, #44]	; (8004a78 <vPortValidateInterruptPriority+0x54>)
 8004a4c:	4a0b      	ldr	r2, [pc, #44]	; (8004a7c <vPortValidateInterruptPriority+0x58>)
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	6812      	ldr	r2, [r2, #0]
 8004a52:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8004a56:	4293      	cmp	r3, r2
 8004a58:	d908      	bls.n	8004a6c <vPortValidateInterruptPriority+0x48>
 8004a5a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004a5e:	f383 8811 	msr	BASEPRI, r3
 8004a62:	f3bf 8f6f 	isb	sy
 8004a66:	f3bf 8f4f 	dsb	sy
 8004a6a:	e7fe      	b.n	8004a6a <vPortValidateInterruptPriority+0x46>
	}
 8004a6c:	4770      	bx	lr
 8004a6e:	bf00      	nop
 8004a70:	e000e3f0 	.word	0xe000e3f0
 8004a74:	20000ef4 	.word	0x20000ef4
 8004a78:	e000ed0c 	.word	0xe000ed0c
 8004a7c:	20000ef8 	.word	0x20000ef8

08004a80 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8004a80:	b430      	push	{r4, r5}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8004a82:	4b11      	ldr	r3, [pc, #68]	; (8004ac8 <prvInsertBlockIntoFreeList+0x48>)
 8004a84:	681a      	ldr	r2, [r3, #0]
 8004a86:	4282      	cmp	r2, r0
 8004a88:	d201      	bcs.n	8004a8e <prvInsertBlockIntoFreeList+0xe>
 8004a8a:	4613      	mov	r3, r2
 8004a8c:	e7fa      	b.n	8004a84 <prvInsertBlockIntoFreeList+0x4>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8004a8e:	685c      	ldr	r4, [r3, #4]
 8004a90:	1919      	adds	r1, r3, r4
 8004a92:	4288      	cmp	r0, r1
 8004a94:	d103      	bne.n	8004a9e <prvInsertBlockIntoFreeList+0x1e>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8004a96:	6841      	ldr	r1, [r0, #4]
 8004a98:	4618      	mov	r0, r3
 8004a9a:	4421      	add	r1, r4
 8004a9c:	6059      	str	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8004a9e:	6844      	ldr	r4, [r0, #4]
 8004aa0:	1901      	adds	r1, r0, r4
 8004aa2:	428a      	cmp	r2, r1
 8004aa4:	d109      	bne.n	8004aba <prvInsertBlockIntoFreeList+0x3a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8004aa6:	4909      	ldr	r1, [pc, #36]	; (8004acc <prvInsertBlockIntoFreeList+0x4c>)
 8004aa8:	6809      	ldr	r1, [r1, #0]
 8004aaa:	428a      	cmp	r2, r1
 8004aac:	d005      	beq.n	8004aba <prvInsertBlockIntoFreeList+0x3a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004aae:	e9d2 5100 	ldrd	r5, r1, [r2]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004ab2:	4421      	add	r1, r4
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004ab4:	e9c0 5100 	strd	r5, r1, [r0]
 8004ab8:	e000      	b.n	8004abc <prvInsertBlockIntoFreeList+0x3c>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8004aba:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8004abc:	4298      	cmp	r0, r3
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004abe:	bf18      	it	ne
 8004ac0:	6018      	strne	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8004ac2:	bc30      	pop	{r4, r5}
 8004ac4:	4770      	bx	lr
 8004ac6:	bf00      	nop
 8004ac8:	20001b0c 	.word	0x20001b0c
 8004acc:	20000efc 	.word	0x20000efc

08004ad0 <pvPortMalloc>:
{
 8004ad0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004ad4:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8004ad6:	f7ff f9b7 	bl	8003e48 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8004ada:	4843      	ldr	r0, [pc, #268]	; (8004be8 <pvPortMalloc+0x118>)
 8004adc:	6803      	ldr	r3, [r0, #0]
 8004ade:	2b00      	cmp	r3, #0
 8004ae0:	d05f      	beq.n	8004ba2 <pvPortMalloc+0xd2>
 8004ae2:	4b42      	ldr	r3, [pc, #264]	; (8004bec <pvPortMalloc+0x11c>)
 8004ae4:	681e      	ldr	r6, [r3, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8004ae6:	4234      	tst	r4, r6
 8004ae8:	d154      	bne.n	8004b94 <pvPortMalloc+0xc4>
			if( xWantedSize > 0 )
 8004aea:	2c00      	cmp	r4, #0
 8004aec:	d052      	beq.n	8004b94 <pvPortMalloc+0xc4>
				xWantedSize += xHeapStructSize;
 8004aee:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8004af2:	0759      	lsls	r1, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8004af4:	bf1c      	itt	ne
 8004af6:	f023 0307 	bicne.w	r3, r3, #7
 8004afa:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8004afc:	2b00      	cmp	r3, #0
 8004afe:	d049      	beq.n	8004b94 <pvPortMalloc+0xc4>
 8004b00:	4f3b      	ldr	r7, [pc, #236]	; (8004bf0 <pvPortMalloc+0x120>)
 8004b02:	683d      	ldr	r5, [r7, #0]
 8004b04:	429d      	cmp	r5, r3
 8004b06:	d345      	bcc.n	8004b94 <pvPortMalloc+0xc4>
				pxBlock = xStart.pxNextFreeBlock;
 8004b08:	493a      	ldr	r1, [pc, #232]	; (8004bf4 <pvPortMalloc+0x124>)
 8004b0a:	680c      	ldr	r4, [r1, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004b0c:	e006      	b.n	8004b1c <pvPortMalloc+0x4c>
 8004b0e:	f8d4 c000 	ldr.w	ip, [r4]
 8004b12:	f1bc 0f00 	cmp.w	ip, #0
 8004b16:	d004      	beq.n	8004b22 <pvPortMalloc+0x52>
 8004b18:	4621      	mov	r1, r4
 8004b1a:	4664      	mov	r4, ip
 8004b1c:	6862      	ldr	r2, [r4, #4]
 8004b1e:	429a      	cmp	r2, r3
 8004b20:	d3f5      	bcc.n	8004b0e <pvPortMalloc+0x3e>
				if( pxBlock != pxEnd )
 8004b22:	6800      	ldr	r0, [r0, #0]
 8004b24:	42a0      	cmp	r0, r4
 8004b26:	d035      	beq.n	8004b94 <pvPortMalloc+0xc4>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004b28:	6820      	ldr	r0, [r4, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004b2a:	eba2 0c03 	sub.w	ip, r2, r3
 8004b2e:	f1bc 0f10 	cmp.w	ip, #16
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004b32:	f8d1 8000 	ldr.w	r8, [r1]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004b36:	6008      	str	r0, [r1, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8004b38:	d911      	bls.n	8004b5e <pvPortMalloc+0x8e>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8004b3a:	18e0      	adds	r0, r4, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8004b3c:	0742      	lsls	r2, r0, #29
 8004b3e:	d008      	beq.n	8004b52 <pvPortMalloc+0x82>
 8004b40:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b44:	f383 8811 	msr	BASEPRI, r3
 8004b48:	f3bf 8f6f 	isb	sy
 8004b4c:	f3bf 8f4f 	dsb	sy
 8004b50:	e7fe      	b.n	8004b50 <pvPortMalloc+0x80>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004b52:	f8c0 c004 	str.w	ip, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004b56:	6063      	str	r3, [r4, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8004b58:	f7ff ff92 	bl	8004a80 <prvInsertBlockIntoFreeList>
 8004b5c:	6862      	ldr	r2, [r4, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8004b5e:	2300      	movs	r3, #0
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004b60:	4925      	ldr	r1, [pc, #148]	; (8004bf8 <pvPortMalloc+0x128>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004b62:	1aad      	subs	r5, r5, r2
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004b64:	6808      	ldr	r0, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004b66:	4332      	orrs	r2, r6
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8004b68:	4285      	cmp	r5, r0
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8004b6a:	6062      	str	r2, [r4, #4]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8004b6c:	f108 0808 	add.w	r8, r8, #8
					pxBlock->pxNextFreeBlock = NULL;
 8004b70:	6023      	str	r3, [r4, #0]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8004b72:	bf38      	it	cc
 8004b74:	600d      	strcc	r5, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8004b76:	603d      	str	r5, [r7, #0]
	( void ) xTaskResumeAll();
 8004b78:	f7ff fa14 	bl	8003fa4 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8004b7c:	f018 0f07 	tst.w	r8, #7
 8004b80:	d00c      	beq.n	8004b9c <pvPortMalloc+0xcc>
 8004b82:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004b86:	f383 8811 	msr	BASEPRI, r3
 8004b8a:	f3bf 8f6f 	isb	sy
 8004b8e:	f3bf 8f4f 	dsb	sy
 8004b92:	e7fe      	b.n	8004b92 <pvPortMalloc+0xc2>
	( void ) xTaskResumeAll();
 8004b94:	f7ff fa06 	bl	8003fa4 <xTaskResumeAll>
 8004b98:	f04f 0800 	mov.w	r8, #0
}
 8004b9c:	4640      	mov	r0, r8
 8004b9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uxAddress = ( size_t ) ucHeap;
 8004ba2:	4b16      	ldr	r3, [pc, #88]	; (8004bfc <pvPortMalloc+0x12c>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004ba4:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8004ba8:	075d      	lsls	r5, r3, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8004baa:	bf1c      	itt	ne
 8004bac:	3307      	addne	r3, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8004bae:	f023 0307 	bicne.w	r3, r3, #7
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8004bb2:	4619      	mov	r1, r3
	xStart.xBlockSize = ( size_t ) 0;
 8004bb4:	2500      	movs	r5, #0
	uxAddress -= xHeapStructSize;
 8004bb6:	4a12      	ldr	r2, [pc, #72]	; (8004c00 <pvPortMalloc+0x130>)
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004bb8:	f8df c03c 	ldr.w	ip, [pc, #60]	; 8004bf8 <pvPortMalloc+0x128>
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8004bbc:	f022 0207 	bic.w	r2, r2, #7
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8004bc0:	1ad3      	subs	r3, r2, r3
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004bc2:	f8cc 3000 	str.w	r3, [ip]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004bc6:	f8df c028 	ldr.w	ip, [pc, #40]	; 8004bf0 <pvPortMalloc+0x120>
	pxEnd->pxNextFreeBlock = NULL;
 8004bca:	6015      	str	r5, [r2, #0]
	pxEnd->xBlockSize = 0;
 8004bcc:	6055      	str	r5, [r2, #4]
	pxEnd = ( void * ) uxAddress;
 8004bce:	6002      	str	r2, [r0, #0]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8004bd0:	e9c1 2300 	strd	r2, r3, [r1]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8004bd4:	f8cc 3000 	str.w	r3, [ip]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004bd8:	4a04      	ldr	r2, [pc, #16]	; (8004bec <pvPortMalloc+0x11c>)
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004bda:	4b06      	ldr	r3, [pc, #24]	; (8004bf4 <pvPortMalloc+0x124>)
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004bdc:	463e      	mov	r6, r7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8004bde:	e9c3 1500 	strd	r1, r5, [r3]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8004be2:	6017      	str	r7, [r2, #0]
 8004be4:	e77f      	b.n	8004ae6 <pvPortMalloc+0x16>
 8004be6:	bf00      	nop
 8004be8:	20000efc 	.word	0x20000efc
 8004bec:	20001b00 	.word	0x20001b00
 8004bf0:	20001b04 	.word	0x20001b04
 8004bf4:	20001b0c 	.word	0x20001b0c
 8004bf8:	20001b08 	.word	0x20001b08
 8004bfc:	20000f00 	.word	0x20000f00
 8004c00:	20001af8 	.word	0x20001af8

08004c04 <vPortFree>:
	if( pv != NULL )
 8004c04:	b1d0      	cbz	r0, 8004c3c <vPortFree+0x38>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8004c06:	4a19      	ldr	r2, [pc, #100]	; (8004c6c <vPortFree+0x68>)
 8004c08:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8004c0c:	6812      	ldr	r2, [r2, #0]
 8004c0e:	4213      	tst	r3, r2
 8004c10:	d108      	bne.n	8004c24 <vPortFree+0x20>
 8004c12:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c16:	f383 8811 	msr	BASEPRI, r3
 8004c1a:	f3bf 8f6f 	isb	sy
 8004c1e:	f3bf 8f4f 	dsb	sy
 8004c22:	e7fe      	b.n	8004c22 <vPortFree+0x1e>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004c24:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8004c28:	b149      	cbz	r1, 8004c3e <vPortFree+0x3a>
 8004c2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c2e:	f383 8811 	msr	BASEPRI, r3
 8004c32:	f3bf 8f6f 	isb	sy
 8004c36:	f3bf 8f4f 	dsb	sy
 8004c3a:	e7fe      	b.n	8004c3a <vPortFree+0x36>
 8004c3c:	4770      	bx	lr
{
 8004c3e:	b510      	push	{r4, lr}
 8004c40:	4604      	mov	r4, r0
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004c42:	ea23 0302 	bic.w	r3, r3, r2
 8004c46:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8004c4a:	f7ff f8fd 	bl	8003e48 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004c4e:	4a08      	ldr	r2, [pc, #32]	; (8004c70 <vPortFree+0x6c>)
 8004c50:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8004c54:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004c56:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004c5a:	440b      	add	r3, r1
 8004c5c:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004c5e:	f7ff ff0f 	bl	8004a80 <prvInsertBlockIntoFreeList>
}
 8004c62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8004c66:	f7ff b99d 	b.w	8003fa4 <xTaskResumeAll>
 8004c6a:	bf00      	nop
 8004c6c:	20001b00 	.word	0x20001b00
 8004c70:	20001b04 	.word	0x20001b04

08004c74 <atoi>:
 8004c74:	220a      	movs	r2, #10
 8004c76:	2100      	movs	r1, #0
 8004c78:	f000 b932 	b.w	8004ee0 <strtol>

08004c7c <gcvt>:
 8004c7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c7e:	461c      	mov	r4, r3
 8004c80:	b085      	sub	sp, #20
 8004c82:	2300      	movs	r3, #0
 8004c84:	4615      	mov	r5, r2
 8004c86:	2200      	movs	r2, #0
 8004c88:	4606      	mov	r6, r0
 8004c8a:	460f      	mov	r7, r1
 8004c8c:	f7fb fe96 	bl	80009bc <__aeabi_dcmplt>
 8004c90:	4623      	mov	r3, r4
 8004c92:	b118      	cbz	r0, 8004c9c <gcvt+0x20>
 8004c94:	222d      	movs	r2, #45	; 0x2d
 8004c96:	3d01      	subs	r5, #1
 8004c98:	f803 2b01 	strb.w	r2, [r3], #1
 8004c9c:	2267      	movs	r2, #103	; 0x67
 8004c9e:	2100      	movs	r1, #0
 8004ca0:	e9cd 5300 	strd	r5, r3, [sp]
 8004ca4:	e9cd 2102 	strd	r2, r1, [sp, #8]
 8004ca8:	4905      	ldr	r1, [pc, #20]	; (8004cc0 <gcvt+0x44>)
 8004caa:	4632      	mov	r2, r6
 8004cac:	463b      	mov	r3, r7
 8004cae:	6808      	ldr	r0, [r1, #0]
 8004cb0:	f000 f9a2 	bl	8004ff8 <_gcvt>
 8004cb4:	2800      	cmp	r0, #0
 8004cb6:	bf14      	ite	ne
 8004cb8:	4620      	movne	r0, r4
 8004cba:	2000      	moveq	r0, #0
 8004cbc:	b005      	add	sp, #20
 8004cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004cc0:	20000010 	.word	0x20000010

08004cc4 <__errno>:
 8004cc4:	4b01      	ldr	r3, [pc, #4]	; (8004ccc <__errno+0x8>)
 8004cc6:	6818      	ldr	r0, [r3, #0]
 8004cc8:	4770      	bx	lr
 8004cca:	bf00      	nop
 8004ccc:	20000010 	.word	0x20000010

08004cd0 <__libc_init_array>:
 8004cd0:	b570      	push	{r4, r5, r6, lr}
 8004cd2:	2500      	movs	r5, #0
 8004cd4:	4e0c      	ldr	r6, [pc, #48]	; (8004d08 <__libc_init_array+0x38>)
 8004cd6:	4c0d      	ldr	r4, [pc, #52]	; (8004d0c <__libc_init_array+0x3c>)
 8004cd8:	1ba4      	subs	r4, r4, r6
 8004cda:	10a4      	asrs	r4, r4, #2
 8004cdc:	42a5      	cmp	r5, r4
 8004cde:	d109      	bne.n	8004cf4 <__libc_init_array+0x24>
 8004ce0:	f001 fc40 	bl	8006564 <_init>
 8004ce4:	2500      	movs	r5, #0
 8004ce6:	4e0a      	ldr	r6, [pc, #40]	; (8004d10 <__libc_init_array+0x40>)
 8004ce8:	4c0a      	ldr	r4, [pc, #40]	; (8004d14 <__libc_init_array+0x44>)
 8004cea:	1ba4      	subs	r4, r4, r6
 8004cec:	10a4      	asrs	r4, r4, #2
 8004cee:	42a5      	cmp	r5, r4
 8004cf0:	d105      	bne.n	8004cfe <__libc_init_array+0x2e>
 8004cf2:	bd70      	pop	{r4, r5, r6, pc}
 8004cf4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8004cf8:	4798      	blx	r3
 8004cfa:	3501      	adds	r5, #1
 8004cfc:	e7ee      	b.n	8004cdc <__libc_init_array+0xc>
 8004cfe:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8004d02:	4798      	blx	r3
 8004d04:	3501      	adds	r5, #1
 8004d06:	e7f2      	b.n	8004cee <__libc_init_array+0x1e>
 8004d08:	0800691c 	.word	0x0800691c
 8004d0c:	0800691c 	.word	0x0800691c
 8004d10:	0800691c 	.word	0x0800691c
 8004d14:	08006920 	.word	0x08006920

08004d18 <memcpy>:
 8004d18:	b510      	push	{r4, lr}
 8004d1a:	1e43      	subs	r3, r0, #1
 8004d1c:	440a      	add	r2, r1
 8004d1e:	4291      	cmp	r1, r2
 8004d20:	d100      	bne.n	8004d24 <memcpy+0xc>
 8004d22:	bd10      	pop	{r4, pc}
 8004d24:	f811 4b01 	ldrb.w	r4, [r1], #1
 8004d28:	f803 4f01 	strb.w	r4, [r3, #1]!
 8004d2c:	e7f7      	b.n	8004d1e <memcpy+0x6>

08004d2e <memset>:
 8004d2e:	4603      	mov	r3, r0
 8004d30:	4402      	add	r2, r0
 8004d32:	4293      	cmp	r3, r2
 8004d34:	d100      	bne.n	8004d38 <memset+0xa>
 8004d36:	4770      	bx	lr
 8004d38:	f803 1b01 	strb.w	r1, [r3], #1
 8004d3c:	e7f9      	b.n	8004d32 <memset+0x4>
	...

08004d40 <strtok>:
 8004d40:	4b13      	ldr	r3, [pc, #76]	; (8004d90 <strtok+0x50>)
 8004d42:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004d46:	681d      	ldr	r5, [r3, #0]
 8004d48:	4606      	mov	r6, r0
 8004d4a:	6dac      	ldr	r4, [r5, #88]	; 0x58
 8004d4c:	460f      	mov	r7, r1
 8004d4e:	b9b4      	cbnz	r4, 8004d7e <strtok+0x3e>
 8004d50:	2050      	movs	r0, #80	; 0x50
 8004d52:	f000 fa23 	bl	800519c <malloc>
 8004d56:	65a8      	str	r0, [r5, #88]	; 0x58
 8004d58:	e9c0 4400 	strd	r4, r4, [r0]
 8004d5c:	e9c0 4402 	strd	r4, r4, [r0, #8]
 8004d60:	e9c0 4404 	strd	r4, r4, [r0, #16]
 8004d64:	e9c0 440a 	strd	r4, r4, [r0, #40]	; 0x28
 8004d68:	e9c0 440c 	strd	r4, r4, [r0, #48]	; 0x30
 8004d6c:	e9c0 440e 	strd	r4, r4, [r0, #56]	; 0x38
 8004d70:	e9c0 4410 	strd	r4, r4, [r0, #64]	; 0x40
 8004d74:	e9c0 4412 	strd	r4, r4, [r0, #72]	; 0x48
 8004d78:	6184      	str	r4, [r0, #24]
 8004d7a:	7704      	strb	r4, [r0, #28]
 8004d7c:	6244      	str	r4, [r0, #36]	; 0x24
 8004d7e:	6daa      	ldr	r2, [r5, #88]	; 0x58
 8004d80:	4639      	mov	r1, r7
 8004d82:	4630      	mov	r0, r6
 8004d84:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8004d88:	2301      	movs	r3, #1
 8004d8a:	f000 b803 	b.w	8004d94 <__strtok_r>
 8004d8e:	bf00      	nop
 8004d90:	20000010 	.word	0x20000010

08004d94 <__strtok_r>:
 8004d94:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004d96:	b918      	cbnz	r0, 8004da0 <__strtok_r+0xc>
 8004d98:	6810      	ldr	r0, [r2, #0]
 8004d9a:	b908      	cbnz	r0, 8004da0 <__strtok_r+0xc>
 8004d9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004d9e:	4620      	mov	r0, r4
 8004da0:	4604      	mov	r4, r0
 8004da2:	460f      	mov	r7, r1
 8004da4:	f814 5b01 	ldrb.w	r5, [r4], #1
 8004da8:	f817 6b01 	ldrb.w	r6, [r7], #1
 8004dac:	b91e      	cbnz	r6, 8004db6 <__strtok_r+0x22>
 8004dae:	b96d      	cbnz	r5, 8004dcc <__strtok_r+0x38>
 8004db0:	6015      	str	r5, [r2, #0]
 8004db2:	4628      	mov	r0, r5
 8004db4:	e7f2      	b.n	8004d9c <__strtok_r+0x8>
 8004db6:	42b5      	cmp	r5, r6
 8004db8:	d1f6      	bne.n	8004da8 <__strtok_r+0x14>
 8004dba:	2b00      	cmp	r3, #0
 8004dbc:	d1ef      	bne.n	8004d9e <__strtok_r+0xa>
 8004dbe:	6014      	str	r4, [r2, #0]
 8004dc0:	7003      	strb	r3, [r0, #0]
 8004dc2:	e7eb      	b.n	8004d9c <__strtok_r+0x8>
 8004dc4:	462b      	mov	r3, r5
 8004dc6:	e00d      	b.n	8004de4 <__strtok_r+0x50>
 8004dc8:	b926      	cbnz	r6, 8004dd4 <__strtok_r+0x40>
 8004dca:	461c      	mov	r4, r3
 8004dcc:	4623      	mov	r3, r4
 8004dce:	460f      	mov	r7, r1
 8004dd0:	f813 5b01 	ldrb.w	r5, [r3], #1
 8004dd4:	f817 6b01 	ldrb.w	r6, [r7], #1
 8004dd8:	42b5      	cmp	r5, r6
 8004dda:	d1f5      	bne.n	8004dc8 <__strtok_r+0x34>
 8004ddc:	2d00      	cmp	r5, #0
 8004dde:	d0f1      	beq.n	8004dc4 <__strtok_r+0x30>
 8004de0:	2100      	movs	r1, #0
 8004de2:	7021      	strb	r1, [r4, #0]
 8004de4:	6013      	str	r3, [r2, #0]
 8004de6:	e7d9      	b.n	8004d9c <__strtok_r+0x8>

08004de8 <_strtol_l.isra.0>:
 8004de8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004dec:	4680      	mov	r8, r0
 8004dee:	4689      	mov	r9, r1
 8004df0:	4692      	mov	sl, r2
 8004df2:	461e      	mov	r6, r3
 8004df4:	460f      	mov	r7, r1
 8004df6:	463d      	mov	r5, r7
 8004df8:	9808      	ldr	r0, [sp, #32]
 8004dfa:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004dfe:	f000 f9c9 	bl	8005194 <__locale_ctype_ptr_l>
 8004e02:	4420      	add	r0, r4
 8004e04:	7843      	ldrb	r3, [r0, #1]
 8004e06:	f013 0308 	ands.w	r3, r3, #8
 8004e0a:	d132      	bne.n	8004e72 <_strtol_l.isra.0+0x8a>
 8004e0c:	2c2d      	cmp	r4, #45	; 0x2d
 8004e0e:	d132      	bne.n	8004e76 <_strtol_l.isra.0+0x8e>
 8004e10:	2201      	movs	r2, #1
 8004e12:	787c      	ldrb	r4, [r7, #1]
 8004e14:	1cbd      	adds	r5, r7, #2
 8004e16:	2e00      	cmp	r6, #0
 8004e18:	d05d      	beq.n	8004ed6 <_strtol_l.isra.0+0xee>
 8004e1a:	2e10      	cmp	r6, #16
 8004e1c:	d109      	bne.n	8004e32 <_strtol_l.isra.0+0x4a>
 8004e1e:	2c30      	cmp	r4, #48	; 0x30
 8004e20:	d107      	bne.n	8004e32 <_strtol_l.isra.0+0x4a>
 8004e22:	782b      	ldrb	r3, [r5, #0]
 8004e24:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8004e28:	2b58      	cmp	r3, #88	; 0x58
 8004e2a:	d14f      	bne.n	8004ecc <_strtol_l.isra.0+0xe4>
 8004e2c:	2610      	movs	r6, #16
 8004e2e:	786c      	ldrb	r4, [r5, #1]
 8004e30:	3502      	adds	r5, #2
 8004e32:	2a00      	cmp	r2, #0
 8004e34:	bf14      	ite	ne
 8004e36:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 8004e3a:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 8004e3e:	2700      	movs	r7, #0
 8004e40:	fbb1 fcf6 	udiv	ip, r1, r6
 8004e44:	4638      	mov	r0, r7
 8004e46:	fb06 1e1c 	mls	lr, r6, ip, r1
 8004e4a:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 8004e4e:	2b09      	cmp	r3, #9
 8004e50:	d817      	bhi.n	8004e82 <_strtol_l.isra.0+0x9a>
 8004e52:	461c      	mov	r4, r3
 8004e54:	42a6      	cmp	r6, r4
 8004e56:	dd23      	ble.n	8004ea0 <_strtol_l.isra.0+0xb8>
 8004e58:	1c7b      	adds	r3, r7, #1
 8004e5a:	d007      	beq.n	8004e6c <_strtol_l.isra.0+0x84>
 8004e5c:	4584      	cmp	ip, r0
 8004e5e:	d31c      	bcc.n	8004e9a <_strtol_l.isra.0+0xb2>
 8004e60:	d101      	bne.n	8004e66 <_strtol_l.isra.0+0x7e>
 8004e62:	45a6      	cmp	lr, r4
 8004e64:	db19      	blt.n	8004e9a <_strtol_l.isra.0+0xb2>
 8004e66:	2701      	movs	r7, #1
 8004e68:	fb00 4006 	mla	r0, r0, r6, r4
 8004e6c:	f815 4b01 	ldrb.w	r4, [r5], #1
 8004e70:	e7eb      	b.n	8004e4a <_strtol_l.isra.0+0x62>
 8004e72:	462f      	mov	r7, r5
 8004e74:	e7bf      	b.n	8004df6 <_strtol_l.isra.0+0xe>
 8004e76:	2c2b      	cmp	r4, #43	; 0x2b
 8004e78:	bf04      	itt	eq
 8004e7a:	1cbd      	addeq	r5, r7, #2
 8004e7c:	787c      	ldrbeq	r4, [r7, #1]
 8004e7e:	461a      	mov	r2, r3
 8004e80:	e7c9      	b.n	8004e16 <_strtol_l.isra.0+0x2e>
 8004e82:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 8004e86:	2b19      	cmp	r3, #25
 8004e88:	d801      	bhi.n	8004e8e <_strtol_l.isra.0+0xa6>
 8004e8a:	3c37      	subs	r4, #55	; 0x37
 8004e8c:	e7e2      	b.n	8004e54 <_strtol_l.isra.0+0x6c>
 8004e8e:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 8004e92:	2b19      	cmp	r3, #25
 8004e94:	d804      	bhi.n	8004ea0 <_strtol_l.isra.0+0xb8>
 8004e96:	3c57      	subs	r4, #87	; 0x57
 8004e98:	e7dc      	b.n	8004e54 <_strtol_l.isra.0+0x6c>
 8004e9a:	f04f 37ff 	mov.w	r7, #4294967295
 8004e9e:	e7e5      	b.n	8004e6c <_strtol_l.isra.0+0x84>
 8004ea0:	1c7b      	adds	r3, r7, #1
 8004ea2:	d108      	bne.n	8004eb6 <_strtol_l.isra.0+0xce>
 8004ea4:	2322      	movs	r3, #34	; 0x22
 8004ea6:	4608      	mov	r0, r1
 8004ea8:	f8c8 3000 	str.w	r3, [r8]
 8004eac:	f1ba 0f00 	cmp.w	sl, #0
 8004eb0:	d107      	bne.n	8004ec2 <_strtol_l.isra.0+0xda>
 8004eb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8004eb6:	b102      	cbz	r2, 8004eba <_strtol_l.isra.0+0xd2>
 8004eb8:	4240      	negs	r0, r0
 8004eba:	f1ba 0f00 	cmp.w	sl, #0
 8004ebe:	d0f8      	beq.n	8004eb2 <_strtol_l.isra.0+0xca>
 8004ec0:	b10f      	cbz	r7, 8004ec6 <_strtol_l.isra.0+0xde>
 8004ec2:	f105 39ff 	add.w	r9, r5, #4294967295
 8004ec6:	f8ca 9000 	str.w	r9, [sl]
 8004eca:	e7f2      	b.n	8004eb2 <_strtol_l.isra.0+0xca>
 8004ecc:	2430      	movs	r4, #48	; 0x30
 8004ece:	2e00      	cmp	r6, #0
 8004ed0:	d1af      	bne.n	8004e32 <_strtol_l.isra.0+0x4a>
 8004ed2:	2608      	movs	r6, #8
 8004ed4:	e7ad      	b.n	8004e32 <_strtol_l.isra.0+0x4a>
 8004ed6:	2c30      	cmp	r4, #48	; 0x30
 8004ed8:	d0a3      	beq.n	8004e22 <_strtol_l.isra.0+0x3a>
 8004eda:	260a      	movs	r6, #10
 8004edc:	e7a9      	b.n	8004e32 <_strtol_l.isra.0+0x4a>
	...

08004ee0 <strtol>:
 8004ee0:	4b08      	ldr	r3, [pc, #32]	; (8004f04 <strtol+0x24>)
 8004ee2:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8004ee4:	681c      	ldr	r4, [r3, #0]
 8004ee6:	4d08      	ldr	r5, [pc, #32]	; (8004f08 <strtol+0x28>)
 8004ee8:	6a23      	ldr	r3, [r4, #32]
 8004eea:	2b00      	cmp	r3, #0
 8004eec:	bf08      	it	eq
 8004eee:	462b      	moveq	r3, r5
 8004ef0:	9300      	str	r3, [sp, #0]
 8004ef2:	4613      	mov	r3, r2
 8004ef4:	460a      	mov	r2, r1
 8004ef6:	4601      	mov	r1, r0
 8004ef8:	4620      	mov	r0, r4
 8004efa:	f7ff ff75 	bl	8004de8 <_strtol_l.isra.0>
 8004efe:	b003      	add	sp, #12
 8004f00:	bd30      	pop	{r4, r5, pc}
 8004f02:	bf00      	nop
 8004f04:	20000010 	.word	0x20000010
 8004f08:	20000074 	.word	0x20000074

08004f0c <print_e>:
 8004f0c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f0e:	b08b      	sub	sp, #44	; 0x2c
 8004f10:	460f      	mov	r7, r1
 8004f12:	a908      	add	r1, sp, #32
 8004f14:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8004f16:	9104      	str	r1, [sp, #16]
 8004f18:	a907      	add	r1, sp, #28
 8004f1a:	9103      	str	r1, [sp, #12]
 8004f1c:	a909      	add	r1, sp, #36	; 0x24
 8004f1e:	9102      	str	r1, [sp, #8]
 8004f20:	1c61      	adds	r1, r4, #1
 8004f22:	9101      	str	r1, [sp, #4]
 8004f24:	2102      	movs	r1, #2
 8004f26:	9100      	str	r1, [sp, #0]
 8004f28:	f89d 6044 	ldrb.w	r6, [sp, #68]	; 0x44
 8004f2c:	9d12      	ldr	r5, [sp, #72]	; 0x48
 8004f2e:	f000 fd63 	bl	80059f8 <_dtoa_r>
 8004f32:	f242 730f 	movw	r3, #9999	; 0x270f
 8004f36:	4601      	mov	r1, r0
 8004f38:	9809      	ldr	r0, [sp, #36]	; 0x24
 8004f3a:	4298      	cmp	r0, r3
 8004f3c:	d104      	bne.n	8004f48 <print_e+0x3c>
 8004f3e:	4638      	mov	r0, r7
 8004f40:	f000 fcb6 	bl	80058b0 <strcpy>
 8004f44:	b00b      	add	sp, #44	; 0x2c
 8004f46:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f48:	780b      	ldrb	r3, [r1, #0]
 8004f4a:	703b      	strb	r3, [r7, #0]
 8004f4c:	2d00      	cmp	r5, #0
 8004f4e:	d142      	bne.n	8004fd6 <print_e+0xca>
 8004f50:	2c00      	cmp	r4, #0
 8004f52:	d140      	bne.n	8004fd6 <print_e+0xca>
 8004f54:	1c7b      	adds	r3, r7, #1
 8004f56:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 8004f5a:	b10a      	cbz	r2, 8004f60 <print_e+0x54>
 8004f5c:	2c00      	cmp	r4, #0
 8004f5e:	dc3e      	bgt.n	8004fde <print_e+0xd2>
 8004f60:	2e67      	cmp	r6, #103	; 0x67
 8004f62:	d043      	beq.n	8004fec <print_e+0xe0>
 8004f64:	2e47      	cmp	r6, #71	; 0x47
 8004f66:	d043      	beq.n	8004ff0 <print_e+0xe4>
 8004f68:	461a      	mov	r2, r3
 8004f6a:	2730      	movs	r7, #48	; 0x30
 8004f6c:	191d      	adds	r5, r3, r4
 8004f6e:	1aa9      	subs	r1, r5, r2
 8004f70:	2900      	cmp	r1, #0
 8004f72:	dc38      	bgt.n	8004fe6 <print_e+0xda>
 8004f74:	2c00      	cmp	r4, #0
 8004f76:	bfa8      	it	ge
 8004f78:	191b      	addge	r3, r3, r4
 8004f7a:	1e41      	subs	r1, r0, #1
 8004f7c:	2900      	cmp	r1, #0
 8004f7e:	9109      	str	r1, [sp, #36]	; 0x24
 8004f80:	461a      	mov	r2, r3
 8004f82:	bfb7      	itett	lt
 8004f84:	212d      	movlt	r1, #45	; 0x2d
 8004f86:	212b      	movge	r1, #43	; 0x2b
 8004f88:	f1c0 0001 	rsblt	r0, r0, #1
 8004f8c:	9009      	strlt	r0, [sp, #36]	; 0x24
 8004f8e:	9809      	ldr	r0, [sp, #36]	; 0x24
 8004f90:	f802 6b02 	strb.w	r6, [r2], #2
 8004f94:	bfb4      	ite	lt
 8004f96:	7059      	strblt	r1, [r3, #1]
 8004f98:	7059      	strbge	r1, [r3, #1]
 8004f9a:	2863      	cmp	r0, #99	; 0x63
 8004f9c:	dd0b      	ble.n	8004fb6 <print_e+0xaa>
 8004f9e:	2164      	movs	r1, #100	; 0x64
 8004fa0:	fb90 f1f1 	sdiv	r1, r0, r1
 8004fa4:	f101 0430 	add.w	r4, r1, #48	; 0x30
 8004fa8:	1cda      	adds	r2, r3, #3
 8004faa:	709c      	strb	r4, [r3, #2]
 8004fac:	f06f 0363 	mvn.w	r3, #99	; 0x63
 8004fb0:	fb03 0101 	mla	r1, r3, r1, r0
 8004fb4:	9109      	str	r1, [sp, #36]	; 0x24
 8004fb6:	230a      	movs	r3, #10
 8004fb8:	9909      	ldr	r1, [sp, #36]	; 0x24
 8004fba:	fb91 f3f3 	sdiv	r3, r1, r3
 8004fbe:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8004fc2:	7010      	strb	r0, [r2, #0]
 8004fc4:	f06f 0009 	mvn.w	r0, #9
 8004fc8:	fb00 1303 	mla	r3, r0, r3, r1
 8004fcc:	3330      	adds	r3, #48	; 0x30
 8004fce:	7053      	strb	r3, [r2, #1]
 8004fd0:	2300      	movs	r3, #0
 8004fd2:	7093      	strb	r3, [r2, #2]
 8004fd4:	e7b6      	b.n	8004f44 <print_e+0x38>
 8004fd6:	222e      	movs	r2, #46	; 0x2e
 8004fd8:	1cbb      	adds	r3, r7, #2
 8004fda:	707a      	strb	r2, [r7, #1]
 8004fdc:	e7bb      	b.n	8004f56 <print_e+0x4a>
 8004fde:	f803 2b01 	strb.w	r2, [r3], #1
 8004fe2:	3c01      	subs	r4, #1
 8004fe4:	e7b7      	b.n	8004f56 <print_e+0x4a>
 8004fe6:	f802 7b01 	strb.w	r7, [r2], #1
 8004fea:	e7c0      	b.n	8004f6e <print_e+0x62>
 8004fec:	2665      	movs	r6, #101	; 0x65
 8004fee:	e7c4      	b.n	8004f7a <print_e+0x6e>
 8004ff0:	2645      	movs	r6, #69	; 0x45
 8004ff2:	e7c2      	b.n	8004f7a <print_e+0x6e>
 8004ff4:	0000      	movs	r0, r0
	...

08004ff8 <_gcvt>:
 8004ff8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004ffc:	4617      	mov	r7, r2
 8004ffe:	461d      	mov	r5, r3
 8005000:	b08b      	sub	sp, #44	; 0x2c
 8005002:	4681      	mov	r9, r0
 8005004:	e9dd 6412 	ldrd	r6, r4, [sp, #72]	; 0x48
 8005008:	2200      	movs	r2, #0
 800500a:	2300      	movs	r3, #0
 800500c:	4638      	mov	r0, r7
 800500e:	4629      	mov	r1, r5
 8005010:	f8dd 8054 	ldr.w	r8, [sp, #84]	; 0x54
 8005014:	f7fb fcd2 	bl	80009bc <__aeabi_dcmplt>
 8005018:	b108      	cbz	r0, 800501e <_gcvt+0x26>
 800501a:	f105 4500 	add.w	r5, r5, #2147483648	; 0x80000000
 800501e:	2200      	movs	r2, #0
 8005020:	2300      	movs	r3, #0
 8005022:	4638      	mov	r0, r7
 8005024:	4629      	mov	r1, r5
 8005026:	f7fb fcbf 	bl	80009a8 <__aeabi_dcmpeq>
 800502a:	b138      	cbz	r0, 800503c <_gcvt+0x44>
 800502c:	2330      	movs	r3, #48	; 0x30
 800502e:	7023      	strb	r3, [r4, #0]
 8005030:	2300      	movs	r3, #0
 8005032:	7063      	strb	r3, [r4, #1]
 8005034:	4620      	mov	r0, r4
 8005036:	b00b      	add	sp, #44	; 0x2c
 8005038:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800503c:	a352      	add	r3, pc, #328	; (adr r3, 8005188 <_gcvt+0x190>)
 800503e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005042:	4638      	mov	r0, r7
 8005044:	4629      	mov	r1, r5
 8005046:	f7fb fcc3 	bl	80009d0 <__aeabi_dcmple>
 800504a:	b168      	cbz	r0, 8005068 <_gcvt+0x70>
 800504c:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
 8005050:	3e01      	subs	r6, #1
 8005052:	9301      	str	r3, [sp, #4]
 8005054:	f8cd 8008 	str.w	r8, [sp, #8]
 8005058:	9600      	str	r6, [sp, #0]
 800505a:	463a      	mov	r2, r7
 800505c:	462b      	mov	r3, r5
 800505e:	4621      	mov	r1, r4
 8005060:	4648      	mov	r0, r9
 8005062:	f7ff ff53 	bl	8004f0c <print_e>
 8005066:	e7e5      	b.n	8005034 <_gcvt+0x3c>
 8005068:	4630      	mov	r0, r6
 800506a:	f000 fb8d 	bl	8005788 <_mprec_log10>
 800506e:	463a      	mov	r2, r7
 8005070:	462b      	mov	r3, r5
 8005072:	f7fb fcad 	bl	80009d0 <__aeabi_dcmple>
 8005076:	2800      	cmp	r0, #0
 8005078:	d1e8      	bne.n	800504c <_gcvt+0x54>
 800507a:	2200      	movs	r2, #0
 800507c:	4b44      	ldr	r3, [pc, #272]	; (8005190 <_gcvt+0x198>)
 800507e:	4629      	mov	r1, r5
 8005080:	4638      	mov	r0, r7
 8005082:	f7fb fc9b 	bl	80009bc <__aeabi_dcmplt>
 8005086:	a909      	add	r1, sp, #36	; 0x24
 8005088:	aa08      	add	r2, sp, #32
 800508a:	ab07      	add	r3, sp, #28
 800508c:	e9cd 2103 	strd	r2, r1, [sp, #12]
 8005090:	e9cd 6301 	strd	r6, r3, [sp, #4]
 8005094:	b388      	cbz	r0, 80050fa <_gcvt+0x102>
 8005096:	2303      	movs	r3, #3
 8005098:	9300      	str	r3, [sp, #0]
 800509a:	463a      	mov	r2, r7
 800509c:	462b      	mov	r3, r5
 800509e:	4648      	mov	r0, r9
 80050a0:	f000 fcaa 	bl	80059f8 <_dtoa_r>
 80050a4:	f242 730f 	movw	r3, #9999	; 0x270f
 80050a8:	9a07      	ldr	r2, [sp, #28]
 80050aa:	429a      	cmp	r2, r3
 80050ac:	d027      	beq.n	80050fe <_gcvt+0x106>
 80050ae:	4623      	mov	r3, r4
 80050b0:	4426      	add	r6, r4
 80050b2:	4607      	mov	r7, r0
 80050b4:	f810 1b01 	ldrb.w	r1, [r0], #1
 80050b8:	1af2      	subs	r2, r6, r3
 80050ba:	9d07      	ldr	r5, [sp, #28]
 80050bc:	b349      	cbz	r1, 8005112 <_gcvt+0x11a>
 80050be:	2d00      	cmp	r5, #0
 80050c0:	dc22      	bgt.n	8005108 <_gcvt+0x110>
 80050c2:	f1b8 0f00 	cmp.w	r8, #0
 80050c6:	d102      	bne.n	80050ce <_gcvt+0xd6>
 80050c8:	7839      	ldrb	r1, [r7, #0]
 80050ca:	2900      	cmp	r1, #0
 80050cc:	d049      	beq.n	8005162 <_gcvt+0x16a>
 80050ce:	429c      	cmp	r4, r3
 80050d0:	bf04      	itt	eq
 80050d2:	2130      	moveq	r1, #48	; 0x30
 80050d4:	7021      	strbeq	r1, [r4, #0]
 80050d6:	f04f 012e 	mov.w	r1, #46	; 0x2e
 80050da:	f04f 0000 	mov.w	r0, #0
 80050de:	f04f 0630 	mov.w	r6, #48	; 0x30
 80050e2:	bf08      	it	eq
 80050e4:	1c63      	addeq	r3, r4, #1
 80050e6:	7019      	strb	r1, [r3, #0]
 80050e8:	9907      	ldr	r1, [sp, #28]
 80050ea:	3301      	adds	r3, #1
 80050ec:	2900      	cmp	r1, #0
 80050ee:	460d      	mov	r5, r1
 80050f0:	db24      	blt.n	800513c <_gcvt+0x144>
 80050f2:	b100      	cbz	r0, 80050f6 <_gcvt+0xfe>
 80050f4:	9107      	str	r1, [sp, #28]
 80050f6:	1e79      	subs	r1, r7, #1
 80050f8:	e02b      	b.n	8005152 <_gcvt+0x15a>
 80050fa:	2302      	movs	r3, #2
 80050fc:	e7cc      	b.n	8005098 <_gcvt+0xa0>
 80050fe:	4601      	mov	r1, r0
 8005100:	4620      	mov	r0, r4
 8005102:	f000 fbd5 	bl	80058b0 <strcpy>
 8005106:	e795      	b.n	8005034 <_gcvt+0x3c>
 8005108:	3d01      	subs	r5, #1
 800510a:	f803 1b01 	strb.w	r1, [r3], #1
 800510e:	9507      	str	r5, [sp, #28]
 8005110:	e7cf      	b.n	80050b2 <_gcvt+0xba>
 8005112:	1aad      	subs	r5, r5, r2
 8005114:	2630      	movs	r6, #48	; 0x30
 8005116:	e005      	b.n	8005124 <_gcvt+0x12c>
 8005118:	2a00      	cmp	r2, #0
 800511a:	dd06      	ble.n	800512a <_gcvt+0x132>
 800511c:	2101      	movs	r1, #1
 800511e:	f803 6b01 	strb.w	r6, [r3], #1
 8005122:	3a01      	subs	r2, #1
 8005124:	18a8      	adds	r0, r5, r2
 8005126:	2800      	cmp	r0, #0
 8005128:	dcf6      	bgt.n	8005118 <_gcvt+0x120>
 800512a:	2900      	cmp	r1, #0
 800512c:	d0c9      	beq.n	80050c2 <_gcvt+0xca>
 800512e:	9007      	str	r0, [sp, #28]
 8005130:	e7c7      	b.n	80050c2 <_gcvt+0xca>
 8005132:	f803 6b01 	strb.w	r6, [r3], #1
 8005136:	3a01      	subs	r2, #1
 8005138:	2001      	movs	r0, #1
 800513a:	e7d7      	b.n	80050ec <_gcvt+0xf4>
 800513c:	2a00      	cmp	r2, #0
 800513e:	f101 0101 	add.w	r1, r1, #1
 8005142:	dcf6      	bgt.n	8005132 <_gcvt+0x13a>
 8005144:	2800      	cmp	r0, #0
 8005146:	d0d6      	beq.n	80050f6 <_gcvt+0xfe>
 8005148:	9507      	str	r5, [sp, #28]
 800514a:	e7d4      	b.n	80050f6 <_gcvt+0xfe>
 800514c:	f803 0b01 	strb.w	r0, [r3], #1
 8005150:	3a01      	subs	r2, #1
 8005152:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 8005156:	b108      	cbz	r0, 800515c <_gcvt+0x164>
 8005158:	2a00      	cmp	r2, #0
 800515a:	dcf7      	bgt.n	800514c <_gcvt+0x154>
 800515c:	f1b8 0f00 	cmp.w	r8, #0
 8005160:	d10b      	bne.n	800517a <_gcvt+0x182>
 8005162:	2200      	movs	r2, #0
 8005164:	701a      	strb	r2, [r3, #0]
 8005166:	e765      	b.n	8005034 <_gcvt+0x3c>
 8005168:	f801 6b01 	strb.w	r6, [r1], #1
 800516c:	1a68      	subs	r0, r5, r1
 800516e:	2800      	cmp	r0, #0
 8005170:	dcfa      	bgt.n	8005168 <_gcvt+0x170>
 8005172:	2a00      	cmp	r2, #0
 8005174:	bfa8      	it	ge
 8005176:	189b      	addge	r3, r3, r2
 8005178:	e7f3      	b.n	8005162 <_gcvt+0x16a>
 800517a:	4619      	mov	r1, r3
 800517c:	189d      	adds	r5, r3, r2
 800517e:	2630      	movs	r6, #48	; 0x30
 8005180:	e7f4      	b.n	800516c <_gcvt+0x174>
 8005182:	bf00      	nop
 8005184:	f3af 8000 	nop.w
 8005188:	eb1c432d 	.word	0xeb1c432d
 800518c:	3f1a36e2 	.word	0x3f1a36e2
 8005190:	3ff00000 	.word	0x3ff00000

08005194 <__locale_ctype_ptr_l>:
 8005194:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8005198:	4770      	bx	lr
	...

0800519c <malloc>:
 800519c:	4b02      	ldr	r3, [pc, #8]	; (80051a8 <malloc+0xc>)
 800519e:	4601      	mov	r1, r0
 80051a0:	6818      	ldr	r0, [r3, #0]
 80051a2:	f000 bb1b 	b.w	80057dc <_malloc_r>
 80051a6:	bf00      	nop
 80051a8:	20000010 	.word	0x20000010

080051ac <__ascii_mbtowc>:
 80051ac:	b082      	sub	sp, #8
 80051ae:	b901      	cbnz	r1, 80051b2 <__ascii_mbtowc+0x6>
 80051b0:	a901      	add	r1, sp, #4
 80051b2:	b142      	cbz	r2, 80051c6 <__ascii_mbtowc+0x1a>
 80051b4:	b14b      	cbz	r3, 80051ca <__ascii_mbtowc+0x1e>
 80051b6:	7813      	ldrb	r3, [r2, #0]
 80051b8:	600b      	str	r3, [r1, #0]
 80051ba:	7812      	ldrb	r2, [r2, #0]
 80051bc:	1c10      	adds	r0, r2, #0
 80051be:	bf18      	it	ne
 80051c0:	2001      	movne	r0, #1
 80051c2:	b002      	add	sp, #8
 80051c4:	4770      	bx	lr
 80051c6:	4610      	mov	r0, r2
 80051c8:	e7fb      	b.n	80051c2 <__ascii_mbtowc+0x16>
 80051ca:	f06f 0001 	mvn.w	r0, #1
 80051ce:	e7f8      	b.n	80051c2 <__ascii_mbtowc+0x16>

080051d0 <_Balloc>:
 80051d0:	b570      	push	{r4, r5, r6, lr}
 80051d2:	6a45      	ldr	r5, [r0, #36]	; 0x24
 80051d4:	4604      	mov	r4, r0
 80051d6:	460e      	mov	r6, r1
 80051d8:	b93d      	cbnz	r5, 80051ea <_Balloc+0x1a>
 80051da:	2010      	movs	r0, #16
 80051dc:	f7ff ffde 	bl	800519c <malloc>
 80051e0:	6260      	str	r0, [r4, #36]	; 0x24
 80051e2:	e9c0 5501 	strd	r5, r5, [r0, #4]
 80051e6:	6005      	str	r5, [r0, #0]
 80051e8:	60c5      	str	r5, [r0, #12]
 80051ea:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80051ec:	68eb      	ldr	r3, [r5, #12]
 80051ee:	b183      	cbz	r3, 8005212 <_Balloc+0x42>
 80051f0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80051f2:	68db      	ldr	r3, [r3, #12]
 80051f4:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 80051f8:	b9b8      	cbnz	r0, 800522a <_Balloc+0x5a>
 80051fa:	2101      	movs	r1, #1
 80051fc:	fa01 f506 	lsl.w	r5, r1, r6
 8005200:	1d6a      	adds	r2, r5, #5
 8005202:	0092      	lsls	r2, r2, #2
 8005204:	4620      	mov	r0, r4
 8005206:	f000 fadb 	bl	80057c0 <_calloc_r>
 800520a:	b160      	cbz	r0, 8005226 <_Balloc+0x56>
 800520c:	e9c0 6501 	strd	r6, r5, [r0, #4]
 8005210:	e00e      	b.n	8005230 <_Balloc+0x60>
 8005212:	2221      	movs	r2, #33	; 0x21
 8005214:	2104      	movs	r1, #4
 8005216:	4620      	mov	r0, r4
 8005218:	f000 fad2 	bl	80057c0 <_calloc_r>
 800521c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800521e:	60e8      	str	r0, [r5, #12]
 8005220:	68db      	ldr	r3, [r3, #12]
 8005222:	2b00      	cmp	r3, #0
 8005224:	d1e4      	bne.n	80051f0 <_Balloc+0x20>
 8005226:	2000      	movs	r0, #0
 8005228:	bd70      	pop	{r4, r5, r6, pc}
 800522a:	6802      	ldr	r2, [r0, #0]
 800522c:	f843 2026 	str.w	r2, [r3, r6, lsl #2]
 8005230:	2300      	movs	r3, #0
 8005232:	e9c0 3303 	strd	r3, r3, [r0, #12]
 8005236:	e7f7      	b.n	8005228 <_Balloc+0x58>

08005238 <_Bfree>:
 8005238:	b570      	push	{r4, r5, r6, lr}
 800523a:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800523c:	4606      	mov	r6, r0
 800523e:	460d      	mov	r5, r1
 8005240:	b93c      	cbnz	r4, 8005252 <_Bfree+0x1a>
 8005242:	2010      	movs	r0, #16
 8005244:	f7ff ffaa 	bl	800519c <malloc>
 8005248:	6270      	str	r0, [r6, #36]	; 0x24
 800524a:	e9c0 4401 	strd	r4, r4, [r0, #4]
 800524e:	6004      	str	r4, [r0, #0]
 8005250:	60c4      	str	r4, [r0, #12]
 8005252:	b13d      	cbz	r5, 8005264 <_Bfree+0x2c>
 8005254:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8005256:	686a      	ldr	r2, [r5, #4]
 8005258:	68db      	ldr	r3, [r3, #12]
 800525a:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800525e:	6029      	str	r1, [r5, #0]
 8005260:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
 8005264:	bd70      	pop	{r4, r5, r6, pc}

08005266 <__multadd>:
 8005266:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800526a:	461f      	mov	r7, r3
 800526c:	4606      	mov	r6, r0
 800526e:	460c      	mov	r4, r1
 8005270:	2300      	movs	r3, #0
 8005272:	690d      	ldr	r5, [r1, #16]
 8005274:	f101 0c14 	add.w	ip, r1, #20
 8005278:	f8dc 0000 	ldr.w	r0, [ip]
 800527c:	3301      	adds	r3, #1
 800527e:	b281      	uxth	r1, r0
 8005280:	fb02 7101 	mla	r1, r2, r1, r7
 8005284:	0c00      	lsrs	r0, r0, #16
 8005286:	0c0f      	lsrs	r7, r1, #16
 8005288:	fb02 7000 	mla	r0, r2, r0, r7
 800528c:	b289      	uxth	r1, r1
 800528e:	eb01 4100 	add.w	r1, r1, r0, lsl #16
 8005292:	429d      	cmp	r5, r3
 8005294:	ea4f 4710 	mov.w	r7, r0, lsr #16
 8005298:	f84c 1b04 	str.w	r1, [ip], #4
 800529c:	dcec      	bgt.n	8005278 <__multadd+0x12>
 800529e:	b1d7      	cbz	r7, 80052d6 <__multadd+0x70>
 80052a0:	68a3      	ldr	r3, [r4, #8]
 80052a2:	42ab      	cmp	r3, r5
 80052a4:	dc12      	bgt.n	80052cc <__multadd+0x66>
 80052a6:	6861      	ldr	r1, [r4, #4]
 80052a8:	4630      	mov	r0, r6
 80052aa:	3101      	adds	r1, #1
 80052ac:	f7ff ff90 	bl	80051d0 <_Balloc>
 80052b0:	4680      	mov	r8, r0
 80052b2:	6922      	ldr	r2, [r4, #16]
 80052b4:	f104 010c 	add.w	r1, r4, #12
 80052b8:	3202      	adds	r2, #2
 80052ba:	0092      	lsls	r2, r2, #2
 80052bc:	300c      	adds	r0, #12
 80052be:	f7ff fd2b 	bl	8004d18 <memcpy>
 80052c2:	4621      	mov	r1, r4
 80052c4:	4630      	mov	r0, r6
 80052c6:	f7ff ffb7 	bl	8005238 <_Bfree>
 80052ca:	4644      	mov	r4, r8
 80052cc:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 80052d0:	3501      	adds	r5, #1
 80052d2:	615f      	str	r7, [r3, #20]
 80052d4:	6125      	str	r5, [r4, #16]
 80052d6:	4620      	mov	r0, r4
 80052d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080052dc <__hi0bits>:
 80052dc:	0c02      	lsrs	r2, r0, #16
 80052de:	0412      	lsls	r2, r2, #16
 80052e0:	4603      	mov	r3, r0
 80052e2:	b9b2      	cbnz	r2, 8005312 <__hi0bits+0x36>
 80052e4:	0403      	lsls	r3, r0, #16
 80052e6:	2010      	movs	r0, #16
 80052e8:	f013 4f7f 	tst.w	r3, #4278190080	; 0xff000000
 80052ec:	bf04      	itt	eq
 80052ee:	021b      	lsleq	r3, r3, #8
 80052f0:	3008      	addeq	r0, #8
 80052f2:	f013 4f70 	tst.w	r3, #4026531840	; 0xf0000000
 80052f6:	bf04      	itt	eq
 80052f8:	011b      	lsleq	r3, r3, #4
 80052fa:	3004      	addeq	r0, #4
 80052fc:	f013 4f40 	tst.w	r3, #3221225472	; 0xc0000000
 8005300:	bf04      	itt	eq
 8005302:	009b      	lsleq	r3, r3, #2
 8005304:	3002      	addeq	r0, #2
 8005306:	2b00      	cmp	r3, #0
 8005308:	db06      	blt.n	8005318 <__hi0bits+0x3c>
 800530a:	005b      	lsls	r3, r3, #1
 800530c:	d503      	bpl.n	8005316 <__hi0bits+0x3a>
 800530e:	3001      	adds	r0, #1
 8005310:	4770      	bx	lr
 8005312:	2000      	movs	r0, #0
 8005314:	e7e8      	b.n	80052e8 <__hi0bits+0xc>
 8005316:	2020      	movs	r0, #32
 8005318:	4770      	bx	lr

0800531a <__lo0bits>:
 800531a:	6803      	ldr	r3, [r0, #0]
 800531c:	4601      	mov	r1, r0
 800531e:	f013 0207 	ands.w	r2, r3, #7
 8005322:	d00b      	beq.n	800533c <__lo0bits+0x22>
 8005324:	07da      	lsls	r2, r3, #31
 8005326:	d423      	bmi.n	8005370 <__lo0bits+0x56>
 8005328:	0798      	lsls	r0, r3, #30
 800532a:	bf49      	itett	mi
 800532c:	085b      	lsrmi	r3, r3, #1
 800532e:	089b      	lsrpl	r3, r3, #2
 8005330:	2001      	movmi	r0, #1
 8005332:	600b      	strmi	r3, [r1, #0]
 8005334:	bf5c      	itt	pl
 8005336:	600b      	strpl	r3, [r1, #0]
 8005338:	2002      	movpl	r0, #2
 800533a:	4770      	bx	lr
 800533c:	b298      	uxth	r0, r3
 800533e:	b9a8      	cbnz	r0, 800536c <__lo0bits+0x52>
 8005340:	2010      	movs	r0, #16
 8005342:	0c1b      	lsrs	r3, r3, #16
 8005344:	f013 0fff 	tst.w	r3, #255	; 0xff
 8005348:	bf04      	itt	eq
 800534a:	0a1b      	lsreq	r3, r3, #8
 800534c:	3008      	addeq	r0, #8
 800534e:	071a      	lsls	r2, r3, #28
 8005350:	bf04      	itt	eq
 8005352:	091b      	lsreq	r3, r3, #4
 8005354:	3004      	addeq	r0, #4
 8005356:	079a      	lsls	r2, r3, #30
 8005358:	bf04      	itt	eq
 800535a:	089b      	lsreq	r3, r3, #2
 800535c:	3002      	addeq	r0, #2
 800535e:	07da      	lsls	r2, r3, #31
 8005360:	d402      	bmi.n	8005368 <__lo0bits+0x4e>
 8005362:	085b      	lsrs	r3, r3, #1
 8005364:	d006      	beq.n	8005374 <__lo0bits+0x5a>
 8005366:	3001      	adds	r0, #1
 8005368:	600b      	str	r3, [r1, #0]
 800536a:	4770      	bx	lr
 800536c:	4610      	mov	r0, r2
 800536e:	e7e9      	b.n	8005344 <__lo0bits+0x2a>
 8005370:	2000      	movs	r0, #0
 8005372:	4770      	bx	lr
 8005374:	2020      	movs	r0, #32
 8005376:	4770      	bx	lr

08005378 <__i2b>:
 8005378:	b510      	push	{r4, lr}
 800537a:	460c      	mov	r4, r1
 800537c:	2101      	movs	r1, #1
 800537e:	f7ff ff27 	bl	80051d0 <_Balloc>
 8005382:	2201      	movs	r2, #1
 8005384:	6144      	str	r4, [r0, #20]
 8005386:	6102      	str	r2, [r0, #16]
 8005388:	bd10      	pop	{r4, pc}

0800538a <__multiply>:
 800538a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800538e:	4614      	mov	r4, r2
 8005390:	690a      	ldr	r2, [r1, #16]
 8005392:	6923      	ldr	r3, [r4, #16]
 8005394:	4688      	mov	r8, r1
 8005396:	429a      	cmp	r2, r3
 8005398:	bfbe      	ittt	lt
 800539a:	460b      	movlt	r3, r1
 800539c:	46a0      	movlt	r8, r4
 800539e:	461c      	movlt	r4, r3
 80053a0:	f8d8 7010 	ldr.w	r7, [r8, #16]
 80053a4:	f8d4 9010 	ldr.w	r9, [r4, #16]
 80053a8:	f8d8 3008 	ldr.w	r3, [r8, #8]
 80053ac:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80053b0:	eb07 0609 	add.w	r6, r7, r9
 80053b4:	42b3      	cmp	r3, r6
 80053b6:	bfb8      	it	lt
 80053b8:	3101      	addlt	r1, #1
 80053ba:	f7ff ff09 	bl	80051d0 <_Balloc>
 80053be:	f100 0514 	add.w	r5, r0, #20
 80053c2:	462b      	mov	r3, r5
 80053c4:	2200      	movs	r2, #0
 80053c6:	eb05 0e86 	add.w	lr, r5, r6, lsl #2
 80053ca:	4573      	cmp	r3, lr
 80053cc:	d316      	bcc.n	80053fc <__multiply+0x72>
 80053ce:	f104 0214 	add.w	r2, r4, #20
 80053d2:	f108 0114 	add.w	r1, r8, #20
 80053d6:	eb02 0389 	add.w	r3, r2, r9, lsl #2
 80053da:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 80053de:	9300      	str	r3, [sp, #0]
 80053e0:	9b00      	ldr	r3, [sp, #0]
 80053e2:	9201      	str	r2, [sp, #4]
 80053e4:	4293      	cmp	r3, r2
 80053e6:	d80c      	bhi.n	8005402 <__multiply+0x78>
 80053e8:	2e00      	cmp	r6, #0
 80053ea:	dd03      	ble.n	80053f4 <__multiply+0x6a>
 80053ec:	f85e 3d04 	ldr.w	r3, [lr, #-4]!
 80053f0:	2b00      	cmp	r3, #0
 80053f2:	d05d      	beq.n	80054b0 <__multiply+0x126>
 80053f4:	6106      	str	r6, [r0, #16]
 80053f6:	b003      	add	sp, #12
 80053f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80053fc:	f843 2b04 	str.w	r2, [r3], #4
 8005400:	e7e3      	b.n	80053ca <__multiply+0x40>
 8005402:	f8b2 b000 	ldrh.w	fp, [r2]
 8005406:	f1bb 0f00 	cmp.w	fp, #0
 800540a:	d023      	beq.n	8005454 <__multiply+0xca>
 800540c:	4689      	mov	r9, r1
 800540e:	46ac      	mov	ip, r5
 8005410:	f04f 0800 	mov.w	r8, #0
 8005414:	f859 4b04 	ldr.w	r4, [r9], #4
 8005418:	f8dc a000 	ldr.w	sl, [ip]
 800541c:	b2a3      	uxth	r3, r4
 800541e:	fa1f fa8a 	uxth.w	sl, sl
 8005422:	fb0b a303 	mla	r3, fp, r3, sl
 8005426:	ea4f 4a14 	mov.w	sl, r4, lsr #16
 800542a:	f8dc 4000 	ldr.w	r4, [ip]
 800542e:	4443      	add	r3, r8
 8005430:	ea4f 4814 	mov.w	r8, r4, lsr #16
 8005434:	fb0b 840a 	mla	r4, fp, sl, r8
 8005438:	46e2      	mov	sl, ip
 800543a:	eb04 4413 	add.w	r4, r4, r3, lsr #16
 800543e:	b29b      	uxth	r3, r3
 8005440:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8005444:	454f      	cmp	r7, r9
 8005446:	ea4f 4814 	mov.w	r8, r4, lsr #16
 800544a:	f84a 3b04 	str.w	r3, [sl], #4
 800544e:	d82b      	bhi.n	80054a8 <__multiply+0x11e>
 8005450:	f8cc 8004 	str.w	r8, [ip, #4]
 8005454:	9b01      	ldr	r3, [sp, #4]
 8005456:	3204      	adds	r2, #4
 8005458:	f8b3 a002 	ldrh.w	sl, [r3, #2]
 800545c:	f1ba 0f00 	cmp.w	sl, #0
 8005460:	d020      	beq.n	80054a4 <__multiply+0x11a>
 8005462:	4689      	mov	r9, r1
 8005464:	46a8      	mov	r8, r5
 8005466:	f04f 0b00 	mov.w	fp, #0
 800546a:	682b      	ldr	r3, [r5, #0]
 800546c:	f8b9 c000 	ldrh.w	ip, [r9]
 8005470:	f8b8 4002 	ldrh.w	r4, [r8, #2]
 8005474:	b29b      	uxth	r3, r3
 8005476:	fb0a 440c 	mla	r4, sl, ip, r4
 800547a:	46c4      	mov	ip, r8
 800547c:	445c      	add	r4, fp
 800547e:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 8005482:	f84c 3b04 	str.w	r3, [ip], #4
 8005486:	f859 3b04 	ldr.w	r3, [r9], #4
 800548a:	f8b8 b004 	ldrh.w	fp, [r8, #4]
 800548e:	0c1b      	lsrs	r3, r3, #16
 8005490:	fb0a b303 	mla	r3, sl, r3, fp
 8005494:	454f      	cmp	r7, r9
 8005496:	eb03 4314 	add.w	r3, r3, r4, lsr #16
 800549a:	ea4f 4b13 	mov.w	fp, r3, lsr #16
 800549e:	d805      	bhi.n	80054ac <__multiply+0x122>
 80054a0:	f8c8 3004 	str.w	r3, [r8, #4]
 80054a4:	3504      	adds	r5, #4
 80054a6:	e79b      	b.n	80053e0 <__multiply+0x56>
 80054a8:	46d4      	mov	ip, sl
 80054aa:	e7b3      	b.n	8005414 <__multiply+0x8a>
 80054ac:	46e0      	mov	r8, ip
 80054ae:	e7dd      	b.n	800546c <__multiply+0xe2>
 80054b0:	3e01      	subs	r6, #1
 80054b2:	e799      	b.n	80053e8 <__multiply+0x5e>

080054b4 <__pow5mult>:
 80054b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80054b8:	4615      	mov	r5, r2
 80054ba:	f012 0203 	ands.w	r2, r2, #3
 80054be:	4606      	mov	r6, r0
 80054c0:	460f      	mov	r7, r1
 80054c2:	d007      	beq.n	80054d4 <__pow5mult+0x20>
 80054c4:	4c21      	ldr	r4, [pc, #132]	; (800554c <__pow5mult+0x98>)
 80054c6:	3a01      	subs	r2, #1
 80054c8:	2300      	movs	r3, #0
 80054ca:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 80054ce:	f7ff feca 	bl	8005266 <__multadd>
 80054d2:	4607      	mov	r7, r0
 80054d4:	10ad      	asrs	r5, r5, #2
 80054d6:	d035      	beq.n	8005544 <__pow5mult+0x90>
 80054d8:	6a74      	ldr	r4, [r6, #36]	; 0x24
 80054da:	b93c      	cbnz	r4, 80054ec <__pow5mult+0x38>
 80054dc:	2010      	movs	r0, #16
 80054de:	f7ff fe5d 	bl	800519c <malloc>
 80054e2:	6270      	str	r0, [r6, #36]	; 0x24
 80054e4:	e9c0 4401 	strd	r4, r4, [r0, #4]
 80054e8:	6004      	str	r4, [r0, #0]
 80054ea:	60c4      	str	r4, [r0, #12]
 80054ec:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 80054f0:	f8d8 4008 	ldr.w	r4, [r8, #8]
 80054f4:	b94c      	cbnz	r4, 800550a <__pow5mult+0x56>
 80054f6:	f240 2171 	movw	r1, #625	; 0x271
 80054fa:	4630      	mov	r0, r6
 80054fc:	f7ff ff3c 	bl	8005378 <__i2b>
 8005500:	2300      	movs	r3, #0
 8005502:	4604      	mov	r4, r0
 8005504:	f8c8 0008 	str.w	r0, [r8, #8]
 8005508:	6003      	str	r3, [r0, #0]
 800550a:	f04f 0800 	mov.w	r8, #0
 800550e:	07eb      	lsls	r3, r5, #31
 8005510:	d50a      	bpl.n	8005528 <__pow5mult+0x74>
 8005512:	4639      	mov	r1, r7
 8005514:	4622      	mov	r2, r4
 8005516:	4630      	mov	r0, r6
 8005518:	f7ff ff37 	bl	800538a <__multiply>
 800551c:	4681      	mov	r9, r0
 800551e:	4639      	mov	r1, r7
 8005520:	4630      	mov	r0, r6
 8005522:	f7ff fe89 	bl	8005238 <_Bfree>
 8005526:	464f      	mov	r7, r9
 8005528:	106d      	asrs	r5, r5, #1
 800552a:	d00b      	beq.n	8005544 <__pow5mult+0x90>
 800552c:	6820      	ldr	r0, [r4, #0]
 800552e:	b938      	cbnz	r0, 8005540 <__pow5mult+0x8c>
 8005530:	4622      	mov	r2, r4
 8005532:	4621      	mov	r1, r4
 8005534:	4630      	mov	r0, r6
 8005536:	f7ff ff28 	bl	800538a <__multiply>
 800553a:	6020      	str	r0, [r4, #0]
 800553c:	f8c0 8000 	str.w	r8, [r0]
 8005540:	4604      	mov	r4, r0
 8005542:	e7e4      	b.n	800550e <__pow5mult+0x5a>
 8005544:	4638      	mov	r0, r7
 8005546:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800554a:	bf00      	nop
 800554c:	08006800 	.word	0x08006800

08005550 <__lshift>:
 8005550:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005554:	460c      	mov	r4, r1
 8005556:	4607      	mov	r7, r0
 8005558:	4616      	mov	r6, r2
 800555a:	6923      	ldr	r3, [r4, #16]
 800555c:	ea4f 1a62 	mov.w	sl, r2, asr #5
 8005560:	eb0a 0903 	add.w	r9, sl, r3
 8005564:	6849      	ldr	r1, [r1, #4]
 8005566:	68a3      	ldr	r3, [r4, #8]
 8005568:	f109 0501 	add.w	r5, r9, #1
 800556c:	42ab      	cmp	r3, r5
 800556e:	db32      	blt.n	80055d6 <__lshift+0x86>
 8005570:	4638      	mov	r0, r7
 8005572:	f7ff fe2d 	bl	80051d0 <_Balloc>
 8005576:	2300      	movs	r3, #0
 8005578:	4680      	mov	r8, r0
 800557a:	461a      	mov	r2, r3
 800557c:	f100 0114 	add.w	r1, r0, #20
 8005580:	4553      	cmp	r3, sl
 8005582:	db2b      	blt.n	80055dc <__lshift+0x8c>
 8005584:	6920      	ldr	r0, [r4, #16]
 8005586:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 800558a:	f104 0314 	add.w	r3, r4, #20
 800558e:	f016 021f 	ands.w	r2, r6, #31
 8005592:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 8005596:	eb03 0c80 	add.w	ip, r3, r0, lsl #2
 800559a:	d025      	beq.n	80055e8 <__lshift+0x98>
 800559c:	2000      	movs	r0, #0
 800559e:	f1c2 0e20 	rsb	lr, r2, #32
 80055a2:	468a      	mov	sl, r1
 80055a4:	681e      	ldr	r6, [r3, #0]
 80055a6:	4096      	lsls	r6, r2
 80055a8:	4330      	orrs	r0, r6
 80055aa:	f84a 0b04 	str.w	r0, [sl], #4
 80055ae:	f853 0b04 	ldr.w	r0, [r3], #4
 80055b2:	459c      	cmp	ip, r3
 80055b4:	fa20 f00e 	lsr.w	r0, r0, lr
 80055b8:	d814      	bhi.n	80055e4 <__lshift+0x94>
 80055ba:	6048      	str	r0, [r1, #4]
 80055bc:	b108      	cbz	r0, 80055c2 <__lshift+0x72>
 80055be:	f109 0502 	add.w	r5, r9, #2
 80055c2:	3d01      	subs	r5, #1
 80055c4:	4638      	mov	r0, r7
 80055c6:	f8c8 5010 	str.w	r5, [r8, #16]
 80055ca:	4621      	mov	r1, r4
 80055cc:	f7ff fe34 	bl	8005238 <_Bfree>
 80055d0:	4640      	mov	r0, r8
 80055d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80055d6:	3101      	adds	r1, #1
 80055d8:	005b      	lsls	r3, r3, #1
 80055da:	e7c7      	b.n	800556c <__lshift+0x1c>
 80055dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 80055e0:	3301      	adds	r3, #1
 80055e2:	e7cd      	b.n	8005580 <__lshift+0x30>
 80055e4:	4651      	mov	r1, sl
 80055e6:	e7dc      	b.n	80055a2 <__lshift+0x52>
 80055e8:	3904      	subs	r1, #4
 80055ea:	f853 2b04 	ldr.w	r2, [r3], #4
 80055ee:	459c      	cmp	ip, r3
 80055f0:	f841 2f04 	str.w	r2, [r1, #4]!
 80055f4:	d8f9      	bhi.n	80055ea <__lshift+0x9a>
 80055f6:	e7e4      	b.n	80055c2 <__lshift+0x72>

080055f8 <__mcmp>:
 80055f8:	6903      	ldr	r3, [r0, #16]
 80055fa:	690a      	ldr	r2, [r1, #16]
 80055fc:	b530      	push	{r4, r5, lr}
 80055fe:	1a9b      	subs	r3, r3, r2
 8005600:	d10c      	bne.n	800561c <__mcmp+0x24>
 8005602:	0092      	lsls	r2, r2, #2
 8005604:	3014      	adds	r0, #20
 8005606:	3114      	adds	r1, #20
 8005608:	1884      	adds	r4, r0, r2
 800560a:	4411      	add	r1, r2
 800560c:	f854 5d04 	ldr.w	r5, [r4, #-4]!
 8005610:	f851 2d04 	ldr.w	r2, [r1, #-4]!
 8005614:	4295      	cmp	r5, r2
 8005616:	d003      	beq.n	8005620 <__mcmp+0x28>
 8005618:	d305      	bcc.n	8005626 <__mcmp+0x2e>
 800561a:	2301      	movs	r3, #1
 800561c:	4618      	mov	r0, r3
 800561e:	bd30      	pop	{r4, r5, pc}
 8005620:	42a0      	cmp	r0, r4
 8005622:	d3f3      	bcc.n	800560c <__mcmp+0x14>
 8005624:	e7fa      	b.n	800561c <__mcmp+0x24>
 8005626:	f04f 33ff 	mov.w	r3, #4294967295
 800562a:	e7f7      	b.n	800561c <__mcmp+0x24>

0800562c <__mdiff>:
 800562c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005630:	460d      	mov	r5, r1
 8005632:	4607      	mov	r7, r0
 8005634:	4611      	mov	r1, r2
 8005636:	4628      	mov	r0, r5
 8005638:	4614      	mov	r4, r2
 800563a:	f7ff ffdd 	bl	80055f8 <__mcmp>
 800563e:	1e06      	subs	r6, r0, #0
 8005640:	d108      	bne.n	8005654 <__mdiff+0x28>
 8005642:	4631      	mov	r1, r6
 8005644:	4638      	mov	r0, r7
 8005646:	f7ff fdc3 	bl	80051d0 <_Balloc>
 800564a:	2301      	movs	r3, #1
 800564c:	e9c0 3604 	strd	r3, r6, [r0, #16]
 8005650:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005654:	bfa4      	itt	ge
 8005656:	4623      	movge	r3, r4
 8005658:	462c      	movge	r4, r5
 800565a:	4638      	mov	r0, r7
 800565c:	6861      	ldr	r1, [r4, #4]
 800565e:	bfa6      	itte	ge
 8005660:	461d      	movge	r5, r3
 8005662:	2600      	movge	r6, #0
 8005664:	2601      	movlt	r6, #1
 8005666:	f7ff fdb3 	bl	80051d0 <_Balloc>
 800566a:	f04f 0e00 	mov.w	lr, #0
 800566e:	60c6      	str	r6, [r0, #12]
 8005670:	692b      	ldr	r3, [r5, #16]
 8005672:	6926      	ldr	r6, [r4, #16]
 8005674:	f104 0214 	add.w	r2, r4, #20
 8005678:	f105 0914 	add.w	r9, r5, #20
 800567c:	eb02 0786 	add.w	r7, r2, r6, lsl #2
 8005680:	eb09 0883 	add.w	r8, r9, r3, lsl #2
 8005684:	f100 0114 	add.w	r1, r0, #20
 8005688:	f852 ab04 	ldr.w	sl, [r2], #4
 800568c:	f859 5b04 	ldr.w	r5, [r9], #4
 8005690:	fa1f f38a 	uxth.w	r3, sl
 8005694:	4473      	add	r3, lr
 8005696:	b2ac      	uxth	r4, r5
 8005698:	1b1b      	subs	r3, r3, r4
 800569a:	0c2c      	lsrs	r4, r5, #16
 800569c:	ebc4 441a 	rsb	r4, r4, sl, lsr #16
 80056a0:	eb04 4423 	add.w	r4, r4, r3, asr #16
 80056a4:	b29b      	uxth	r3, r3
 80056a6:	ea4f 4e24 	mov.w	lr, r4, asr #16
 80056aa:	45c8      	cmp	r8, r9
 80056ac:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80056b0:	4694      	mov	ip, r2
 80056b2:	f841 4b04 	str.w	r4, [r1], #4
 80056b6:	d8e7      	bhi.n	8005688 <__mdiff+0x5c>
 80056b8:	45bc      	cmp	ip, r7
 80056ba:	d304      	bcc.n	80056c6 <__mdiff+0x9a>
 80056bc:	f851 3d04 	ldr.w	r3, [r1, #-4]!
 80056c0:	b183      	cbz	r3, 80056e4 <__mdiff+0xb8>
 80056c2:	6106      	str	r6, [r0, #16]
 80056c4:	e7c4      	b.n	8005650 <__mdiff+0x24>
 80056c6:	f85c 4b04 	ldr.w	r4, [ip], #4
 80056ca:	b2a2      	uxth	r2, r4
 80056cc:	4472      	add	r2, lr
 80056ce:	1413      	asrs	r3, r2, #16
 80056d0:	eb03 4314 	add.w	r3, r3, r4, lsr #16
 80056d4:	b292      	uxth	r2, r2
 80056d6:	ea42 4203 	orr.w	r2, r2, r3, lsl #16
 80056da:	ea4f 4e23 	mov.w	lr, r3, asr #16
 80056de:	f841 2b04 	str.w	r2, [r1], #4
 80056e2:	e7e9      	b.n	80056b8 <__mdiff+0x8c>
 80056e4:	3e01      	subs	r6, #1
 80056e6:	e7e9      	b.n	80056bc <__mdiff+0x90>

080056e8 <__d2b>:
 80056e8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80056ec:	461c      	mov	r4, r3
 80056ee:	e9dd 6508 	ldrd	r6, r5, [sp, #32]
 80056f2:	2101      	movs	r1, #1
 80056f4:	4690      	mov	r8, r2
 80056f6:	f7ff fd6b 	bl	80051d0 <_Balloc>
 80056fa:	f3c4 0213 	ubfx	r2, r4, #0, #20
 80056fe:	f3c4 540a 	ubfx	r4, r4, #20, #11
 8005702:	4607      	mov	r7, r0
 8005704:	bb34      	cbnz	r4, 8005754 <__d2b+0x6c>
 8005706:	9201      	str	r2, [sp, #4]
 8005708:	f1b8 0200 	subs.w	r2, r8, #0
 800570c:	d027      	beq.n	800575e <__d2b+0x76>
 800570e:	a802      	add	r0, sp, #8
 8005710:	f840 2d08 	str.w	r2, [r0, #-8]!
 8005714:	f7ff fe01 	bl	800531a <__lo0bits>
 8005718:	9900      	ldr	r1, [sp, #0]
 800571a:	b1f0      	cbz	r0, 800575a <__d2b+0x72>
 800571c:	9a01      	ldr	r2, [sp, #4]
 800571e:	f1c0 0320 	rsb	r3, r0, #32
 8005722:	fa02 f303 	lsl.w	r3, r2, r3
 8005726:	430b      	orrs	r3, r1
 8005728:	40c2      	lsrs	r2, r0
 800572a:	617b      	str	r3, [r7, #20]
 800572c:	9201      	str	r2, [sp, #4]
 800572e:	9b01      	ldr	r3, [sp, #4]
 8005730:	2b00      	cmp	r3, #0
 8005732:	bf14      	ite	ne
 8005734:	2102      	movne	r1, #2
 8005736:	2101      	moveq	r1, #1
 8005738:	61bb      	str	r3, [r7, #24]
 800573a:	6139      	str	r1, [r7, #16]
 800573c:	b1c4      	cbz	r4, 8005770 <__d2b+0x88>
 800573e:	f2a4 4433 	subw	r4, r4, #1075	; 0x433
 8005742:	4404      	add	r4, r0
 8005744:	6034      	str	r4, [r6, #0]
 8005746:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 800574a:	6028      	str	r0, [r5, #0]
 800574c:	4638      	mov	r0, r7
 800574e:	b002      	add	sp, #8
 8005750:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005754:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8005758:	e7d5      	b.n	8005706 <__d2b+0x1e>
 800575a:	6179      	str	r1, [r7, #20]
 800575c:	e7e7      	b.n	800572e <__d2b+0x46>
 800575e:	a801      	add	r0, sp, #4
 8005760:	f7ff fddb 	bl	800531a <__lo0bits>
 8005764:	2101      	movs	r1, #1
 8005766:	9b01      	ldr	r3, [sp, #4]
 8005768:	6139      	str	r1, [r7, #16]
 800576a:	617b      	str	r3, [r7, #20]
 800576c:	3020      	adds	r0, #32
 800576e:	e7e5      	b.n	800573c <__d2b+0x54>
 8005770:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 8005774:	eb07 0381 	add.w	r3, r7, r1, lsl #2
 8005778:	6030      	str	r0, [r6, #0]
 800577a:	6918      	ldr	r0, [r3, #16]
 800577c:	f7ff fdae 	bl	80052dc <__hi0bits>
 8005780:	ebc0 1041 	rsb	r0, r0, r1, lsl #5
 8005784:	e7e1      	b.n	800574a <__d2b+0x62>
	...

08005788 <_mprec_log10>:
 8005788:	2817      	cmp	r0, #23
 800578a:	b5d0      	push	{r4, r6, r7, lr}
 800578c:	4604      	mov	r4, r0
 800578e:	dc05      	bgt.n	800579c <_mprec_log10+0x14>
 8005790:	4b08      	ldr	r3, [pc, #32]	; (80057b4 <_mprec_log10+0x2c>)
 8005792:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
 8005796:	e9d4 0100 	ldrd	r0, r1, [r4]
 800579a:	bdd0      	pop	{r4, r6, r7, pc}
 800579c:	2000      	movs	r0, #0
 800579e:	2600      	movs	r6, #0
 80057a0:	4905      	ldr	r1, [pc, #20]	; (80057b8 <_mprec_log10+0x30>)
 80057a2:	4f06      	ldr	r7, [pc, #24]	; (80057bc <_mprec_log10+0x34>)
 80057a4:	4632      	mov	r2, r6
 80057a6:	463b      	mov	r3, r7
 80057a8:	f7fa fe96 	bl	80004d8 <__aeabi_dmul>
 80057ac:	3c01      	subs	r4, #1
 80057ae:	d1f9      	bne.n	80057a4 <_mprec_log10+0x1c>
 80057b0:	e7f3      	b.n	800579a <_mprec_log10+0x12>
 80057b2:	bf00      	nop
 80057b4:	08006738 	.word	0x08006738
 80057b8:	3ff00000 	.word	0x3ff00000
 80057bc:	40240000 	.word	0x40240000

080057c0 <_calloc_r>:
 80057c0:	b538      	push	{r3, r4, r5, lr}
 80057c2:	fb02 f401 	mul.w	r4, r2, r1
 80057c6:	4621      	mov	r1, r4
 80057c8:	f000 f808 	bl	80057dc <_malloc_r>
 80057cc:	4605      	mov	r5, r0
 80057ce:	b118      	cbz	r0, 80057d8 <_calloc_r+0x18>
 80057d0:	4622      	mov	r2, r4
 80057d2:	2100      	movs	r1, #0
 80057d4:	f7ff faab 	bl	8004d2e <memset>
 80057d8:	4628      	mov	r0, r5
 80057da:	bd38      	pop	{r3, r4, r5, pc}

080057dc <_malloc_r>:
 80057dc:	b570      	push	{r4, r5, r6, lr}
 80057de:	1ccd      	adds	r5, r1, #3
 80057e0:	f025 0503 	bic.w	r5, r5, #3
 80057e4:	3508      	adds	r5, #8
 80057e6:	2d0c      	cmp	r5, #12
 80057e8:	bf38      	it	cc
 80057ea:	250c      	movcc	r5, #12
 80057ec:	2d00      	cmp	r5, #0
 80057ee:	4606      	mov	r6, r0
 80057f0:	db01      	blt.n	80057f6 <_malloc_r+0x1a>
 80057f2:	42a9      	cmp	r1, r5
 80057f4:	d903      	bls.n	80057fe <_malloc_r+0x22>
 80057f6:	230c      	movs	r3, #12
 80057f8:	6033      	str	r3, [r6, #0]
 80057fa:	2000      	movs	r0, #0
 80057fc:	bd70      	pop	{r4, r5, r6, pc}
 80057fe:	f000 feaf 	bl	8006560 <__malloc_lock>
 8005802:	4a21      	ldr	r2, [pc, #132]	; (8005888 <_malloc_r+0xac>)
 8005804:	6814      	ldr	r4, [r2, #0]
 8005806:	4621      	mov	r1, r4
 8005808:	b991      	cbnz	r1, 8005830 <_malloc_r+0x54>
 800580a:	4c20      	ldr	r4, [pc, #128]	; (800588c <_malloc_r+0xb0>)
 800580c:	6823      	ldr	r3, [r4, #0]
 800580e:	b91b      	cbnz	r3, 8005818 <_malloc_r+0x3c>
 8005810:	4630      	mov	r0, r6
 8005812:	f000 f83d 	bl	8005890 <_sbrk_r>
 8005816:	6020      	str	r0, [r4, #0]
 8005818:	4629      	mov	r1, r5
 800581a:	4630      	mov	r0, r6
 800581c:	f000 f838 	bl	8005890 <_sbrk_r>
 8005820:	1c43      	adds	r3, r0, #1
 8005822:	d124      	bne.n	800586e <_malloc_r+0x92>
 8005824:	230c      	movs	r3, #12
 8005826:	4630      	mov	r0, r6
 8005828:	6033      	str	r3, [r6, #0]
 800582a:	f000 fe9a 	bl	8006562 <__malloc_unlock>
 800582e:	e7e4      	b.n	80057fa <_malloc_r+0x1e>
 8005830:	680b      	ldr	r3, [r1, #0]
 8005832:	1b5b      	subs	r3, r3, r5
 8005834:	d418      	bmi.n	8005868 <_malloc_r+0x8c>
 8005836:	2b0b      	cmp	r3, #11
 8005838:	d90f      	bls.n	800585a <_malloc_r+0x7e>
 800583a:	600b      	str	r3, [r1, #0]
 800583c:	18cc      	adds	r4, r1, r3
 800583e:	50cd      	str	r5, [r1, r3]
 8005840:	4630      	mov	r0, r6
 8005842:	f000 fe8e 	bl	8006562 <__malloc_unlock>
 8005846:	f104 000b 	add.w	r0, r4, #11
 800584a:	1d23      	adds	r3, r4, #4
 800584c:	f020 0007 	bic.w	r0, r0, #7
 8005850:	1ac3      	subs	r3, r0, r3
 8005852:	d0d3      	beq.n	80057fc <_malloc_r+0x20>
 8005854:	425a      	negs	r2, r3
 8005856:	50e2      	str	r2, [r4, r3]
 8005858:	e7d0      	b.n	80057fc <_malloc_r+0x20>
 800585a:	684b      	ldr	r3, [r1, #4]
 800585c:	428c      	cmp	r4, r1
 800585e:	bf16      	itet	ne
 8005860:	6063      	strne	r3, [r4, #4]
 8005862:	6013      	streq	r3, [r2, #0]
 8005864:	460c      	movne	r4, r1
 8005866:	e7eb      	b.n	8005840 <_malloc_r+0x64>
 8005868:	460c      	mov	r4, r1
 800586a:	6849      	ldr	r1, [r1, #4]
 800586c:	e7cc      	b.n	8005808 <_malloc_r+0x2c>
 800586e:	1cc4      	adds	r4, r0, #3
 8005870:	f024 0403 	bic.w	r4, r4, #3
 8005874:	42a0      	cmp	r0, r4
 8005876:	d005      	beq.n	8005884 <_malloc_r+0xa8>
 8005878:	1a21      	subs	r1, r4, r0
 800587a:	4630      	mov	r0, r6
 800587c:	f000 f808 	bl	8005890 <_sbrk_r>
 8005880:	3001      	adds	r0, #1
 8005882:	d0cf      	beq.n	8005824 <_malloc_r+0x48>
 8005884:	6025      	str	r5, [r4, #0]
 8005886:	e7db      	b.n	8005840 <_malloc_r+0x64>
 8005888:	20001b14 	.word	0x20001b14
 800588c:	20001b18 	.word	0x20001b18

08005890 <_sbrk_r>:
 8005890:	b538      	push	{r3, r4, r5, lr}
 8005892:	2300      	movs	r3, #0
 8005894:	4c05      	ldr	r4, [pc, #20]	; (80058ac <_sbrk_r+0x1c>)
 8005896:	4605      	mov	r5, r0
 8005898:	4608      	mov	r0, r1
 800589a:	6023      	str	r3, [r4, #0]
 800589c:	f7fb fdae 	bl	80013fc <_sbrk>
 80058a0:	1c43      	adds	r3, r0, #1
 80058a2:	d102      	bne.n	80058aa <_sbrk_r+0x1a>
 80058a4:	6823      	ldr	r3, [r4, #0]
 80058a6:	b103      	cbz	r3, 80058aa <_sbrk_r+0x1a>
 80058a8:	602b      	str	r3, [r5, #0]
 80058aa:	bd38      	pop	{r3, r4, r5, pc}
 80058ac:	20001d38 	.word	0x20001d38

080058b0 <strcpy>:
 80058b0:	4603      	mov	r3, r0
 80058b2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80058b6:	f803 2b01 	strb.w	r2, [r3], #1
 80058ba:	2a00      	cmp	r2, #0
 80058bc:	d1f9      	bne.n	80058b2 <strcpy+0x2>
 80058be:	4770      	bx	lr

080058c0 <__ascii_wctomb>:
 80058c0:	b149      	cbz	r1, 80058d6 <__ascii_wctomb+0x16>
 80058c2:	2aff      	cmp	r2, #255	; 0xff
 80058c4:	bf8b      	itete	hi
 80058c6:	238a      	movhi	r3, #138	; 0x8a
 80058c8:	700a      	strbls	r2, [r1, #0]
 80058ca:	6003      	strhi	r3, [r0, #0]
 80058cc:	2001      	movls	r0, #1
 80058ce:	bf88      	it	hi
 80058d0:	f04f 30ff 	movhi.w	r0, #4294967295
 80058d4:	4770      	bx	lr
 80058d6:	4608      	mov	r0, r1
 80058d8:	4770      	bx	lr

080058da <quorem>:
 80058da:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80058de:	6903      	ldr	r3, [r0, #16]
 80058e0:	690c      	ldr	r4, [r1, #16]
 80058e2:	4680      	mov	r8, r0
 80058e4:	42a3      	cmp	r3, r4
 80058e6:	f2c0 8084 	blt.w	80059f2 <quorem+0x118>
 80058ea:	3c01      	subs	r4, #1
 80058ec:	f101 0714 	add.w	r7, r1, #20
 80058f0:	f100 0614 	add.w	r6, r0, #20
 80058f4:	f857 5024 	ldr.w	r5, [r7, r4, lsl #2]
 80058f8:	f856 0024 	ldr.w	r0, [r6, r4, lsl #2]
 80058fc:	3501      	adds	r5, #1
 80058fe:	fbb0 f5f5 	udiv	r5, r0, r5
 8005902:	ea4f 0c84 	mov.w	ip, r4, lsl #2
 8005906:	eb06 030c 	add.w	r3, r6, ip
 800590a:	eb07 090c 	add.w	r9, r7, ip
 800590e:	9301      	str	r3, [sp, #4]
 8005910:	b39d      	cbz	r5, 800597a <quorem+0xa0>
 8005912:	f04f 0a00 	mov.w	sl, #0
 8005916:	4638      	mov	r0, r7
 8005918:	46b6      	mov	lr, r6
 800591a:	46d3      	mov	fp, sl
 800591c:	f850 2b04 	ldr.w	r2, [r0], #4
 8005920:	b293      	uxth	r3, r2
 8005922:	fb05 a303 	mla	r3, r5, r3, sl
 8005926:	0c12      	lsrs	r2, r2, #16
 8005928:	ea4f 4a13 	mov.w	sl, r3, lsr #16
 800592c:	fb05 a202 	mla	r2, r5, r2, sl
 8005930:	b29b      	uxth	r3, r3
 8005932:	ebab 0303 	sub.w	r3, fp, r3
 8005936:	f8de b000 	ldr.w	fp, [lr]
 800593a:	ea4f 4a12 	mov.w	sl, r2, lsr #16
 800593e:	fa1f fb8b 	uxth.w	fp, fp
 8005942:	445b      	add	r3, fp
 8005944:	fa1f fb82 	uxth.w	fp, r2
 8005948:	f8de 2000 	ldr.w	r2, [lr]
 800594c:	4581      	cmp	r9, r0
 800594e:	ebcb 4212 	rsb	r2, fp, r2, lsr #16
 8005952:	eb02 4223 	add.w	r2, r2, r3, asr #16
 8005956:	b29b      	uxth	r3, r3
 8005958:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 800595c:	ea4f 4b22 	mov.w	fp, r2, asr #16
 8005960:	f84e 3b04 	str.w	r3, [lr], #4
 8005964:	d2da      	bcs.n	800591c <quorem+0x42>
 8005966:	f856 300c 	ldr.w	r3, [r6, ip]
 800596a:	b933      	cbnz	r3, 800597a <quorem+0xa0>
 800596c:	9b01      	ldr	r3, [sp, #4]
 800596e:	3b04      	subs	r3, #4
 8005970:	429e      	cmp	r6, r3
 8005972:	461a      	mov	r2, r3
 8005974:	d331      	bcc.n	80059da <quorem+0x100>
 8005976:	f8c8 4010 	str.w	r4, [r8, #16]
 800597a:	4640      	mov	r0, r8
 800597c:	f7ff fe3c 	bl	80055f8 <__mcmp>
 8005980:	2800      	cmp	r0, #0
 8005982:	db26      	blt.n	80059d2 <quorem+0xf8>
 8005984:	4630      	mov	r0, r6
 8005986:	f04f 0c00 	mov.w	ip, #0
 800598a:	3501      	adds	r5, #1
 800598c:	f857 1b04 	ldr.w	r1, [r7], #4
 8005990:	f8d0 e000 	ldr.w	lr, [r0]
 8005994:	b28b      	uxth	r3, r1
 8005996:	ebac 0303 	sub.w	r3, ip, r3
 800599a:	fa1f f28e 	uxth.w	r2, lr
 800599e:	4413      	add	r3, r2
 80059a0:	0c0a      	lsrs	r2, r1, #16
 80059a2:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 80059a6:	eb02 4223 	add.w	r2, r2, r3, asr #16
 80059aa:	b29b      	uxth	r3, r3
 80059ac:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80059b0:	45b9      	cmp	r9, r7
 80059b2:	ea4f 4c22 	mov.w	ip, r2, asr #16
 80059b6:	f840 3b04 	str.w	r3, [r0], #4
 80059ba:	d2e7      	bcs.n	800598c <quorem+0xb2>
 80059bc:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 80059c0:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 80059c4:	b92a      	cbnz	r2, 80059d2 <quorem+0xf8>
 80059c6:	3b04      	subs	r3, #4
 80059c8:	429e      	cmp	r6, r3
 80059ca:	461a      	mov	r2, r3
 80059cc:	d30b      	bcc.n	80059e6 <quorem+0x10c>
 80059ce:	f8c8 4010 	str.w	r4, [r8, #16]
 80059d2:	4628      	mov	r0, r5
 80059d4:	b003      	add	sp, #12
 80059d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80059da:	6812      	ldr	r2, [r2, #0]
 80059dc:	3b04      	subs	r3, #4
 80059de:	2a00      	cmp	r2, #0
 80059e0:	d1c9      	bne.n	8005976 <quorem+0x9c>
 80059e2:	3c01      	subs	r4, #1
 80059e4:	e7c4      	b.n	8005970 <quorem+0x96>
 80059e6:	6812      	ldr	r2, [r2, #0]
 80059e8:	3b04      	subs	r3, #4
 80059ea:	2a00      	cmp	r2, #0
 80059ec:	d1ef      	bne.n	80059ce <quorem+0xf4>
 80059ee:	3c01      	subs	r4, #1
 80059f0:	e7ea      	b.n	80059c8 <quorem+0xee>
 80059f2:	2000      	movs	r0, #0
 80059f4:	e7ee      	b.n	80059d4 <quorem+0xfa>
	...

080059f8 <_dtoa_r>:
 80059f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80059fc:	4616      	mov	r6, r2
 80059fe:	461f      	mov	r7, r3
 8005a00:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8005a02:	b095      	sub	sp, #84	; 0x54
 8005a04:	4604      	mov	r4, r0
 8005a06:	f8dd 8084 	ldr.w	r8, [sp, #132]	; 0x84
 8005a0a:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8005a0e:	b93d      	cbnz	r5, 8005a20 <_dtoa_r+0x28>
 8005a10:	2010      	movs	r0, #16
 8005a12:	f7ff fbc3 	bl	800519c <malloc>
 8005a16:	6260      	str	r0, [r4, #36]	; 0x24
 8005a18:	e9c0 5501 	strd	r5, r5, [r0, #4]
 8005a1c:	6005      	str	r5, [r0, #0]
 8005a1e:	60c5      	str	r5, [r0, #12]
 8005a20:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005a22:	6819      	ldr	r1, [r3, #0]
 8005a24:	b151      	cbz	r1, 8005a3c <_dtoa_r+0x44>
 8005a26:	685a      	ldr	r2, [r3, #4]
 8005a28:	2301      	movs	r3, #1
 8005a2a:	4093      	lsls	r3, r2
 8005a2c:	604a      	str	r2, [r1, #4]
 8005a2e:	608b      	str	r3, [r1, #8]
 8005a30:	4620      	mov	r0, r4
 8005a32:	f7ff fc01 	bl	8005238 <_Bfree>
 8005a36:	2200      	movs	r2, #0
 8005a38:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005a3a:	601a      	str	r2, [r3, #0]
 8005a3c:	1e3b      	subs	r3, r7, #0
 8005a3e:	bfaf      	iteee	ge
 8005a40:	2300      	movge	r3, #0
 8005a42:	2201      	movlt	r2, #1
 8005a44:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 8005a48:	9303      	strlt	r3, [sp, #12]
 8005a4a:	bfac      	ite	ge
 8005a4c:	f8c8 3000 	strge.w	r3, [r8]
 8005a50:	f8c8 2000 	strlt.w	r2, [r8]
 8005a54:	4bae      	ldr	r3, [pc, #696]	; (8005d10 <_dtoa_r+0x318>)
 8005a56:	f8dd 800c 	ldr.w	r8, [sp, #12]
 8005a5a:	ea33 0308 	bics.w	r3, r3, r8
 8005a5e:	d11b      	bne.n	8005a98 <_dtoa_r+0xa0>
 8005a60:	f242 730f 	movw	r3, #9999	; 0x270f
 8005a64:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8005a66:	6013      	str	r3, [r2, #0]
 8005a68:	9b02      	ldr	r3, [sp, #8]
 8005a6a:	b923      	cbnz	r3, 8005a76 <_dtoa_r+0x7e>
 8005a6c:	f3c8 0013 	ubfx	r0, r8, #0, #20
 8005a70:	2800      	cmp	r0, #0
 8005a72:	f000 8545 	beq.w	8006500 <_dtoa_r+0xb08>
 8005a76:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8005a78:	b953      	cbnz	r3, 8005a90 <_dtoa_r+0x98>
 8005a7a:	4ba6      	ldr	r3, [pc, #664]	; (8005d14 <_dtoa_r+0x31c>)
 8005a7c:	e021      	b.n	8005ac2 <_dtoa_r+0xca>
 8005a7e:	4ba6      	ldr	r3, [pc, #664]	; (8005d18 <_dtoa_r+0x320>)
 8005a80:	9306      	str	r3, [sp, #24]
 8005a82:	3308      	adds	r3, #8
 8005a84:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8005a86:	6013      	str	r3, [r2, #0]
 8005a88:	9806      	ldr	r0, [sp, #24]
 8005a8a:	b015      	add	sp, #84	; 0x54
 8005a8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005a90:	4ba0      	ldr	r3, [pc, #640]	; (8005d14 <_dtoa_r+0x31c>)
 8005a92:	9306      	str	r3, [sp, #24]
 8005a94:	3303      	adds	r3, #3
 8005a96:	e7f5      	b.n	8005a84 <_dtoa_r+0x8c>
 8005a98:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8005a9c:	2200      	movs	r2, #0
 8005a9e:	2300      	movs	r3, #0
 8005aa0:	4630      	mov	r0, r6
 8005aa2:	4639      	mov	r1, r7
 8005aa4:	f7fa ff80 	bl	80009a8 <__aeabi_dcmpeq>
 8005aa8:	4682      	mov	sl, r0
 8005aaa:	b160      	cbz	r0, 8005ac6 <_dtoa_r+0xce>
 8005aac:	2301      	movs	r3, #1
 8005aae:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8005ab0:	6013      	str	r3, [r2, #0]
 8005ab2:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8005ab4:	2b00      	cmp	r3, #0
 8005ab6:	f000 8520 	beq.w	80064fa <_dtoa_r+0xb02>
 8005aba:	4b98      	ldr	r3, [pc, #608]	; (8005d1c <_dtoa_r+0x324>)
 8005abc:	9a22      	ldr	r2, [sp, #136]	; 0x88
 8005abe:	6013      	str	r3, [r2, #0]
 8005ac0:	3b01      	subs	r3, #1
 8005ac2:	9306      	str	r3, [sp, #24]
 8005ac4:	e7e0      	b.n	8005a88 <_dtoa_r+0x90>
 8005ac6:	ab12      	add	r3, sp, #72	; 0x48
 8005ac8:	9301      	str	r3, [sp, #4]
 8005aca:	ab13      	add	r3, sp, #76	; 0x4c
 8005acc:	9300      	str	r3, [sp, #0]
 8005ace:	4632      	mov	r2, r6
 8005ad0:	463b      	mov	r3, r7
 8005ad2:	4620      	mov	r0, r4
 8005ad4:	f7ff fe08 	bl	80056e8 <__d2b>
 8005ad8:	f3c8 550a 	ubfx	r5, r8, #20, #11
 8005adc:	4683      	mov	fp, r0
 8005ade:	2d00      	cmp	r5, #0
 8005ae0:	d07d      	beq.n	8005bde <_dtoa_r+0x1e6>
 8005ae2:	46b0      	mov	r8, r6
 8005ae4:	f3c7 0313 	ubfx	r3, r7, #0, #20
 8005ae8:	f043 597f 	orr.w	r9, r3, #1069547520	; 0x3fc00000
 8005aec:	f449 1940 	orr.w	r9, r9, #3145728	; 0x300000
 8005af0:	f2a5 35ff 	subw	r5, r5, #1023	; 0x3ff
 8005af4:	f8cd a040 	str.w	sl, [sp, #64]	; 0x40
 8005af8:	2200      	movs	r2, #0
 8005afa:	4b89      	ldr	r3, [pc, #548]	; (8005d20 <_dtoa_r+0x328>)
 8005afc:	4640      	mov	r0, r8
 8005afe:	4649      	mov	r1, r9
 8005b00:	f7fa fb32 	bl	8000168 <__aeabi_dsub>
 8005b04:	a37c      	add	r3, pc, #496	; (adr r3, 8005cf8 <_dtoa_r+0x300>)
 8005b06:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b0a:	f7fa fce5 	bl	80004d8 <__aeabi_dmul>
 8005b0e:	a37c      	add	r3, pc, #496	; (adr r3, 8005d00 <_dtoa_r+0x308>)
 8005b10:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b14:	f7fa fb2a 	bl	800016c <__adddf3>
 8005b18:	4606      	mov	r6, r0
 8005b1a:	4628      	mov	r0, r5
 8005b1c:	460f      	mov	r7, r1
 8005b1e:	f7fa fc71 	bl	8000404 <__aeabi_i2d>
 8005b22:	a379      	add	r3, pc, #484	; (adr r3, 8005d08 <_dtoa_r+0x310>)
 8005b24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005b28:	f7fa fcd6 	bl	80004d8 <__aeabi_dmul>
 8005b2c:	4602      	mov	r2, r0
 8005b2e:	460b      	mov	r3, r1
 8005b30:	4630      	mov	r0, r6
 8005b32:	4639      	mov	r1, r7
 8005b34:	f7fa fb1a 	bl	800016c <__adddf3>
 8005b38:	4606      	mov	r6, r0
 8005b3a:	460f      	mov	r7, r1
 8005b3c:	f7fa ff66 	bl	8000a0c <__aeabi_d2iz>
 8005b40:	2200      	movs	r2, #0
 8005b42:	4682      	mov	sl, r0
 8005b44:	2300      	movs	r3, #0
 8005b46:	4630      	mov	r0, r6
 8005b48:	4639      	mov	r1, r7
 8005b4a:	f7fa ff37 	bl	80009bc <__aeabi_dcmplt>
 8005b4e:	b148      	cbz	r0, 8005b64 <_dtoa_r+0x16c>
 8005b50:	4650      	mov	r0, sl
 8005b52:	f7fa fc57 	bl	8000404 <__aeabi_i2d>
 8005b56:	4632      	mov	r2, r6
 8005b58:	463b      	mov	r3, r7
 8005b5a:	f7fa ff25 	bl	80009a8 <__aeabi_dcmpeq>
 8005b5e:	b908      	cbnz	r0, 8005b64 <_dtoa_r+0x16c>
 8005b60:	f10a 3aff 	add.w	sl, sl, #4294967295
 8005b64:	f1ba 0f16 	cmp.w	sl, #22
 8005b68:	d85a      	bhi.n	8005c20 <_dtoa_r+0x228>
 8005b6a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005b6e:	496d      	ldr	r1, [pc, #436]	; (8005d24 <_dtoa_r+0x32c>)
 8005b70:	eb01 01ca 	add.w	r1, r1, sl, lsl #3
 8005b74:	e9d1 0100 	ldrd	r0, r1, [r1]
 8005b78:	f7fa ff3e 	bl	80009f8 <__aeabi_dcmpgt>
 8005b7c:	2800      	cmp	r0, #0
 8005b7e:	d051      	beq.n	8005c24 <_dtoa_r+0x22c>
 8005b80:	2300      	movs	r3, #0
 8005b82:	f10a 3aff 	add.w	sl, sl, #4294967295
 8005b86:	930d      	str	r3, [sp, #52]	; 0x34
 8005b88:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8005b8a:	1b5d      	subs	r5, r3, r5
 8005b8c:	1e6b      	subs	r3, r5, #1
 8005b8e:	9307      	str	r3, [sp, #28]
 8005b90:	bf43      	ittte	mi
 8005b92:	2300      	movmi	r3, #0
 8005b94:	f1c5 0901 	rsbmi	r9, r5, #1
 8005b98:	9307      	strmi	r3, [sp, #28]
 8005b9a:	f04f 0900 	movpl.w	r9, #0
 8005b9e:	f1ba 0f00 	cmp.w	sl, #0
 8005ba2:	db41      	blt.n	8005c28 <_dtoa_r+0x230>
 8005ba4:	9b07      	ldr	r3, [sp, #28]
 8005ba6:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
 8005baa:	4453      	add	r3, sl
 8005bac:	9307      	str	r3, [sp, #28]
 8005bae:	2300      	movs	r3, #0
 8005bb0:	9308      	str	r3, [sp, #32]
 8005bb2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8005bb4:	2b09      	cmp	r3, #9
 8005bb6:	f200 808f 	bhi.w	8005cd8 <_dtoa_r+0x2e0>
 8005bba:	2b05      	cmp	r3, #5
 8005bbc:	bfc4      	itt	gt
 8005bbe:	3b04      	subgt	r3, #4
 8005bc0:	931e      	strgt	r3, [sp, #120]	; 0x78
 8005bc2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8005bc4:	bfc8      	it	gt
 8005bc6:	2500      	movgt	r5, #0
 8005bc8:	f1a3 0302 	sub.w	r3, r3, #2
 8005bcc:	bfd8      	it	le
 8005bce:	2501      	movle	r5, #1
 8005bd0:	2b03      	cmp	r3, #3
 8005bd2:	f200 808d 	bhi.w	8005cf0 <_dtoa_r+0x2f8>
 8005bd6:	e8df f003 	tbb	[pc, r3]
 8005bda:	7d7b      	.short	0x7d7b
 8005bdc:	6f2f      	.short	0x6f2f
 8005bde:	e9dd 5312 	ldrd	r5, r3, [sp, #72]	; 0x48
 8005be2:	441d      	add	r5, r3
 8005be4:	f205 4032 	addw	r0, r5, #1074	; 0x432
 8005be8:	2820      	cmp	r0, #32
 8005bea:	dd13      	ble.n	8005c14 <_dtoa_r+0x21c>
 8005bec:	f1c0 0040 	rsb	r0, r0, #64	; 0x40
 8005bf0:	9b02      	ldr	r3, [sp, #8]
 8005bf2:	fa08 f800 	lsl.w	r8, r8, r0
 8005bf6:	f205 4012 	addw	r0, r5, #1042	; 0x412
 8005bfa:	fa23 f000 	lsr.w	r0, r3, r0
 8005bfe:	ea48 0000 	orr.w	r0, r8, r0
 8005c02:	f7fa fbef 	bl	80003e4 <__aeabi_ui2d>
 8005c06:	2301      	movs	r3, #1
 8005c08:	4680      	mov	r8, r0
 8005c0a:	f1a1 79f8 	sub.w	r9, r1, #32505856	; 0x1f00000
 8005c0e:	3d01      	subs	r5, #1
 8005c10:	9310      	str	r3, [sp, #64]	; 0x40
 8005c12:	e771      	b.n	8005af8 <_dtoa_r+0x100>
 8005c14:	9b02      	ldr	r3, [sp, #8]
 8005c16:	f1c0 0020 	rsb	r0, r0, #32
 8005c1a:	fa03 f000 	lsl.w	r0, r3, r0
 8005c1e:	e7f0      	b.n	8005c02 <_dtoa_r+0x20a>
 8005c20:	2301      	movs	r3, #1
 8005c22:	e7b0      	b.n	8005b86 <_dtoa_r+0x18e>
 8005c24:	900d      	str	r0, [sp, #52]	; 0x34
 8005c26:	e7af      	b.n	8005b88 <_dtoa_r+0x190>
 8005c28:	f1ca 0300 	rsb	r3, sl, #0
 8005c2c:	9308      	str	r3, [sp, #32]
 8005c2e:	2300      	movs	r3, #0
 8005c30:	eba9 090a 	sub.w	r9, r9, sl
 8005c34:	930c      	str	r3, [sp, #48]	; 0x30
 8005c36:	e7bc      	b.n	8005bb2 <_dtoa_r+0x1ba>
 8005c38:	2301      	movs	r3, #1
 8005c3a:	9309      	str	r3, [sp, #36]	; 0x24
 8005c3c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005c3e:	2b00      	cmp	r3, #0
 8005c40:	dd74      	ble.n	8005d2c <_dtoa_r+0x334>
 8005c42:	4698      	mov	r8, r3
 8005c44:	9304      	str	r3, [sp, #16]
 8005c46:	2200      	movs	r2, #0
 8005c48:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8005c4a:	6072      	str	r2, [r6, #4]
 8005c4c:	2204      	movs	r2, #4
 8005c4e:	f102 0014 	add.w	r0, r2, #20
 8005c52:	4298      	cmp	r0, r3
 8005c54:	6871      	ldr	r1, [r6, #4]
 8005c56:	d96e      	bls.n	8005d36 <_dtoa_r+0x33e>
 8005c58:	4620      	mov	r0, r4
 8005c5a:	f7ff fab9 	bl	80051d0 <_Balloc>
 8005c5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c60:	6030      	str	r0, [r6, #0]
 8005c62:	681b      	ldr	r3, [r3, #0]
 8005c64:	f1b8 0f0e 	cmp.w	r8, #14
 8005c68:	9306      	str	r3, [sp, #24]
 8005c6a:	f200 80ed 	bhi.w	8005e48 <_dtoa_r+0x450>
 8005c6e:	2d00      	cmp	r5, #0
 8005c70:	f000 80ea 	beq.w	8005e48 <_dtoa_r+0x450>
 8005c74:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005c78:	f1ba 0f00 	cmp.w	sl, #0
 8005c7c:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 8005c80:	dd77      	ble.n	8005d72 <_dtoa_r+0x37a>
 8005c82:	4a28      	ldr	r2, [pc, #160]	; (8005d24 <_dtoa_r+0x32c>)
 8005c84:	f00a 030f 	and.w	r3, sl, #15
 8005c88:	ea4f 162a 	mov.w	r6, sl, asr #4
 8005c8c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8005c90:	06f0      	lsls	r0, r6, #27
 8005c92:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005c96:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 8005c9a:	d568      	bpl.n	8005d6e <_dtoa_r+0x376>
 8005c9c:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8005ca0:	4b21      	ldr	r3, [pc, #132]	; (8005d28 <_dtoa_r+0x330>)
 8005ca2:	2503      	movs	r5, #3
 8005ca4:	e9d3 2308 	ldrd	r2, r3, [r3, #32]
 8005ca8:	f7fa fd40 	bl	800072c <__aeabi_ddiv>
 8005cac:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005cb0:	f006 060f 	and.w	r6, r6, #15
 8005cb4:	4f1c      	ldr	r7, [pc, #112]	; (8005d28 <_dtoa_r+0x330>)
 8005cb6:	e04f      	b.n	8005d58 <_dtoa_r+0x360>
 8005cb8:	2301      	movs	r3, #1
 8005cba:	9309      	str	r3, [sp, #36]	; 0x24
 8005cbc:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005cbe:	4453      	add	r3, sl
 8005cc0:	f103 0801 	add.w	r8, r3, #1
 8005cc4:	9304      	str	r3, [sp, #16]
 8005cc6:	4643      	mov	r3, r8
 8005cc8:	2b01      	cmp	r3, #1
 8005cca:	bfb8      	it	lt
 8005ccc:	2301      	movlt	r3, #1
 8005cce:	e7ba      	b.n	8005c46 <_dtoa_r+0x24e>
 8005cd0:	2300      	movs	r3, #0
 8005cd2:	e7b2      	b.n	8005c3a <_dtoa_r+0x242>
 8005cd4:	2300      	movs	r3, #0
 8005cd6:	e7f0      	b.n	8005cba <_dtoa_r+0x2c2>
 8005cd8:	2501      	movs	r5, #1
 8005cda:	2300      	movs	r3, #0
 8005cdc:	9509      	str	r5, [sp, #36]	; 0x24
 8005cde:	931e      	str	r3, [sp, #120]	; 0x78
 8005ce0:	f04f 33ff 	mov.w	r3, #4294967295
 8005ce4:	2200      	movs	r2, #0
 8005ce6:	9304      	str	r3, [sp, #16]
 8005ce8:	4698      	mov	r8, r3
 8005cea:	2312      	movs	r3, #18
 8005cec:	921f      	str	r2, [sp, #124]	; 0x7c
 8005cee:	e7aa      	b.n	8005c46 <_dtoa_r+0x24e>
 8005cf0:	2301      	movs	r3, #1
 8005cf2:	9309      	str	r3, [sp, #36]	; 0x24
 8005cf4:	e7f4      	b.n	8005ce0 <_dtoa_r+0x2e8>
 8005cf6:	bf00      	nop
 8005cf8:	636f4361 	.word	0x636f4361
 8005cfc:	3fd287a7 	.word	0x3fd287a7
 8005d00:	8b60c8b3 	.word	0x8b60c8b3
 8005d04:	3fc68a28 	.word	0x3fc68a28
 8005d08:	509f79fb 	.word	0x509f79fb
 8005d0c:	3fd34413 	.word	0x3fd34413
 8005d10:	7ff00000 	.word	0x7ff00000
 8005d14:	08006916 	.word	0x08006916
 8005d18:	0800690d 	.word	0x0800690d
 8005d1c:	0800691b 	.word	0x0800691b
 8005d20:	3ff80000 	.word	0x3ff80000
 8005d24:	08006738 	.word	0x08006738
 8005d28:	08006710 	.word	0x08006710
 8005d2c:	2301      	movs	r3, #1
 8005d2e:	9304      	str	r3, [sp, #16]
 8005d30:	4698      	mov	r8, r3
 8005d32:	461a      	mov	r2, r3
 8005d34:	e7da      	b.n	8005cec <_dtoa_r+0x2f4>
 8005d36:	3101      	adds	r1, #1
 8005d38:	6071      	str	r1, [r6, #4]
 8005d3a:	0052      	lsls	r2, r2, #1
 8005d3c:	e787      	b.n	8005c4e <_dtoa_r+0x256>
 8005d3e:	07f1      	lsls	r1, r6, #31
 8005d40:	d508      	bpl.n	8005d54 <_dtoa_r+0x35c>
 8005d42:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8005d46:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005d4a:	f7fa fbc5 	bl	80004d8 <__aeabi_dmul>
 8005d4e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005d52:	3501      	adds	r5, #1
 8005d54:	1076      	asrs	r6, r6, #1
 8005d56:	3708      	adds	r7, #8
 8005d58:	2e00      	cmp	r6, #0
 8005d5a:	d1f0      	bne.n	8005d3e <_dtoa_r+0x346>
 8005d5c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005d60:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005d64:	f7fa fce2 	bl	800072c <__aeabi_ddiv>
 8005d68:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005d6c:	e01b      	b.n	8005da6 <_dtoa_r+0x3ae>
 8005d6e:	2502      	movs	r5, #2
 8005d70:	e7a0      	b.n	8005cb4 <_dtoa_r+0x2bc>
 8005d72:	f000 80a4 	beq.w	8005ebe <_dtoa_r+0x4c6>
 8005d76:	e9dd 010e 	ldrd	r0, r1, [sp, #56]	; 0x38
 8005d7a:	f1ca 0600 	rsb	r6, sl, #0
 8005d7e:	4ba0      	ldr	r3, [pc, #640]	; (8006000 <_dtoa_r+0x608>)
 8005d80:	f006 020f 	and.w	r2, r6, #15
 8005d84:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8005d88:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005d8c:	f7fa fba4 	bl	80004d8 <__aeabi_dmul>
 8005d90:	2502      	movs	r5, #2
 8005d92:	2300      	movs	r3, #0
 8005d94:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005d98:	4f9a      	ldr	r7, [pc, #616]	; (8006004 <_dtoa_r+0x60c>)
 8005d9a:	1136      	asrs	r6, r6, #4
 8005d9c:	2e00      	cmp	r6, #0
 8005d9e:	f040 8083 	bne.w	8005ea8 <_dtoa_r+0x4b0>
 8005da2:	2b00      	cmp	r3, #0
 8005da4:	d1e0      	bne.n	8005d68 <_dtoa_r+0x370>
 8005da6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8005da8:	2b00      	cmp	r3, #0
 8005daa:	f000 808a 	beq.w	8005ec2 <_dtoa_r+0x4ca>
 8005dae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005db2:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
 8005db6:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8005dba:	2200      	movs	r2, #0
 8005dbc:	4b92      	ldr	r3, [pc, #584]	; (8006008 <_dtoa_r+0x610>)
 8005dbe:	f7fa fdfd 	bl	80009bc <__aeabi_dcmplt>
 8005dc2:	2800      	cmp	r0, #0
 8005dc4:	d07d      	beq.n	8005ec2 <_dtoa_r+0x4ca>
 8005dc6:	f1b8 0f00 	cmp.w	r8, #0
 8005dca:	d07a      	beq.n	8005ec2 <_dtoa_r+0x4ca>
 8005dcc:	9b04      	ldr	r3, [sp, #16]
 8005dce:	2b00      	cmp	r3, #0
 8005dd0:	dd36      	ble.n	8005e40 <_dtoa_r+0x448>
 8005dd2:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8005dd6:	2200      	movs	r2, #0
 8005dd8:	4b8c      	ldr	r3, [pc, #560]	; (800600c <_dtoa_r+0x614>)
 8005dda:	f7fa fb7d 	bl	80004d8 <__aeabi_dmul>
 8005dde:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005de2:	9e04      	ldr	r6, [sp, #16]
 8005de4:	f10a 37ff 	add.w	r7, sl, #4294967295
 8005de8:	3501      	adds	r5, #1
 8005dea:	4628      	mov	r0, r5
 8005dec:	f7fa fb0a 	bl	8000404 <__aeabi_i2d>
 8005df0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005df4:	f7fa fb70 	bl	80004d8 <__aeabi_dmul>
 8005df8:	2200      	movs	r2, #0
 8005dfa:	4b85      	ldr	r3, [pc, #532]	; (8006010 <_dtoa_r+0x618>)
 8005dfc:	f7fa f9b6 	bl	800016c <__adddf3>
 8005e00:	f1a1 7550 	sub.w	r5, r1, #54525952	; 0x3400000
 8005e04:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005e08:	950b      	str	r5, [sp, #44]	; 0x2c
 8005e0a:	2e00      	cmp	r6, #0
 8005e0c:	d15c      	bne.n	8005ec8 <_dtoa_r+0x4d0>
 8005e0e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005e12:	2200      	movs	r2, #0
 8005e14:	4b7f      	ldr	r3, [pc, #508]	; (8006014 <_dtoa_r+0x61c>)
 8005e16:	f7fa f9a7 	bl	8000168 <__aeabi_dsub>
 8005e1a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8005e1c:	462b      	mov	r3, r5
 8005e1e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005e22:	f7fa fde9 	bl	80009f8 <__aeabi_dcmpgt>
 8005e26:	2800      	cmp	r0, #0
 8005e28:	f040 8281 	bne.w	800632e <_dtoa_r+0x936>
 8005e2c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005e30:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8005e32:	f105 4300 	add.w	r3, r5, #2147483648	; 0x80000000
 8005e36:	f7fa fdc1 	bl	80009bc <__aeabi_dcmplt>
 8005e3a:	2800      	cmp	r0, #0
 8005e3c:	f040 8275 	bne.w	800632a <_dtoa_r+0x932>
 8005e40:	e9dd 230e 	ldrd	r2, r3, [sp, #56]	; 0x38
 8005e44:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8005e48:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8005e4a:	2b00      	cmp	r3, #0
 8005e4c:	f2c0 814b 	blt.w	80060e6 <_dtoa_r+0x6ee>
 8005e50:	f1ba 0f0e 	cmp.w	sl, #14
 8005e54:	f300 8147 	bgt.w	80060e6 <_dtoa_r+0x6ee>
 8005e58:	4b69      	ldr	r3, [pc, #420]	; (8006000 <_dtoa_r+0x608>)
 8005e5a:	eb03 03ca 	add.w	r3, r3, sl, lsl #3
 8005e5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005e62:	e9cd 2304 	strd	r2, r3, [sp, #16]
 8005e66:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	f280 80d7 	bge.w	800601c <_dtoa_r+0x624>
 8005e6e:	f1b8 0f00 	cmp.w	r8, #0
 8005e72:	f300 80d3 	bgt.w	800601c <_dtoa_r+0x624>
 8005e76:	f040 8257 	bne.w	8006328 <_dtoa_r+0x930>
 8005e7a:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 8005e7e:	2200      	movs	r2, #0
 8005e80:	4b64      	ldr	r3, [pc, #400]	; (8006014 <_dtoa_r+0x61c>)
 8005e82:	f7fa fb29 	bl	80004d8 <__aeabi_dmul>
 8005e86:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005e8a:	f7fa fdab 	bl	80009e4 <__aeabi_dcmpge>
 8005e8e:	4646      	mov	r6, r8
 8005e90:	4647      	mov	r7, r8
 8005e92:	2800      	cmp	r0, #0
 8005e94:	f040 822d 	bne.w	80062f2 <_dtoa_r+0x8fa>
 8005e98:	9b06      	ldr	r3, [sp, #24]
 8005e9a:	9a06      	ldr	r2, [sp, #24]
 8005e9c:	1c5d      	adds	r5, r3, #1
 8005e9e:	2331      	movs	r3, #49	; 0x31
 8005ea0:	f10a 0a01 	add.w	sl, sl, #1
 8005ea4:	7013      	strb	r3, [r2, #0]
 8005ea6:	e228      	b.n	80062fa <_dtoa_r+0x902>
 8005ea8:	07f2      	lsls	r2, r6, #31
 8005eaa:	d505      	bpl.n	8005eb8 <_dtoa_r+0x4c0>
 8005eac:	e9d7 2300 	ldrd	r2, r3, [r7]
 8005eb0:	f7fa fb12 	bl	80004d8 <__aeabi_dmul>
 8005eb4:	2301      	movs	r3, #1
 8005eb6:	3501      	adds	r5, #1
 8005eb8:	1076      	asrs	r6, r6, #1
 8005eba:	3708      	adds	r7, #8
 8005ebc:	e76e      	b.n	8005d9c <_dtoa_r+0x3a4>
 8005ebe:	2502      	movs	r5, #2
 8005ec0:	e771      	b.n	8005da6 <_dtoa_r+0x3ae>
 8005ec2:	4657      	mov	r7, sl
 8005ec4:	4646      	mov	r6, r8
 8005ec6:	e790      	b.n	8005dea <_dtoa_r+0x3f2>
 8005ec8:	4b4d      	ldr	r3, [pc, #308]	; (8006000 <_dtoa_r+0x608>)
 8005eca:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
 8005ece:	e953 0102 	ldrd	r0, r1, [r3, #-8]
 8005ed2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005ed4:	2b00      	cmp	r3, #0
 8005ed6:	d048      	beq.n	8005f6a <_dtoa_r+0x572>
 8005ed8:	4602      	mov	r2, r0
 8005eda:	460b      	mov	r3, r1
 8005edc:	2000      	movs	r0, #0
 8005ede:	494e      	ldr	r1, [pc, #312]	; (8006018 <_dtoa_r+0x620>)
 8005ee0:	f7fa fc24 	bl	800072c <__aeabi_ddiv>
 8005ee4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005ee8:	f7fa f93e 	bl	8000168 <__aeabi_dsub>
 8005eec:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005ef0:	9d06      	ldr	r5, [sp, #24]
 8005ef2:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005ef6:	f7fa fd89 	bl	8000a0c <__aeabi_d2iz>
 8005efa:	9011      	str	r0, [sp, #68]	; 0x44
 8005efc:	f7fa fa82 	bl	8000404 <__aeabi_i2d>
 8005f00:	4602      	mov	r2, r0
 8005f02:	460b      	mov	r3, r1
 8005f04:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005f08:	f7fa f92e 	bl	8000168 <__aeabi_dsub>
 8005f0c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005f0e:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005f12:	3330      	adds	r3, #48	; 0x30
 8005f14:	f805 3b01 	strb.w	r3, [r5], #1
 8005f18:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005f1c:	f7fa fd4e 	bl	80009bc <__aeabi_dcmplt>
 8005f20:	2800      	cmp	r0, #0
 8005f22:	d163      	bne.n	8005fec <_dtoa_r+0x5f4>
 8005f24:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8005f28:	2000      	movs	r0, #0
 8005f2a:	4937      	ldr	r1, [pc, #220]	; (8006008 <_dtoa_r+0x610>)
 8005f2c:	f7fa f91c 	bl	8000168 <__aeabi_dsub>
 8005f30:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005f34:	f7fa fd42 	bl	80009bc <__aeabi_dcmplt>
 8005f38:	2800      	cmp	r0, #0
 8005f3a:	f040 80b5 	bne.w	80060a8 <_dtoa_r+0x6b0>
 8005f3e:	9b06      	ldr	r3, [sp, #24]
 8005f40:	1aeb      	subs	r3, r5, r3
 8005f42:	429e      	cmp	r6, r3
 8005f44:	f77f af7c 	ble.w	8005e40 <_dtoa_r+0x448>
 8005f48:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8005f4c:	2200      	movs	r2, #0
 8005f4e:	4b2f      	ldr	r3, [pc, #188]	; (800600c <_dtoa_r+0x614>)
 8005f50:	f7fa fac2 	bl	80004d8 <__aeabi_dmul>
 8005f54:	2200      	movs	r2, #0
 8005f56:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005f5a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005f5e:	4b2b      	ldr	r3, [pc, #172]	; (800600c <_dtoa_r+0x614>)
 8005f60:	f7fa faba 	bl	80004d8 <__aeabi_dmul>
 8005f64:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005f68:	e7c3      	b.n	8005ef2 <_dtoa_r+0x4fa>
 8005f6a:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005f6e:	f7fa fab3 	bl	80004d8 <__aeabi_dmul>
 8005f72:	9b06      	ldr	r3, [sp, #24]
 8005f74:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8005f78:	199d      	adds	r5, r3, r6
 8005f7a:	461e      	mov	r6, r3
 8005f7c:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005f80:	f7fa fd44 	bl	8000a0c <__aeabi_d2iz>
 8005f84:	9011      	str	r0, [sp, #68]	; 0x44
 8005f86:	f7fa fa3d 	bl	8000404 <__aeabi_i2d>
 8005f8a:	4602      	mov	r2, r0
 8005f8c:	460b      	mov	r3, r1
 8005f8e:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005f92:	f7fa f8e9 	bl	8000168 <__aeabi_dsub>
 8005f96:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8005f98:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005f9c:	3330      	adds	r3, #48	; 0x30
 8005f9e:	f806 3b01 	strb.w	r3, [r6], #1
 8005fa2:	42ae      	cmp	r6, r5
 8005fa4:	f04f 0200 	mov.w	r2, #0
 8005fa8:	d124      	bne.n	8005ff4 <_dtoa_r+0x5fc>
 8005faa:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
 8005fae:	4b1a      	ldr	r3, [pc, #104]	; (8006018 <_dtoa_r+0x620>)
 8005fb0:	f7fa f8dc 	bl	800016c <__adddf3>
 8005fb4:	4602      	mov	r2, r0
 8005fb6:	460b      	mov	r3, r1
 8005fb8:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005fbc:	f7fa fd1c 	bl	80009f8 <__aeabi_dcmpgt>
 8005fc0:	2800      	cmp	r0, #0
 8005fc2:	d171      	bne.n	80060a8 <_dtoa_r+0x6b0>
 8005fc4:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
 8005fc8:	2000      	movs	r0, #0
 8005fca:	4913      	ldr	r1, [pc, #76]	; (8006018 <_dtoa_r+0x620>)
 8005fcc:	f7fa f8cc 	bl	8000168 <__aeabi_dsub>
 8005fd0:	4602      	mov	r2, r0
 8005fd2:	460b      	mov	r3, r1
 8005fd4:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8005fd8:	f7fa fcf0 	bl	80009bc <__aeabi_dcmplt>
 8005fdc:	2800      	cmp	r0, #0
 8005fde:	f43f af2f 	beq.w	8005e40 <_dtoa_r+0x448>
 8005fe2:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8005fe6:	1e6a      	subs	r2, r5, #1
 8005fe8:	2b30      	cmp	r3, #48	; 0x30
 8005fea:	d001      	beq.n	8005ff0 <_dtoa_r+0x5f8>
 8005fec:	46ba      	mov	sl, r7
 8005fee:	e04a      	b.n	8006086 <_dtoa_r+0x68e>
 8005ff0:	4615      	mov	r5, r2
 8005ff2:	e7f6      	b.n	8005fe2 <_dtoa_r+0x5ea>
 8005ff4:	4b05      	ldr	r3, [pc, #20]	; (800600c <_dtoa_r+0x614>)
 8005ff6:	f7fa fa6f 	bl	80004d8 <__aeabi_dmul>
 8005ffa:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8005ffe:	e7bd      	b.n	8005f7c <_dtoa_r+0x584>
 8006000:	08006738 	.word	0x08006738
 8006004:	08006710 	.word	0x08006710
 8006008:	3ff00000 	.word	0x3ff00000
 800600c:	40240000 	.word	0x40240000
 8006010:	401c0000 	.word	0x401c0000
 8006014:	40140000 	.word	0x40140000
 8006018:	3fe00000 	.word	0x3fe00000
 800601c:	9d06      	ldr	r5, [sp, #24]
 800601e:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8006022:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8006026:	4630      	mov	r0, r6
 8006028:	4639      	mov	r1, r7
 800602a:	f7fa fb7f 	bl	800072c <__aeabi_ddiv>
 800602e:	f7fa fced 	bl	8000a0c <__aeabi_d2iz>
 8006032:	4681      	mov	r9, r0
 8006034:	f7fa f9e6 	bl	8000404 <__aeabi_i2d>
 8006038:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 800603c:	f7fa fa4c 	bl	80004d8 <__aeabi_dmul>
 8006040:	4602      	mov	r2, r0
 8006042:	460b      	mov	r3, r1
 8006044:	4630      	mov	r0, r6
 8006046:	4639      	mov	r1, r7
 8006048:	f7fa f88e 	bl	8000168 <__aeabi_dsub>
 800604c:	f109 0630 	add.w	r6, r9, #48	; 0x30
 8006050:	f805 6b01 	strb.w	r6, [r5], #1
 8006054:	9e06      	ldr	r6, [sp, #24]
 8006056:	4602      	mov	r2, r0
 8006058:	1bae      	subs	r6, r5, r6
 800605a:	45b0      	cmp	r8, r6
 800605c:	460b      	mov	r3, r1
 800605e:	d135      	bne.n	80060cc <_dtoa_r+0x6d4>
 8006060:	f7fa f884 	bl	800016c <__adddf3>
 8006064:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8006068:	4606      	mov	r6, r0
 800606a:	460f      	mov	r7, r1
 800606c:	f7fa fcc4 	bl	80009f8 <__aeabi_dcmpgt>
 8006070:	b9c8      	cbnz	r0, 80060a6 <_dtoa_r+0x6ae>
 8006072:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
 8006076:	4630      	mov	r0, r6
 8006078:	4639      	mov	r1, r7
 800607a:	f7fa fc95 	bl	80009a8 <__aeabi_dcmpeq>
 800607e:	b110      	cbz	r0, 8006086 <_dtoa_r+0x68e>
 8006080:	f019 0f01 	tst.w	r9, #1
 8006084:	d10f      	bne.n	80060a6 <_dtoa_r+0x6ae>
 8006086:	4659      	mov	r1, fp
 8006088:	4620      	mov	r0, r4
 800608a:	f7ff f8d5 	bl	8005238 <_Bfree>
 800608e:	2300      	movs	r3, #0
 8006090:	9a20      	ldr	r2, [sp, #128]	; 0x80
 8006092:	702b      	strb	r3, [r5, #0]
 8006094:	f10a 0301 	add.w	r3, sl, #1
 8006098:	6013      	str	r3, [r2, #0]
 800609a:	9b22      	ldr	r3, [sp, #136]	; 0x88
 800609c:	2b00      	cmp	r3, #0
 800609e:	f43f acf3 	beq.w	8005a88 <_dtoa_r+0x90>
 80060a2:	601d      	str	r5, [r3, #0]
 80060a4:	e4f0      	b.n	8005a88 <_dtoa_r+0x90>
 80060a6:	4657      	mov	r7, sl
 80060a8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80060ac:	1e6b      	subs	r3, r5, #1
 80060ae:	2a39      	cmp	r2, #57	; 0x39
 80060b0:	d106      	bne.n	80060c0 <_dtoa_r+0x6c8>
 80060b2:	9a06      	ldr	r2, [sp, #24]
 80060b4:	429a      	cmp	r2, r3
 80060b6:	d107      	bne.n	80060c8 <_dtoa_r+0x6d0>
 80060b8:	2330      	movs	r3, #48	; 0x30
 80060ba:	7013      	strb	r3, [r2, #0]
 80060bc:	4613      	mov	r3, r2
 80060be:	3701      	adds	r7, #1
 80060c0:	781a      	ldrb	r2, [r3, #0]
 80060c2:	3201      	adds	r2, #1
 80060c4:	701a      	strb	r2, [r3, #0]
 80060c6:	e791      	b.n	8005fec <_dtoa_r+0x5f4>
 80060c8:	461d      	mov	r5, r3
 80060ca:	e7ed      	b.n	80060a8 <_dtoa_r+0x6b0>
 80060cc:	2200      	movs	r2, #0
 80060ce:	4b99      	ldr	r3, [pc, #612]	; (8006334 <_dtoa_r+0x93c>)
 80060d0:	f7fa fa02 	bl	80004d8 <__aeabi_dmul>
 80060d4:	2200      	movs	r2, #0
 80060d6:	2300      	movs	r3, #0
 80060d8:	4606      	mov	r6, r0
 80060da:	460f      	mov	r7, r1
 80060dc:	f7fa fc64 	bl	80009a8 <__aeabi_dcmpeq>
 80060e0:	2800      	cmp	r0, #0
 80060e2:	d09e      	beq.n	8006022 <_dtoa_r+0x62a>
 80060e4:	e7cf      	b.n	8006086 <_dtoa_r+0x68e>
 80060e6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80060e8:	2a00      	cmp	r2, #0
 80060ea:	f000 8088 	beq.w	80061fe <_dtoa_r+0x806>
 80060ee:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80060f0:	2a01      	cmp	r2, #1
 80060f2:	dc6d      	bgt.n	80061d0 <_dtoa_r+0x7d8>
 80060f4:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80060f6:	2a00      	cmp	r2, #0
 80060f8:	d066      	beq.n	80061c8 <_dtoa_r+0x7d0>
 80060fa:	f203 4333 	addw	r3, r3, #1075	; 0x433
 80060fe:	464d      	mov	r5, r9
 8006100:	9e08      	ldr	r6, [sp, #32]
 8006102:	9a07      	ldr	r2, [sp, #28]
 8006104:	2101      	movs	r1, #1
 8006106:	441a      	add	r2, r3
 8006108:	4620      	mov	r0, r4
 800610a:	4499      	add	r9, r3
 800610c:	9207      	str	r2, [sp, #28]
 800610e:	f7ff f933 	bl	8005378 <__i2b>
 8006112:	4607      	mov	r7, r0
 8006114:	2d00      	cmp	r5, #0
 8006116:	dd0b      	ble.n	8006130 <_dtoa_r+0x738>
 8006118:	9b07      	ldr	r3, [sp, #28]
 800611a:	2b00      	cmp	r3, #0
 800611c:	dd08      	ble.n	8006130 <_dtoa_r+0x738>
 800611e:	42ab      	cmp	r3, r5
 8006120:	bfa8      	it	ge
 8006122:	462b      	movge	r3, r5
 8006124:	9a07      	ldr	r2, [sp, #28]
 8006126:	eba9 0903 	sub.w	r9, r9, r3
 800612a:	1aed      	subs	r5, r5, r3
 800612c:	1ad3      	subs	r3, r2, r3
 800612e:	9307      	str	r3, [sp, #28]
 8006130:	9b08      	ldr	r3, [sp, #32]
 8006132:	b1eb      	cbz	r3, 8006170 <_dtoa_r+0x778>
 8006134:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006136:	2b00      	cmp	r3, #0
 8006138:	d065      	beq.n	8006206 <_dtoa_r+0x80e>
 800613a:	b18e      	cbz	r6, 8006160 <_dtoa_r+0x768>
 800613c:	4639      	mov	r1, r7
 800613e:	4632      	mov	r2, r6
 8006140:	4620      	mov	r0, r4
 8006142:	f7ff f9b7 	bl	80054b4 <__pow5mult>
 8006146:	465a      	mov	r2, fp
 8006148:	4601      	mov	r1, r0
 800614a:	4607      	mov	r7, r0
 800614c:	4620      	mov	r0, r4
 800614e:	f7ff f91c 	bl	800538a <__multiply>
 8006152:	4659      	mov	r1, fp
 8006154:	900a      	str	r0, [sp, #40]	; 0x28
 8006156:	4620      	mov	r0, r4
 8006158:	f7ff f86e 	bl	8005238 <_Bfree>
 800615c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800615e:	469b      	mov	fp, r3
 8006160:	9b08      	ldr	r3, [sp, #32]
 8006162:	1b9a      	subs	r2, r3, r6
 8006164:	d004      	beq.n	8006170 <_dtoa_r+0x778>
 8006166:	4659      	mov	r1, fp
 8006168:	4620      	mov	r0, r4
 800616a:	f7ff f9a3 	bl	80054b4 <__pow5mult>
 800616e:	4683      	mov	fp, r0
 8006170:	2101      	movs	r1, #1
 8006172:	4620      	mov	r0, r4
 8006174:	f7ff f900 	bl	8005378 <__i2b>
 8006178:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800617a:	4606      	mov	r6, r0
 800617c:	2b00      	cmp	r3, #0
 800617e:	f000 81c6 	beq.w	800650e <_dtoa_r+0xb16>
 8006182:	461a      	mov	r2, r3
 8006184:	4601      	mov	r1, r0
 8006186:	4620      	mov	r0, r4
 8006188:	f7ff f994 	bl	80054b4 <__pow5mult>
 800618c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 800618e:	4606      	mov	r6, r0
 8006190:	2b01      	cmp	r3, #1
 8006192:	dc3e      	bgt.n	8006212 <_dtoa_r+0x81a>
 8006194:	9b02      	ldr	r3, [sp, #8]
 8006196:	2b00      	cmp	r3, #0
 8006198:	d137      	bne.n	800620a <_dtoa_r+0x812>
 800619a:	9b03      	ldr	r3, [sp, #12]
 800619c:	f3c3 0313 	ubfx	r3, r3, #0, #20
 80061a0:	2b00      	cmp	r3, #0
 80061a2:	d134      	bne.n	800620e <_dtoa_r+0x816>
 80061a4:	9b03      	ldr	r3, [sp, #12]
 80061a6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80061aa:	0d1b      	lsrs	r3, r3, #20
 80061ac:	051b      	lsls	r3, r3, #20
 80061ae:	b12b      	cbz	r3, 80061bc <_dtoa_r+0x7c4>
 80061b0:	9b07      	ldr	r3, [sp, #28]
 80061b2:	f109 0901 	add.w	r9, r9, #1
 80061b6:	3301      	adds	r3, #1
 80061b8:	9307      	str	r3, [sp, #28]
 80061ba:	2301      	movs	r3, #1
 80061bc:	9308      	str	r3, [sp, #32]
 80061be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	d128      	bne.n	8006216 <_dtoa_r+0x81e>
 80061c4:	2001      	movs	r0, #1
 80061c6:	e02e      	b.n	8006226 <_dtoa_r+0x82e>
 80061c8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80061ca:	f1c3 0336 	rsb	r3, r3, #54	; 0x36
 80061ce:	e796      	b.n	80060fe <_dtoa_r+0x706>
 80061d0:	9b08      	ldr	r3, [sp, #32]
 80061d2:	f108 36ff 	add.w	r6, r8, #4294967295
 80061d6:	42b3      	cmp	r3, r6
 80061d8:	bfb7      	itett	lt
 80061da:	9b08      	ldrlt	r3, [sp, #32]
 80061dc:	1b9e      	subge	r6, r3, r6
 80061de:	1af2      	sublt	r2, r6, r3
 80061e0:	9b0c      	ldrlt	r3, [sp, #48]	; 0x30
 80061e2:	bfbf      	itttt	lt
 80061e4:	9608      	strlt	r6, [sp, #32]
 80061e6:	189b      	addlt	r3, r3, r2
 80061e8:	930c      	strlt	r3, [sp, #48]	; 0x30
 80061ea:	2600      	movlt	r6, #0
 80061ec:	f1b8 0f00 	cmp.w	r8, #0
 80061f0:	bfb9      	ittee	lt
 80061f2:	eba9 0508 	sublt.w	r5, r9, r8
 80061f6:	2300      	movlt	r3, #0
 80061f8:	464d      	movge	r5, r9
 80061fa:	4643      	movge	r3, r8
 80061fc:	e781      	b.n	8006102 <_dtoa_r+0x70a>
 80061fe:	9e08      	ldr	r6, [sp, #32]
 8006200:	464d      	mov	r5, r9
 8006202:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8006204:	e786      	b.n	8006114 <_dtoa_r+0x71c>
 8006206:	9a08      	ldr	r2, [sp, #32]
 8006208:	e7ad      	b.n	8006166 <_dtoa_r+0x76e>
 800620a:	2300      	movs	r3, #0
 800620c:	e7d6      	b.n	80061bc <_dtoa_r+0x7c4>
 800620e:	9b02      	ldr	r3, [sp, #8]
 8006210:	e7d4      	b.n	80061bc <_dtoa_r+0x7c4>
 8006212:	2300      	movs	r3, #0
 8006214:	9308      	str	r3, [sp, #32]
 8006216:	6933      	ldr	r3, [r6, #16]
 8006218:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 800621c:	6918      	ldr	r0, [r3, #16]
 800621e:	f7ff f85d 	bl	80052dc <__hi0bits>
 8006222:	f1c0 0020 	rsb	r0, r0, #32
 8006226:	9b07      	ldr	r3, [sp, #28]
 8006228:	4418      	add	r0, r3
 800622a:	f010 001f 	ands.w	r0, r0, #31
 800622e:	d047      	beq.n	80062c0 <_dtoa_r+0x8c8>
 8006230:	f1c0 0320 	rsb	r3, r0, #32
 8006234:	2b04      	cmp	r3, #4
 8006236:	dd3b      	ble.n	80062b0 <_dtoa_r+0x8b8>
 8006238:	9b07      	ldr	r3, [sp, #28]
 800623a:	f1c0 001c 	rsb	r0, r0, #28
 800623e:	4481      	add	r9, r0
 8006240:	4405      	add	r5, r0
 8006242:	4403      	add	r3, r0
 8006244:	9307      	str	r3, [sp, #28]
 8006246:	f1b9 0f00 	cmp.w	r9, #0
 800624a:	dd05      	ble.n	8006258 <_dtoa_r+0x860>
 800624c:	4659      	mov	r1, fp
 800624e:	464a      	mov	r2, r9
 8006250:	4620      	mov	r0, r4
 8006252:	f7ff f97d 	bl	8005550 <__lshift>
 8006256:	4683      	mov	fp, r0
 8006258:	9b07      	ldr	r3, [sp, #28]
 800625a:	2b00      	cmp	r3, #0
 800625c:	dd05      	ble.n	800626a <_dtoa_r+0x872>
 800625e:	4631      	mov	r1, r6
 8006260:	461a      	mov	r2, r3
 8006262:	4620      	mov	r0, r4
 8006264:	f7ff f974 	bl	8005550 <__lshift>
 8006268:	4606      	mov	r6, r0
 800626a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800626c:	b353      	cbz	r3, 80062c4 <_dtoa_r+0x8cc>
 800626e:	4631      	mov	r1, r6
 8006270:	4658      	mov	r0, fp
 8006272:	f7ff f9c1 	bl	80055f8 <__mcmp>
 8006276:	2800      	cmp	r0, #0
 8006278:	da24      	bge.n	80062c4 <_dtoa_r+0x8cc>
 800627a:	2300      	movs	r3, #0
 800627c:	4659      	mov	r1, fp
 800627e:	220a      	movs	r2, #10
 8006280:	4620      	mov	r0, r4
 8006282:	f7fe fff0 	bl	8005266 <__multadd>
 8006286:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006288:	f10a 3aff 	add.w	sl, sl, #4294967295
 800628c:	4683      	mov	fp, r0
 800628e:	2b00      	cmp	r3, #0
 8006290:	f000 8144 	beq.w	800651c <_dtoa_r+0xb24>
 8006294:	2300      	movs	r3, #0
 8006296:	4639      	mov	r1, r7
 8006298:	220a      	movs	r2, #10
 800629a:	4620      	mov	r0, r4
 800629c:	f7fe ffe3 	bl	8005266 <__multadd>
 80062a0:	9b04      	ldr	r3, [sp, #16]
 80062a2:	4607      	mov	r7, r0
 80062a4:	2b00      	cmp	r3, #0
 80062a6:	dc4d      	bgt.n	8006344 <_dtoa_r+0x94c>
 80062a8:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80062aa:	2b02      	cmp	r3, #2
 80062ac:	dd4a      	ble.n	8006344 <_dtoa_r+0x94c>
 80062ae:	e011      	b.n	80062d4 <_dtoa_r+0x8dc>
 80062b0:	d0c9      	beq.n	8006246 <_dtoa_r+0x84e>
 80062b2:	9a07      	ldr	r2, [sp, #28]
 80062b4:	331c      	adds	r3, #28
 80062b6:	441a      	add	r2, r3
 80062b8:	4499      	add	r9, r3
 80062ba:	441d      	add	r5, r3
 80062bc:	4613      	mov	r3, r2
 80062be:	e7c1      	b.n	8006244 <_dtoa_r+0x84c>
 80062c0:	4603      	mov	r3, r0
 80062c2:	e7f6      	b.n	80062b2 <_dtoa_r+0x8ba>
 80062c4:	f1b8 0f00 	cmp.w	r8, #0
 80062c8:	dc36      	bgt.n	8006338 <_dtoa_r+0x940>
 80062ca:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 80062cc:	2b02      	cmp	r3, #2
 80062ce:	dd33      	ble.n	8006338 <_dtoa_r+0x940>
 80062d0:	f8cd 8010 	str.w	r8, [sp, #16]
 80062d4:	9b04      	ldr	r3, [sp, #16]
 80062d6:	b963      	cbnz	r3, 80062f2 <_dtoa_r+0x8fa>
 80062d8:	4631      	mov	r1, r6
 80062da:	2205      	movs	r2, #5
 80062dc:	4620      	mov	r0, r4
 80062de:	f7fe ffc2 	bl	8005266 <__multadd>
 80062e2:	4601      	mov	r1, r0
 80062e4:	4606      	mov	r6, r0
 80062e6:	4658      	mov	r0, fp
 80062e8:	f7ff f986 	bl	80055f8 <__mcmp>
 80062ec:	2800      	cmp	r0, #0
 80062ee:	f73f add3 	bgt.w	8005e98 <_dtoa_r+0x4a0>
 80062f2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80062f4:	9d06      	ldr	r5, [sp, #24]
 80062f6:	ea6f 0a03 	mvn.w	sl, r3
 80062fa:	f04f 0900 	mov.w	r9, #0
 80062fe:	4631      	mov	r1, r6
 8006300:	4620      	mov	r0, r4
 8006302:	f7fe ff99 	bl	8005238 <_Bfree>
 8006306:	2f00      	cmp	r7, #0
 8006308:	f43f aebd 	beq.w	8006086 <_dtoa_r+0x68e>
 800630c:	f1b9 0f00 	cmp.w	r9, #0
 8006310:	d005      	beq.n	800631e <_dtoa_r+0x926>
 8006312:	45b9      	cmp	r9, r7
 8006314:	d003      	beq.n	800631e <_dtoa_r+0x926>
 8006316:	4649      	mov	r1, r9
 8006318:	4620      	mov	r0, r4
 800631a:	f7fe ff8d 	bl	8005238 <_Bfree>
 800631e:	4639      	mov	r1, r7
 8006320:	4620      	mov	r0, r4
 8006322:	f7fe ff89 	bl	8005238 <_Bfree>
 8006326:	e6ae      	b.n	8006086 <_dtoa_r+0x68e>
 8006328:	2600      	movs	r6, #0
 800632a:	4637      	mov	r7, r6
 800632c:	e7e1      	b.n	80062f2 <_dtoa_r+0x8fa>
 800632e:	46ba      	mov	sl, r7
 8006330:	4637      	mov	r7, r6
 8006332:	e5b1      	b.n	8005e98 <_dtoa_r+0x4a0>
 8006334:	40240000 	.word	0x40240000
 8006338:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800633a:	f8cd 8010 	str.w	r8, [sp, #16]
 800633e:	2b00      	cmp	r3, #0
 8006340:	f000 80f3 	beq.w	800652a <_dtoa_r+0xb32>
 8006344:	2d00      	cmp	r5, #0
 8006346:	dd05      	ble.n	8006354 <_dtoa_r+0x95c>
 8006348:	4639      	mov	r1, r7
 800634a:	462a      	mov	r2, r5
 800634c:	4620      	mov	r0, r4
 800634e:	f7ff f8ff 	bl	8005550 <__lshift>
 8006352:	4607      	mov	r7, r0
 8006354:	9b08      	ldr	r3, [sp, #32]
 8006356:	2b00      	cmp	r3, #0
 8006358:	d04c      	beq.n	80063f4 <_dtoa_r+0x9fc>
 800635a:	6879      	ldr	r1, [r7, #4]
 800635c:	4620      	mov	r0, r4
 800635e:	f7fe ff37 	bl	80051d0 <_Balloc>
 8006362:	4605      	mov	r5, r0
 8006364:	693a      	ldr	r2, [r7, #16]
 8006366:	f107 010c 	add.w	r1, r7, #12
 800636a:	3202      	adds	r2, #2
 800636c:	0092      	lsls	r2, r2, #2
 800636e:	300c      	adds	r0, #12
 8006370:	f7fe fcd2 	bl	8004d18 <memcpy>
 8006374:	2201      	movs	r2, #1
 8006376:	4629      	mov	r1, r5
 8006378:	4620      	mov	r0, r4
 800637a:	f7ff f8e9 	bl	8005550 <__lshift>
 800637e:	46b9      	mov	r9, r7
 8006380:	4607      	mov	r7, r0
 8006382:	9b06      	ldr	r3, [sp, #24]
 8006384:	9307      	str	r3, [sp, #28]
 8006386:	9b02      	ldr	r3, [sp, #8]
 8006388:	f003 0301 	and.w	r3, r3, #1
 800638c:	9308      	str	r3, [sp, #32]
 800638e:	4631      	mov	r1, r6
 8006390:	4658      	mov	r0, fp
 8006392:	f7ff faa2 	bl	80058da <quorem>
 8006396:	4649      	mov	r1, r9
 8006398:	4605      	mov	r5, r0
 800639a:	f100 0830 	add.w	r8, r0, #48	; 0x30
 800639e:	4658      	mov	r0, fp
 80063a0:	f7ff f92a 	bl	80055f8 <__mcmp>
 80063a4:	463a      	mov	r2, r7
 80063a6:	9002      	str	r0, [sp, #8]
 80063a8:	4631      	mov	r1, r6
 80063aa:	4620      	mov	r0, r4
 80063ac:	f7ff f93e 	bl	800562c <__mdiff>
 80063b0:	68c3      	ldr	r3, [r0, #12]
 80063b2:	4602      	mov	r2, r0
 80063b4:	bb03      	cbnz	r3, 80063f8 <_dtoa_r+0xa00>
 80063b6:	4601      	mov	r1, r0
 80063b8:	9009      	str	r0, [sp, #36]	; 0x24
 80063ba:	4658      	mov	r0, fp
 80063bc:	f7ff f91c 	bl	80055f8 <__mcmp>
 80063c0:	4603      	mov	r3, r0
 80063c2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80063c4:	4611      	mov	r1, r2
 80063c6:	4620      	mov	r0, r4
 80063c8:	9309      	str	r3, [sp, #36]	; 0x24
 80063ca:	f7fe ff35 	bl	8005238 <_Bfree>
 80063ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80063d0:	b9a3      	cbnz	r3, 80063fc <_dtoa_r+0xa04>
 80063d2:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 80063d4:	b992      	cbnz	r2, 80063fc <_dtoa_r+0xa04>
 80063d6:	9a08      	ldr	r2, [sp, #32]
 80063d8:	b982      	cbnz	r2, 80063fc <_dtoa_r+0xa04>
 80063da:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 80063de:	d029      	beq.n	8006434 <_dtoa_r+0xa3c>
 80063e0:	9b02      	ldr	r3, [sp, #8]
 80063e2:	2b00      	cmp	r3, #0
 80063e4:	dd01      	ble.n	80063ea <_dtoa_r+0x9f2>
 80063e6:	f105 0831 	add.w	r8, r5, #49	; 0x31
 80063ea:	9b07      	ldr	r3, [sp, #28]
 80063ec:	1c5d      	adds	r5, r3, #1
 80063ee:	f883 8000 	strb.w	r8, [r3]
 80063f2:	e784      	b.n	80062fe <_dtoa_r+0x906>
 80063f4:	4638      	mov	r0, r7
 80063f6:	e7c2      	b.n	800637e <_dtoa_r+0x986>
 80063f8:	2301      	movs	r3, #1
 80063fa:	e7e3      	b.n	80063c4 <_dtoa_r+0x9cc>
 80063fc:	9a02      	ldr	r2, [sp, #8]
 80063fe:	2a00      	cmp	r2, #0
 8006400:	db04      	blt.n	800640c <_dtoa_r+0xa14>
 8006402:	d123      	bne.n	800644c <_dtoa_r+0xa54>
 8006404:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8006406:	bb0a      	cbnz	r2, 800644c <_dtoa_r+0xa54>
 8006408:	9a08      	ldr	r2, [sp, #32]
 800640a:	b9fa      	cbnz	r2, 800644c <_dtoa_r+0xa54>
 800640c:	2b00      	cmp	r3, #0
 800640e:	ddec      	ble.n	80063ea <_dtoa_r+0x9f2>
 8006410:	4659      	mov	r1, fp
 8006412:	2201      	movs	r2, #1
 8006414:	4620      	mov	r0, r4
 8006416:	f7ff f89b 	bl	8005550 <__lshift>
 800641a:	4631      	mov	r1, r6
 800641c:	4683      	mov	fp, r0
 800641e:	f7ff f8eb 	bl	80055f8 <__mcmp>
 8006422:	2800      	cmp	r0, #0
 8006424:	dc03      	bgt.n	800642e <_dtoa_r+0xa36>
 8006426:	d1e0      	bne.n	80063ea <_dtoa_r+0x9f2>
 8006428:	f018 0f01 	tst.w	r8, #1
 800642c:	d0dd      	beq.n	80063ea <_dtoa_r+0x9f2>
 800642e:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 8006432:	d1d8      	bne.n	80063e6 <_dtoa_r+0x9ee>
 8006434:	9b07      	ldr	r3, [sp, #28]
 8006436:	9a07      	ldr	r2, [sp, #28]
 8006438:	1c5d      	adds	r5, r3, #1
 800643a:	2339      	movs	r3, #57	; 0x39
 800643c:	7013      	strb	r3, [r2, #0]
 800643e:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 8006442:	1e6a      	subs	r2, r5, #1
 8006444:	2b39      	cmp	r3, #57	; 0x39
 8006446:	d04d      	beq.n	80064e4 <_dtoa_r+0xaec>
 8006448:	3301      	adds	r3, #1
 800644a:	e052      	b.n	80064f2 <_dtoa_r+0xafa>
 800644c:	9a07      	ldr	r2, [sp, #28]
 800644e:	2b00      	cmp	r3, #0
 8006450:	f102 0501 	add.w	r5, r2, #1
 8006454:	dd06      	ble.n	8006464 <_dtoa_r+0xa6c>
 8006456:	f1b8 0f39 	cmp.w	r8, #57	; 0x39
 800645a:	d0eb      	beq.n	8006434 <_dtoa_r+0xa3c>
 800645c:	f108 0801 	add.w	r8, r8, #1
 8006460:	9b07      	ldr	r3, [sp, #28]
 8006462:	e7c4      	b.n	80063ee <_dtoa_r+0x9f6>
 8006464:	9b06      	ldr	r3, [sp, #24]
 8006466:	9a04      	ldr	r2, [sp, #16]
 8006468:	1aeb      	subs	r3, r5, r3
 800646a:	4293      	cmp	r3, r2
 800646c:	f805 8c01 	strb.w	r8, [r5, #-1]
 8006470:	d021      	beq.n	80064b6 <_dtoa_r+0xabe>
 8006472:	4659      	mov	r1, fp
 8006474:	2300      	movs	r3, #0
 8006476:	220a      	movs	r2, #10
 8006478:	4620      	mov	r0, r4
 800647a:	f7fe fef4 	bl	8005266 <__multadd>
 800647e:	45b9      	cmp	r9, r7
 8006480:	4683      	mov	fp, r0
 8006482:	f04f 0300 	mov.w	r3, #0
 8006486:	f04f 020a 	mov.w	r2, #10
 800648a:	4649      	mov	r1, r9
 800648c:	4620      	mov	r0, r4
 800648e:	d105      	bne.n	800649c <_dtoa_r+0xaa4>
 8006490:	f7fe fee9 	bl	8005266 <__multadd>
 8006494:	4681      	mov	r9, r0
 8006496:	4607      	mov	r7, r0
 8006498:	9507      	str	r5, [sp, #28]
 800649a:	e778      	b.n	800638e <_dtoa_r+0x996>
 800649c:	f7fe fee3 	bl	8005266 <__multadd>
 80064a0:	4639      	mov	r1, r7
 80064a2:	4681      	mov	r9, r0
 80064a4:	2300      	movs	r3, #0
 80064a6:	220a      	movs	r2, #10
 80064a8:	4620      	mov	r0, r4
 80064aa:	f7fe fedc 	bl	8005266 <__multadd>
 80064ae:	4607      	mov	r7, r0
 80064b0:	e7f2      	b.n	8006498 <_dtoa_r+0xaa0>
 80064b2:	f04f 0900 	mov.w	r9, #0
 80064b6:	4659      	mov	r1, fp
 80064b8:	2201      	movs	r2, #1
 80064ba:	4620      	mov	r0, r4
 80064bc:	f7ff f848 	bl	8005550 <__lshift>
 80064c0:	4631      	mov	r1, r6
 80064c2:	4683      	mov	fp, r0
 80064c4:	f7ff f898 	bl	80055f8 <__mcmp>
 80064c8:	2800      	cmp	r0, #0
 80064ca:	dcb8      	bgt.n	800643e <_dtoa_r+0xa46>
 80064cc:	d102      	bne.n	80064d4 <_dtoa_r+0xadc>
 80064ce:	f018 0f01 	tst.w	r8, #1
 80064d2:	d1b4      	bne.n	800643e <_dtoa_r+0xa46>
 80064d4:	f815 3c01 	ldrb.w	r3, [r5, #-1]
 80064d8:	1e6a      	subs	r2, r5, #1
 80064da:	2b30      	cmp	r3, #48	; 0x30
 80064dc:	f47f af0f 	bne.w	80062fe <_dtoa_r+0x906>
 80064e0:	4615      	mov	r5, r2
 80064e2:	e7f7      	b.n	80064d4 <_dtoa_r+0xadc>
 80064e4:	9b06      	ldr	r3, [sp, #24]
 80064e6:	4293      	cmp	r3, r2
 80064e8:	d105      	bne.n	80064f6 <_dtoa_r+0xafe>
 80064ea:	2331      	movs	r3, #49	; 0x31
 80064ec:	9a06      	ldr	r2, [sp, #24]
 80064ee:	f10a 0a01 	add.w	sl, sl, #1
 80064f2:	7013      	strb	r3, [r2, #0]
 80064f4:	e703      	b.n	80062fe <_dtoa_r+0x906>
 80064f6:	4615      	mov	r5, r2
 80064f8:	e7a1      	b.n	800643e <_dtoa_r+0xa46>
 80064fa:	4b17      	ldr	r3, [pc, #92]	; (8006558 <_dtoa_r+0xb60>)
 80064fc:	f7ff bae1 	b.w	8005ac2 <_dtoa_r+0xca>
 8006500:	9b22      	ldr	r3, [sp, #136]	; 0x88
 8006502:	2b00      	cmp	r3, #0
 8006504:	f47f aabb 	bne.w	8005a7e <_dtoa_r+0x86>
 8006508:	4b14      	ldr	r3, [pc, #80]	; (800655c <_dtoa_r+0xb64>)
 800650a:	f7ff bada 	b.w	8005ac2 <_dtoa_r+0xca>
 800650e:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8006510:	2b01      	cmp	r3, #1
 8006512:	f77f ae3f 	ble.w	8006194 <_dtoa_r+0x79c>
 8006516:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006518:	9308      	str	r3, [sp, #32]
 800651a:	e653      	b.n	80061c4 <_dtoa_r+0x7cc>
 800651c:	9b04      	ldr	r3, [sp, #16]
 800651e:	2b00      	cmp	r3, #0
 8006520:	dc03      	bgt.n	800652a <_dtoa_r+0xb32>
 8006522:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8006524:	2b02      	cmp	r3, #2
 8006526:	f73f aed5 	bgt.w	80062d4 <_dtoa_r+0x8dc>
 800652a:	9d06      	ldr	r5, [sp, #24]
 800652c:	4631      	mov	r1, r6
 800652e:	4658      	mov	r0, fp
 8006530:	f7ff f9d3 	bl	80058da <quorem>
 8006534:	9b06      	ldr	r3, [sp, #24]
 8006536:	f100 0830 	add.w	r8, r0, #48	; 0x30
 800653a:	f805 8b01 	strb.w	r8, [r5], #1
 800653e:	9a04      	ldr	r2, [sp, #16]
 8006540:	1aeb      	subs	r3, r5, r3
 8006542:	429a      	cmp	r2, r3
 8006544:	ddb5      	ble.n	80064b2 <_dtoa_r+0xaba>
 8006546:	4659      	mov	r1, fp
 8006548:	2300      	movs	r3, #0
 800654a:	220a      	movs	r2, #10
 800654c:	4620      	mov	r0, r4
 800654e:	f7fe fe8a 	bl	8005266 <__multadd>
 8006552:	4683      	mov	fp, r0
 8006554:	e7ea      	b.n	800652c <_dtoa_r+0xb34>
 8006556:	bf00      	nop
 8006558:	0800691a 	.word	0x0800691a
 800655c:	0800690d 	.word	0x0800690d

08006560 <__malloc_lock>:
 8006560:	4770      	bx	lr

08006562 <__malloc_unlock>:
 8006562:	4770      	bx	lr

08006564 <_init>:
 8006564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006566:	bf00      	nop
 8006568:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800656a:	bc08      	pop	{r3}
 800656c:	469e      	mov	lr, r3
 800656e:	4770      	bx	lr

08006570 <_fini>:
 8006570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006572:	bf00      	nop
 8006574:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8006576:	bc08      	pop	{r3}
 8006578:	469e      	mov	lr, r3
 800657a:	4770      	bx	lr
